["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/editOnPaste.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$editOnPaste=function(global,process,require,module,exports,shadow$shims){function insertFragment(editorState,fragment,entityMap){fragment=DraftModifier.replaceWithFragment(editorState.getCurrentContent(),editorState.getSelection(),fragment);return EditorState.push(editorState,fragment.set(\"entityMap\",entityMap),\"insert-fragment\")}function areTextBlocksAndClipboardEqual(textBlocks,blockMap){return textBlocks.length===blockMap.size&&blockMap.valueSeq().every(function(block,\nii){return block.getText()===textBlocks[ii]})}var BlockMapBuilder=require(\"module$node_modules$draft_js$lib$BlockMapBuilder\"),CharacterMetadata=require(\"module$node_modules$draft_js$lib$CharacterMetadata\"),DataTransfer=require(\"module$node_modules$fbjs$lib$DataTransfer\"),DraftModifier=require(\"module$node_modules$draft_js$lib$DraftModifier\"),DraftPasteProcessor=require(\"module$node_modules$draft_js$lib$DraftPasteProcessor\"),EditorState=require(\"module$node_modules$draft_js$lib$EditorState\"),RichTextEditorUtil=\nrequire(\"module$node_modules$draft_js$lib$RichTextEditorUtil\"),getEntityKeyForSelection=require(\"module$node_modules$draft_js$lib$getEntityKeyForSelection\"),getTextContentFromFiles=require(\"module$node_modules$draft_js$lib$getTextContentFromFiles\"),isEventHandled=require(\"module$node_modules$draft_js$lib$isEventHandled\"),splitTextIntoTextBlocks=require(\"module$node_modules$draft_js$lib$splitTextIntoTextBlocks\");module.exports=function(editor,e){e.preventDefault();var data=new DataTransfer(e.clipboardData);\nif(!data.isRichText()){e=data.getFiles();var defaultFileText=data.getText();if(0<e.length){if(editor.props.handlePastedFiles&&isEventHandled(editor.props.handlePastedFiles(e)))return;getTextContentFromFiles(e,function(fileText){if(fileText=fileText||defaultFileText){var editorState=editor._latestEditorState;fileText=splitTextIntoTextBlocks(fileText);var character=CharacterMetadata.create({style:editorState.getCurrentInlineStyle(),entity:getEntityKeyForSelection(editorState.getCurrentContent(),editorState.getSelection())}),\ncurrentBlockType=RichTextEditorUtil.getCurrentBlockType(editorState);fileText=DraftPasteProcessor.processText(fileText,character,currentBlockType);fileText=BlockMapBuilder.createFromArray(fileText);fileText=DraftModifier.replaceWithFragment(editorState.getCurrentContent(),editorState.getSelection(),fileText);editor.update(EditorState.push(editorState,fileText,\"insert-fragment\"))}});return}}e=[];var text=data.getText(),html=data.getHTML(),editorState$jscomp$0=editor._latestEditorState;if(!editor.props.handlePastedText||\n!isEventHandled(editor.props.handlePastedText(text,html,editorState$jscomp$0))){text&&(e=splitTextIntoTextBlocks(text));if(!editor.props.stripPastedStyles){var internalClipboard=editor.getClipboard();if(data.isRichText()&&internalClipboard){if(-1!==html.indexOf(editor.getEditorKey())||1===e.length&&1===internalClipboard.size&&internalClipboard.first().getText()===text){editor.update(insertFragment(editor._latestEditorState,internalClipboard));return}}else if(internalClipboard&&data.types.includes(\"com.apple.webarchive\")&&\n!data.types.includes(\"text/html\")&&areTextBlocksAndClipboardEqual(e,internalClipboard)){editor.update(insertFragment(editor._latestEditorState,internalClipboard));return}if(html&&(text=DraftPasteProcessor.processHTML(html,editor.props.blockRenderMap))&&(data=text.contentBlocks,text=text.entityMap,data)){e=BlockMapBuilder.createFromArray(data);editor.update(insertFragment(editor._latestEditorState,e,text));return}editor.setClipboard(null)}e.length&&(data=CharacterMetadata.create({style:editorState$jscomp$0.getCurrentInlineStyle(),\nentity:getEntityKeyForSelection(editorState$jscomp$0.getCurrentContent(),editorState$jscomp$0.getSelection())}),editorState$jscomp$0=RichTextEditorUtil.getCurrentBlockType(editorState$jscomp$0),e=DraftPasteProcessor.processText(e,data,editorState$jscomp$0),e=BlockMapBuilder.createFromArray(e),editor.update(insertFragment(editor._latestEditorState,e)))}}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$editOnPaste\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule editOnPaste\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar CharacterMetadata = require('./CharacterMetadata');\nvar DataTransfer = require('fbjs/lib/DataTransfer');\nvar DraftModifier = require('./DraftModifier');\nvar DraftPasteProcessor = require('./DraftPasteProcessor');\nvar EditorState = require('./EditorState');\nvar RichTextEditorUtil = require('./RichTextEditorUtil');\n\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\nvar getTextContentFromFiles = require('./getTextContentFromFiles');\nvar isEventHandled = require('./isEventHandled');\nvar splitTextIntoTextBlocks = require('./splitTextIntoTextBlocks');\n\n/**\n * Paste content.\n */\nfunction editOnPaste(editor, e) {\n  e.preventDefault();\n  var data = new DataTransfer(e.clipboardData);\n\n  // Get files, unless this is likely to be a string the user wants inline.\n  if (!data.isRichText()) {\n    var files = data.getFiles();\n    var defaultFileText = data.getText();\n    if (files.length > 0) {\n      // Allow customized paste handling for images, etc. Otherwise, fall\n      // through to insert text contents into the editor.\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\n        return;\n      }\n\n      getTextContentFromFiles(files, function ( /*string*/fileText) {\n        fileText = fileText || defaultFileText;\n        if (!fileText) {\n          return;\n        }\n\n        var editorState = editor._latestEditorState;\n        var blocks = splitTextIntoTextBlocks(fileText);\n        var character = CharacterMetadata.create({\n          style: editorState.getCurrentInlineStyle(),\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n        });\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\n        var fragment = BlockMapBuilder.createFromArray(text);\n\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\n      });\n\n      return;\n    }\n  }\n\n  var textBlocks = [];\n  var text = data.getText();\n  var html = data.getHTML();\n  var editorState = editor._latestEditorState;\n\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\n    return;\n  }\n\n  if (text) {\n    textBlocks = splitTextIntoTextBlocks(text);\n  }\n\n  if (!editor.props.stripPastedStyles) {\n    // If the text from the paste event is rich content that matches what we\n    // already have on the internal clipboard, assume that we should just use\n    // the clipboard fragment for the paste. This will allow us to preserve\n    // styling and entities, if any are present. Note that newlines are\n    // stripped during comparison -- this is because copy/paste within the\n    // editor in Firefox and IE will not include empty lines. The resulting\n    // paste will preserve the newlines correctly.\n    var internalClipboard = editor.getClipboard();\n    if (data.isRichText() && internalClipboard) {\n      if (\n      // If the editorKey is present in the pasted HTML, it should be safe to\n      // assume this is an internal paste.\n      html.indexOf(editor.getEditorKey()) !== -1 ||\n      // The copy may have been made within a single block, in which case the\n      // editor key won't be part of the paste. In this case, just check\n      // whether the pasted text matches the internal clipboard.\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n        return;\n      }\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\n      // Safari does not properly store text/html in some cases.\n      // Use the internalClipboard if present and equal to what is on\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n      return;\n    }\n\n    // If there is html paste data, try to parse that.\n    if (html) {\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\n      if (htmlFragment) {\n        var contentBlocks = htmlFragment.contentBlocks,\n            entityMap = htmlFragment.entityMap;\n\n        if (contentBlocks) {\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\n          return;\n        }\n      }\n    }\n\n    // Otherwise, create a new fragment from our pasted text. Also\n    // empty the internal clipboard, since it's no longer valid.\n    editor.setClipboard(null);\n  }\n\n  if (textBlocks.length) {\n    var character = CharacterMetadata.create({\n      style: editorState.getCurrentInlineStyle(),\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n    });\n\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\n\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\n    editor.update(insertFragment(editor._latestEditorState, textMap));\n  }\n}\n\nfunction insertFragment(editorState, fragment, entityMap) {\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n  // TODO: merge the entity map once we stop using DraftEntity\n  // like this:\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\n\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\n}\n\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\n    return block.getText() === textBlocks[ii];\n  });\n}\n\nmodule.exports = editOnPaste;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$draft_js$lib$DraftPasteProcessor","~$module$node_modules$draft_js$lib$isEventHandled","~$module$node_modules$draft_js$lib$BlockMapBuilder","~$module$node_modules$draft_js$lib$getEntityKeyForSelection","~$shadow.js","~$module$node_modules$draft_js$lib$DraftModifier","~$module$node_modules$draft_js$lib$RichTextEditorUtil","~$module$node_modules$draft_js$lib$CharacterMetadata","~$module$node_modules$draft_js$lib$EditorState","~$module$node_modules$draft_js$lib$splitTextIntoTextBlocks","~$module$node_modules$draft_js$lib$getTextContentFromFiles","~$module$node_modules$fbjs$lib$DataTransfer"]],"~:properties",["^5",["style","entity"]],"~:compiled-at",1532351402151,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$editOnPaste.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/editOnPaste.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$editOnPaste\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule editOnPaste\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar BlockMapBuilder = require('./BlockMapBuilder');\\nvar CharacterMetadata = require('./CharacterMetadata');\\nvar DataTransfer = require('fbjs/lib/DataTransfer');\\nvar DraftModifier = require('./DraftModifier');\\nvar DraftPasteProcessor = require('./DraftPasteProcessor');\\nvar EditorState = require('./EditorState');\\nvar RichTextEditorUtil = require('./RichTextEditorUtil');\\n\\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\\nvar getTextContentFromFiles = require('./getTextContentFromFiles');\\nvar isEventHandled = require('./isEventHandled');\\nvar splitTextIntoTextBlocks = require('./splitTextIntoTextBlocks');\\n\\n/**\\n * Paste content.\\n */\\nfunction editOnPaste(editor, e) {\\n  e.preventDefault();\\n  var data = new DataTransfer(e.clipboardData);\\n\\n  // Get files, unless this is likely to be a string the user wants inline.\\n  if (!data.isRichText()) {\\n    var files = data.getFiles();\\n    var defaultFileText = data.getText();\\n    if (files.length > 0) {\\n      // Allow customized paste handling for images, etc. Otherwise, fall\\n      // through to insert text contents into the editor.\\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\\n        return;\\n      }\\n\\n      getTextContentFromFiles(files, function ( /*string*/fileText) {\\n        fileText = fileText || defaultFileText;\\n        if (!fileText) {\\n          return;\\n        }\\n\\n        var editorState = editor._latestEditorState;\\n        var blocks = splitTextIntoTextBlocks(fileText);\\n        var character = CharacterMetadata.create({\\n          style: editorState.getCurrentInlineStyle(),\\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\\n        });\\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\\n\\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\\n        var fragment = BlockMapBuilder.createFromArray(text);\\n\\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\\n\\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\\n      });\\n\\n      return;\\n    }\\n  }\\n\\n  var textBlocks = [];\\n  var text = data.getText();\\n  var html = data.getHTML();\\n  var editorState = editor._latestEditorState;\\n\\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\\n    return;\\n  }\\n\\n  if (text) {\\n    textBlocks = splitTextIntoTextBlocks(text);\\n  }\\n\\n  if (!editor.props.stripPastedStyles) {\\n    // If the text from the paste event is rich content that matches what we\\n    // already have on the internal clipboard, assume that we should just use\\n    // the clipboard fragment for the paste. This will allow us to preserve\\n    // styling and entities, if any are present. Note that newlines are\\n    // stripped during comparison -- this is because copy/paste within the\\n    // editor in Firefox and IE will not include empty lines. The resulting\\n    // paste will preserve the newlines correctly.\\n    var internalClipboard = editor.getClipboard();\\n    if (data.isRichText() && internalClipboard) {\\n      if (\\n      // If the editorKey is present in the pasted HTML, it should be safe to\\n      // assume this is an internal paste.\\n      html.indexOf(editor.getEditorKey()) !== -1 ||\\n      // The copy may have been made within a single block, in which case the\\n      // editor key won't be part of the paste. In this case, just check\\n      // whether the pasted text matches the internal clipboard.\\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\\n        return;\\n      }\\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\\n      // Safari does not properly store text/html in some cases.\\n      // Use the internalClipboard if present and equal to what is on\\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\\n      return;\\n    }\\n\\n    // If there is html paste data, try to parse that.\\n    if (html) {\\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\\n      if (htmlFragment) {\\n        var contentBlocks = htmlFragment.contentBlocks,\\n            entityMap = htmlFragment.entityMap;\\n\\n        if (contentBlocks) {\\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\\n          return;\\n        }\\n      }\\n    }\\n\\n    // Otherwise, create a new fragment from our pasted text. Also\\n    // empty the internal clipboard, since it's no longer valid.\\n    editor.setClipboard(null);\\n  }\\n\\n  if (textBlocks.length) {\\n    var character = CharacterMetadata.create({\\n      style: editorState.getCurrentInlineStyle(),\\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\\n    });\\n\\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\\n\\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\\n\\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\\n    editor.update(insertFragment(editor._latestEditorState, textMap));\\n  }\\n}\\n\\nfunction insertFragment(editorState, fragment, entityMap) {\\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\\n  // TODO: merge the entity map once we stop using DraftEntity\\n  // like this:\\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\\n\\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\\n}\\n\\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\\n    return block.getText() === textBlocks[ii];\\n  });\\n}\\n\\nmodule.exports = editOnPaste;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"insertFragment\",\"editorState\",\"fragment\",\"entityMap\",\"newContent\",\"DraftModifier\",\"replaceWithFragment\",\"getCurrentContent\",\"getSelection\",\"EditorState\",\"push\",\"set\",\"areTextBlocksAndClipboardEqual\",\"textBlocks\",\"blockMap\",\"length\",\"size\",\"valueSeq\",\"every\",\"block\",\"ii\",\"getText\",\"BlockMapBuilder\",\"CharacterMetadata\",\"DataTransfer\",\"DraftPasteProcessor\",\"RichTextEditorUtil\",\"getEntityKeyForSelection\",\"getTextContentFromFiles\",\"isEventHandled\",\"splitTextIntoTextBlocks\",\"editOnPaste\",\"editor\",\"e\",\"preventDefault\",\"data\",\"clipboardData\",\"isRichText\",\"files\",\"getFiles\",\"defaultFileText\",\"props\",\"handlePastedFiles\",\"fileText\",\"_latestEditorState\",\"blocks\",\"character\",\"create\",\"style\",\"getCurrentInlineStyle\",\"entity\",\"currentBlockType\",\"getCurrentBlockType\",\"text\",\"processText\",\"createFromArray\",\"withInsertedText\",\"update\",\"html\",\"getHTML\",\"handlePastedText\",\"stripPastedStyles\",\"internalClipboard\",\"getClipboard\",\"indexOf\",\"getEditorKey\",\"first\",\"types\",\"includes\",\"htmlFragment\",\"processHTML\",\"blockRenderMap\",\"contentBlocks\",\"htmlMap\",\"setClipboard\",\"textFragment\",\"textMap\"]\n}\n"]