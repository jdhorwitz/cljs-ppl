["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/expandRangeToStartOfLine.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$expandRangeToStartOfLine=function(global,process,require,module,exports,shadow$shims){function areRectsOnOneLine(rects,lineHeight){for(var minTop=Infinity,minBottom=Infinity,maxTop=-Infinity,maxBottom=-Infinity,ii=0;ii<rects.length;ii++){var rect=rects[ii];0!==rect.width&&1!==rect.width&&(minTop=Math.min(minTop,rect.top),minBottom=Math.min(minBottom,rect.bottom),maxTop=Math.max(maxTop,rect.top),maxBottom=Math.max(maxBottom,rect.bottom))}return maxTop<=\nminBottom&&maxTop-minTop<lineHeight&&maxBottom-minBottom<lineHeight}var UnicodeUtils=require(\"module$node_modules$fbjs$lib$UnicodeUtils\"),getRangeClientRects=require(\"module$node_modules$draft_js$lib$getRangeClientRects\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\");module.exports=function(range){range.collapsed?void 0:invariant(!1,\"expandRangeToStartOfLine: Provided range is not collapsed.\");range=range.cloneRange();var containingElement=range.startContainer;1!==containingElement.nodeType&&\n(containingElement=containingElement.parentNode);var computed=getComputedStyle(containingElement);containingElement=document.createElement(\"div\");containingElement.style.fontFamily=computed.fontFamily;containingElement.style.fontSize=computed.fontSize;containingElement.style.fontStyle=computed.fontStyle;containingElement.style.fontWeight=computed.fontWeight;containingElement.style.lineHeight=computed.lineHeight;containingElement.style.position=\"absolute\";containingElement.textContent=\"M\";(computed=\ndocument.body)?void 0:invariant(!1,\"Missing document.body\");computed.appendChild(containingElement);var rect=containingElement.getBoundingClientRect();computed.removeChild(containingElement);containingElement=rect.height;computed=range.endContainer;rect=range.endOffset;for(range.setStart(range.startContainer,0);areRectsOnOneLine(getRangeClientRects(range),containingElement)&&(computed=range.startContainer,rect=range.startOffset,computed.parentNode?void 0:invariant(!1,\"Found unexpected detached subtree when traversing.\"),\nrange.setStartBefore(computed),1!==computed.nodeType||\"inline\"===getComputedStyle(computed).display););var currentContainer=computed,maxIndexToConsider=rect-1;do{for(var nodeValue=currentContainer.nodeValue;0<=maxIndexToConsider;maxIndexToConsider--)if(!(null!=nodeValue&&0<maxIndexToConsider&&UnicodeUtils.isSurrogatePair(nodeValue,maxIndexToConsider-1)))if(range.setStart(currentContainer,maxIndexToConsider),areRectsOnOneLine(getRangeClientRects(range),containingElement))computed=currentContainer,\nrect=maxIndexToConsider;else break;if(-1===maxIndexToConsider||0===currentContainer.childNodes.length)break;currentContainer=currentContainer.childNodes[maxIndexToConsider];a:switch(currentContainer.nodeType){case Node.DOCUMENT_TYPE_NODE:maxIndexToConsider=0;break a;case Node.TEXT_NODE:case Node.PROCESSING_INSTRUCTION_NODE:case Node.COMMENT_NODE:maxIndexToConsider=currentContainer.length;break a;default:maxIndexToConsider=currentContainer.childNodes.length}}while(1);range.setStart(computed,rect);\nreturn range}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$expandRangeToStartOfLine\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule expandRangeToStartOfLine\n * @format\n * \n */\n\nvar UnicodeUtils = require('fbjs/lib/UnicodeUtils');\n\nvar getRangeClientRects = require('./getRangeClientRects');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Return the computed line height, in pixels, for the provided element.\n */\nfunction getLineHeightPx(element) {\n  var computed = getComputedStyle(element);\n  var div = document.createElement('div');\n  div.style.fontFamily = computed.fontFamily;\n  div.style.fontSize = computed.fontSize;\n  div.style.fontStyle = computed.fontStyle;\n  div.style.fontWeight = computed.fontWeight;\n  div.style.lineHeight = computed.lineHeight;\n  div.style.position = 'absolute';\n  div.textContent = 'M';\n\n  var documentBody = document.body;\n  !documentBody ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing document.body') : invariant(false) : void 0;\n\n  // forced layout here\n  documentBody.appendChild(div);\n  var rect = div.getBoundingClientRect();\n  documentBody.removeChild(div);\n\n  return rect.height;\n}\n\n/**\n * Return whether every ClientRect in the provided list lies on the same line.\n *\n * We assume that the rects on the same line all contain the baseline, so the\n * lowest top line needs to be above the highest bottom line (i.e., if you were\n * to project the rects onto the y-axis, their intersection would be nonempty).\n *\n * In addition, we require that no two boxes are lineHeight (or more) apart at\n * either top or bottom, which helps protect against false positives for fonts\n * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino\n * produces rects of height 58px!).\n */\nfunction areRectsOnOneLine(rects, lineHeight) {\n  var minTop = Infinity;\n  var minBottom = Infinity;\n  var maxTop = -Infinity;\n  var maxBottom = -Infinity;\n\n  for (var ii = 0; ii < rects.length; ii++) {\n    var rect = rects[ii];\n    if (rect.width === 0 || rect.width === 1) {\n      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,\n      // Safari) include an empty rect on the previous or next line. When the\n      // text lies in a container whose position is not integral (e.g., from\n      // margin: auto), Safari makes these empty rects have width 1 (instead of\n      // 0). Having one-pixel-wide characters seems unlikely (and most browsers\n      // report widths in subpixel precision anyway) so it's relatively safe to\n      // skip over them.\n      continue;\n    }\n    minTop = Math.min(minTop, rect.top);\n    minBottom = Math.min(minBottom, rect.bottom);\n    maxTop = Math.max(maxTop, rect.top);\n    maxBottom = Math.max(maxBottom, rect.bottom);\n  }\n\n  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;\n}\n\n/**\n * Return the length of a node, as used by Range offsets.\n */\nfunction getNodeLength(node) {\n  // http://www.w3.org/TR/dom/#concept-node-length\n  switch (node.nodeType) {\n    case Node.DOCUMENT_TYPE_NODE:\n      return 0;\n    case Node.TEXT_NODE:\n    case Node.PROCESSING_INSTRUCTION_NODE:\n    case Node.COMMENT_NODE:\n      return node.length;\n    default:\n      return node.childNodes.length;\n  }\n}\n\n/**\n * Given a collapsed range, move the start position backwards as far as\n * possible while the range still spans only a single line.\n */\nfunction expandRangeToStartOfLine(range) {\n  !range.collapsed ? process.env.NODE_ENV !== 'production' ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;\n  range = range.cloneRange();\n\n  var containingElement = range.startContainer;\n  if (containingElement.nodeType !== 1) {\n    containingElement = containingElement.parentNode;\n  }\n  var lineHeight = getLineHeightPx(containingElement);\n\n  // Imagine our text looks like:\n  //   <div><span>once upon a time, there was a <em>boy\n  //   who lived</em> </span><q><strong>under^ the\n  //   stairs</strong> in a small closet.</q></div>\n  // where the caret represents the cursor. First, we crawl up the tree until\n  // the range spans multiple lines (setting the start point to before\n  // \"<strong>\", then before \"<div>\"), then at each level we do a search to\n  // find the latest point which is still on a previous line. We'll find that\n  // the break point is inside the span, then inside the <em>, then in its text\n  // node child, the actual break point before \"who\".\n\n  var bestContainer = range.endContainer;\n  var bestOffset = range.endOffset;\n  range.setStart(range.startContainer, 0);\n\n  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n    bestContainer = range.startContainer;\n    bestOffset = range.startOffset;\n    !bestContainer.parentNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;\n    range.setStartBefore(bestContainer);\n    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {\n      // The start of the line is never in a different block-level container.\n      break;\n    }\n  }\n\n  // In the above example, range now spans from \"<div>\" to \"under\",\n  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].\n  // Picking out which child to recurse into here is a special case since we\n  // don't want to check past <q> -- once we find that the final range starts\n  // in <span>, we can look at all of its children (and all of their children)\n  // to find the break point.\n\n  // At all times, (bestContainer, bestOffset) is the latest single-line start\n  // point that we know of.\n  var currentContainer = bestContainer;\n  var maxIndexToConsider = bestOffset - 1;\n\n  do {\n    var nodeValue = currentContainer.nodeValue;\n\n    for (var ii = maxIndexToConsider; ii >= 0; ii--) {\n      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {\n        // We're in the middle of a surrogate pair -- skip over so we never\n        // return a range with an endpoint in the middle of a code point.\n        continue;\n      }\n\n      range.setStart(currentContainer, ii);\n      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n        bestContainer = currentContainer;\n        bestOffset = ii;\n      } else {\n        break;\n      }\n    }\n\n    if (ii === -1 || currentContainer.childNodes.length === 0) {\n      // If ii === -1, then (bestContainer, bestOffset), which is equal to\n      // (currentContainer, 0), was a single-line start point but a start\n      // point before currentContainer wasn't, so the line break seems to\n      // have occurred immediately after currentContainer's start tag\n      //\n      // If currentContainer.childNodes.length === 0, we're already at a\n      // terminal node (e.g., text node) and should return our current best.\n      break;\n    }\n\n    currentContainer = currentContainer.childNodes[ii];\n    maxIndexToConsider = getNodeLength(currentContainer);\n  } while (true);\n\n  range.setStart(bestContainer, bestOffset);\n  return range;\n}\n\nmodule.exports = expandRangeToStartOfLine;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$draft_js$lib$getRangeClientRects","~$shadow.js","~$module$node_modules$fbjs$lib$UnicodeUtils","~$module$node_modules$fbjs$lib$invariant"]],"~:properties",["^5",["fontFamily","fontStyle","fontWeight","lineHeight","textContent","position","fontSize"]],"~:compiled-at",1532351402146,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$expandRangeToStartOfLine.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/expandRangeToStartOfLine.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$expandRangeToStartOfLine\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule expandRangeToStartOfLine\\n * @format\\n * \\n */\\n\\nvar UnicodeUtils = require('fbjs/lib/UnicodeUtils');\\n\\nvar getRangeClientRects = require('./getRangeClientRects');\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Return the computed line height, in pixels, for the provided element.\\n */\\nfunction getLineHeightPx(element) {\\n  var computed = getComputedStyle(element);\\n  var div = document.createElement('div');\\n  div.style.fontFamily = computed.fontFamily;\\n  div.style.fontSize = computed.fontSize;\\n  div.style.fontStyle = computed.fontStyle;\\n  div.style.fontWeight = computed.fontWeight;\\n  div.style.lineHeight = computed.lineHeight;\\n  div.style.position = 'absolute';\\n  div.textContent = 'M';\\n\\n  var documentBody = document.body;\\n  !documentBody ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing document.body') : invariant(false) : void 0;\\n\\n  // forced layout here\\n  documentBody.appendChild(div);\\n  var rect = div.getBoundingClientRect();\\n  documentBody.removeChild(div);\\n\\n  return rect.height;\\n}\\n\\n/**\\n * Return whether every ClientRect in the provided list lies on the same line.\\n *\\n * We assume that the rects on the same line all contain the baseline, so the\\n * lowest top line needs to be above the highest bottom line (i.e., if you were\\n * to project the rects onto the y-axis, their intersection would be nonempty).\\n *\\n * In addition, we require that no two boxes are lineHeight (or more) apart at\\n * either top or bottom, which helps protect against false positives for fonts\\n * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino\\n * produces rects of height 58px!).\\n */\\nfunction areRectsOnOneLine(rects, lineHeight) {\\n  var minTop = Infinity;\\n  var minBottom = Infinity;\\n  var maxTop = -Infinity;\\n  var maxBottom = -Infinity;\\n\\n  for (var ii = 0; ii < rects.length; ii++) {\\n    var rect = rects[ii];\\n    if (rect.width === 0 || rect.width === 1) {\\n      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,\\n      // Safari) include an empty rect on the previous or next line. When the\\n      // text lies in a container whose position is not integral (e.g., from\\n      // margin: auto), Safari makes these empty rects have width 1 (instead of\\n      // 0). Having one-pixel-wide characters seems unlikely (and most browsers\\n      // report widths in subpixel precision anyway) so it's relatively safe to\\n      // skip over them.\\n      continue;\\n    }\\n    minTop = Math.min(minTop, rect.top);\\n    minBottom = Math.min(minBottom, rect.bottom);\\n    maxTop = Math.max(maxTop, rect.top);\\n    maxBottom = Math.max(maxBottom, rect.bottom);\\n  }\\n\\n  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;\\n}\\n\\n/**\\n * Return the length of a node, as used by Range offsets.\\n */\\nfunction getNodeLength(node) {\\n  // http://www.w3.org/TR/dom/#concept-node-length\\n  switch (node.nodeType) {\\n    case Node.DOCUMENT_TYPE_NODE:\\n      return 0;\\n    case Node.TEXT_NODE:\\n    case Node.PROCESSING_INSTRUCTION_NODE:\\n    case Node.COMMENT_NODE:\\n      return node.length;\\n    default:\\n      return node.childNodes.length;\\n  }\\n}\\n\\n/**\\n * Given a collapsed range, move the start position backwards as far as\\n * possible while the range still spans only a single line.\\n */\\nfunction expandRangeToStartOfLine(range) {\\n  !range.collapsed ? process.env.NODE_ENV !== 'production' ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;\\n  range = range.cloneRange();\\n\\n  var containingElement = range.startContainer;\\n  if (containingElement.nodeType !== 1) {\\n    containingElement = containingElement.parentNode;\\n  }\\n  var lineHeight = getLineHeightPx(containingElement);\\n\\n  // Imagine our text looks like:\\n  //   <div><span>once upon a time, there was a <em>boy\\n  //   who lived</em> </span><q><strong>under^ the\\n  //   stairs</strong> in a small closet.</q></div>\\n  // where the caret represents the cursor. First, we crawl up the tree until\\n  // the range spans multiple lines (setting the start point to before\\n  // \\\"<strong>\\\", then before \\\"<div>\\\"), then at each level we do a search to\\n  // find the latest point which is still on a previous line. We'll find that\\n  // the break point is inside the span, then inside the <em>, then in its text\\n  // node child, the actual break point before \\\"who\\\".\\n\\n  var bestContainer = range.endContainer;\\n  var bestOffset = range.endOffset;\\n  range.setStart(range.startContainer, 0);\\n\\n  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\\n    bestContainer = range.startContainer;\\n    bestOffset = range.startOffset;\\n    !bestContainer.parentNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;\\n    range.setStartBefore(bestContainer);\\n    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {\\n      // The start of the line is never in a different block-level container.\\n      break;\\n    }\\n  }\\n\\n  // In the above example, range now spans from \\\"<div>\\\" to \\\"under\\\",\\n  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].\\n  // Picking out which child to recurse into here is a special case since we\\n  // don't want to check past <q> -- once we find that the final range starts\\n  // in <span>, we can look at all of its children (and all of their children)\\n  // to find the break point.\\n\\n  // At all times, (bestContainer, bestOffset) is the latest single-line start\\n  // point that we know of.\\n  var currentContainer = bestContainer;\\n  var maxIndexToConsider = bestOffset - 1;\\n\\n  do {\\n    var nodeValue = currentContainer.nodeValue;\\n\\n    for (var ii = maxIndexToConsider; ii >= 0; ii--) {\\n      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {\\n        // We're in the middle of a surrogate pair -- skip over so we never\\n        // return a range with an endpoint in the middle of a code point.\\n        continue;\\n      }\\n\\n      range.setStart(currentContainer, ii);\\n      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\\n        bestContainer = currentContainer;\\n        bestOffset = ii;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    if (ii === -1 || currentContainer.childNodes.length === 0) {\\n      // If ii === -1, then (bestContainer, bestOffset), which is equal to\\n      // (currentContainer, 0), was a single-line start point but a start\\n      // point before currentContainer wasn't, so the line break seems to\\n      // have occurred immediately after currentContainer's start tag\\n      //\\n      // If currentContainer.childNodes.length === 0, we're already at a\\n      // terminal node (e.g., text node) and should return our current best.\\n      break;\\n    }\\n\\n    currentContainer = currentContainer.childNodes[ii];\\n    maxIndexToConsider = getNodeLength(currentContainer);\\n  } while (true);\\n\\n  range.setStart(bestContainer, bestOffset);\\n  return range;\\n}\\n\\nmodule.exports = expandRangeToStartOfLine;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"areRectsOnOneLine\",\"rects\",\"lineHeight\",\"minTop\",\"Infinity\",\"minBottom\",\"maxTop\",\"maxBottom\",\"ii\",\"length\",\"rect\",\"width\",\"Math\",\"min\",\"top\",\"bottom\",\"max\",\"UnicodeUtils\",\"getRangeClientRects\",\"invariant\",\"expandRangeToStartOfLine\",\"range\",\"collapsed\",\"cloneRange\",\"containingElement\",\"startContainer\",\"nodeType\",\"parentNode\",\"computed\",\"getComputedStyle\",\"div\",\"document\",\"createElement\",\"style\",\"fontFamily\",\"fontSize\",\"fontStyle\",\"fontWeight\",\"position\",\"textContent\",\"documentBody\",\"body\",\"appendChild\",\"getBoundingClientRect\",\"removeChild\",\"height\",\"bestContainer\",\"endContainer\",\"bestOffset\",\"endOffset\",\"setStart\",\"startOffset\",\"setStartBefore\",\"display\",\"currentContainer\",\"maxIndexToConsider\",\"nodeValue\",\"isSurrogatePair\",\"childNodes\",\"Node\",\"DOCUMENT_TYPE_NODE\",\"TEXT_NODE\",\"PROCESSING_INSTRUCTION_NODE\",\"COMMENT_NODE\"]\n}\n"]