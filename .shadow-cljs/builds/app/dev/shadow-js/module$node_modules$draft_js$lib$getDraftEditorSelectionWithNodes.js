["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/getDraftEditorSelectionWithNodes.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$getDraftEditorSelectionWithNodes=function(global,process,require,module,exports,shadow$shims){function getPointForNonTextNode(editorRoot,startNode,childOffset){var node=startNode;startNode=findAncestorOffsetKey(node);null!=startNode||editorRoot&&(editorRoot===node||editorRoot.firstChild===node)?void 0:invariant(!1,\"Unknown node in selection range.\");editorRoot===node&&(node=node.firstChild,node instanceof Element&&\"true\"===node.getAttribute(\"data-contents\")?\nvoid 0:invariant(!1,\"Invalid DraftEditorContents structure.\"),0<childOffset&&(childOffset=node.childNodes.length));if(0===childOffset){if(null!=startNode)editorRoot=startNode;else{for(editorRoot=node;editorRoot.firstChild&&(editorRoot.firstChild instanceof Element&&\"true\"===editorRoot.firstChild.getAttribute(\"data-blocks\")||getSelectionOffsetKeyForNode(editorRoot.firstChild));)editorRoot=editorRoot.firstChild;editorRoot=nullthrows(getSelectionOffsetKeyForNode(editorRoot))}return{key:editorRoot,offset:0}}childOffset=\nnode.childNodes[childOffset-1];if(getSelectionOffsetKeyForNode(childOffset)){for(editorRoot=childOffset;editorRoot.lastChild&&(editorRoot.lastChild instanceof Element&&\"true\"===editorRoot.lastChild.getAttribute(\"data-blocks\")||getSelectionOffsetKeyForNode(editorRoot.lastChild));)editorRoot=editorRoot.lastChild;childOffset=editorRoot;editorRoot=nullthrows(getSelectionOffsetKeyForNode(childOffset));childOffset=getTextContentLength(childOffset)}else editorRoot=nullthrows(startNode),childOffset=getTextContentLength(childOffset);\nreturn{key:editorRoot,offset:childOffset}}function getTextContentLength(node){node=node.textContent;return\"\\n\"===node?0:node.length}var findAncestorOffsetKey=require(\"module$node_modules$draft_js$lib$findAncestorOffsetKey\"),getSelectionOffsetKeyForNode=require(\"module$node_modules$draft_js$lib$getSelectionOffsetKeyForNode\"),getUpdatedSelectionState=require(\"module$node_modules$draft_js$lib$getUpdatedSelectionState\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),nullthrows=require(\"module$node_modules$fbjs$lib$nullthrows\");\nmodule.exports=function(editorState,root,anchorNode,anchorOffset,focusNode,focusOffset){var anchorIsTextNode=anchorNode.nodeType===Node.TEXT_NODE,focusIsTextNode=focusNode.nodeType===Node.TEXT_NODE;if(anchorIsTextNode&&focusIsTextNode)return{selectionState:getUpdatedSelectionState(editorState,nullthrows(findAncestorOffsetKey(anchorNode)),anchorOffset,nullthrows(findAncestorOffsetKey(focusNode)),focusOffset),needsRecovery:!1};var needsRecovery=!0;anchorIsTextNode?(anchorIsTextNode={key:nullthrows(findAncestorOffsetKey(anchorNode)),\noffset:anchorOffset},focusIsTextNode=getPointForNonTextNode(root,focusNode,focusOffset)):focusIsTextNode?(focusIsTextNode={key:nullthrows(findAncestorOffsetKey(focusNode)),offset:focusOffset},anchorIsTextNode=getPointForNonTextNode(root,anchorNode,anchorOffset)):(anchorIsTextNode=getPointForNonTextNode(root,anchorNode,anchorOffset),focusIsTextNode=getPointForNonTextNode(root,focusNode,focusOffset),anchorNode===focusNode&&anchorOffset===focusOffset&&(needsRecovery=!!anchorNode.firstChild&&\"BR\"!==anchorNode.firstChild.nodeName));\nreturn{selectionState:getUpdatedSelectionState(editorState,anchorIsTextNode.key,anchorIsTextNode.offset,focusIsTextNode.key,focusIsTextNode.offset),needsRecovery:needsRecovery}}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$getDraftEditorSelectionWithNodes\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getDraftEditorSelectionWithNodes\n * @format\n * \n */\n\n'use strict';\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\nvar getSelectionOffsetKeyForNode = require('./getSelectionOffsetKeyForNode');\nvar getUpdatedSelectionState = require('./getUpdatedSelectionState');\nvar invariant = require('fbjs/lib/invariant');\nvar nullthrows = require('fbjs/lib/nullthrows');\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;\n\n  // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true;\n\n  // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n\n    // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n\n/**\n * Identify the first leaf descendant for the given node.\n */\nfunction getFirstLeaf(node) {\n  while (node.firstChild && (\n  // data-blocks has no offset\n  node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Identify the last leaf descendant for the given node.\n */\nfunction getLastLeaf(node) {\n  while (node.lastChild && (\n  // data-blocks has no offset\n  node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0;\n\n  // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  }\n\n  // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n  if (childOffset === 0) {\n    var key = null;\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n    return { key: key, offset: 0 };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$fbjs$lib$nullthrows","~$module$node_modules$draft_js$lib$getSelectionOffsetKeyForNode","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$draft_js$lib$getUpdatedSelectionState","~$module$node_modules$draft_js$lib$findAncestorOffsetKey"]],"~:properties",["^5",["needsRecovery","offset","key","selectionState"]],"~:compiled-at",1532351402146,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$getDraftEditorSelectionWithNodes.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/getDraftEditorSelectionWithNodes.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$getDraftEditorSelectionWithNodes\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule getDraftEditorSelectionWithNodes\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\\nvar getSelectionOffsetKeyForNode = require('./getSelectionOffsetKeyForNode');\\nvar getUpdatedSelectionState = require('./getUpdatedSelectionState');\\nvar invariant = require('fbjs/lib/invariant');\\nvar nullthrows = require('fbjs/lib/nullthrows');\\n\\n/**\\n * Convert the current selection range to an anchor/focus pair of offset keys\\n * and values that can be interpreted by components.\\n */\\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;\\n\\n  // If the selection range lies only on text nodes, the task is simple.\\n  // Find the nearest offset-aware elements and use the\\n  // offset values supplied by the selection range.\\n  if (anchorIsTextNode && focusIsTextNode) {\\n    return {\\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\\n      needsRecovery: false\\n    };\\n  }\\n\\n  var anchorPoint = null;\\n  var focusPoint = null;\\n  var needsRecovery = true;\\n\\n  // An element is selected. Convert this selection range into leaf offset\\n  // keys and offset values for consumption at the component level. This\\n  // is common in Firefox, where select-all and triple click behavior leads\\n  // to entire elements being selected.\\n  //\\n  // Note that we use the `needsRecovery` parameter in the callback here. This\\n  // is because when certain elements are selected, the behavior for subsequent\\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\\n  // expectations at the component level. For example, if an entire <div> is\\n  // selected and the user presses the right arrow, Firefox keeps the selection\\n  // on the <div>. If we allow subsequent keypresses to insert characters\\n  // natively, they will be inserted into a browser-created text node to the\\n  // right of that <div>. This is obviously undesirable.\\n  //\\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\\n  // for manually setting the selection state on the rendered document to\\n  // ensure proper selection state maintenance.\\n\\n  if (anchorIsTextNode) {\\n    anchorPoint = {\\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\\n      offset: anchorOffset\\n    };\\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\\n  } else if (focusIsTextNode) {\\n    focusPoint = {\\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\\n      offset: focusOffset\\n    };\\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\\n  } else {\\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\\n\\n    // If the selection is collapsed on an empty block, don't force recovery.\\n    // This way, on arrow key selection changes, the browser can move the\\n    // cursor from a non-zero offset on one block, through empty blocks,\\n    // to a matching non-zero offset on other text blocks.\\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\\n    }\\n  }\\n\\n  return {\\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\\n    needsRecovery: needsRecovery\\n  };\\n}\\n\\n/**\\n * Identify the first leaf descendant for the given node.\\n */\\nfunction getFirstLeaf(node) {\\n  while (node.firstChild && (\\n  // data-blocks has no offset\\n  node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\\n    node = node.firstChild;\\n  }\\n  return node;\\n}\\n\\n/**\\n * Identify the last leaf descendant for the given node.\\n */\\nfunction getLastLeaf(node) {\\n  while (node.lastChild && (\\n  // data-blocks has no offset\\n  node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\\n    node = node.lastChild;\\n  }\\n  return node;\\n}\\n\\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\\n  var node = startNode;\\n  var offsetKey = findAncestorOffsetKey(node);\\n\\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0;\\n\\n  // If the editorRoot is the selection, step downward into the content\\n  // wrapper.\\n  if (editorRoot === node) {\\n    node = node.firstChild;\\n    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\\n    if (childOffset > 0) {\\n      childOffset = node.childNodes.length;\\n    }\\n  }\\n\\n  // If the child offset is zero and we have an offset key, we're done.\\n  // If there's no offset key because the entire editor is selected,\\n  // find the leftmost (\\\"first\\\") leaf in the tree and use that as the offset\\n  // key.\\n  if (childOffset === 0) {\\n    var key = null;\\n    if (offsetKey != null) {\\n      key = offsetKey;\\n    } else {\\n      var firstLeaf = getFirstLeaf(node);\\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\\n    }\\n    return { key: key, offset: 0 };\\n  }\\n\\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\\n  var leafKey = null;\\n  var textLength = null;\\n\\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\\n    // Our target node may be a leaf or a text node, in which case we're\\n    // already where we want to be and can just use the child's length as\\n    // our offset.\\n    leafKey = nullthrows(offsetKey);\\n    textLength = getTextContentLength(nodeBeforeCursor);\\n  } else {\\n    // Otherwise, we'll look at the child to the left of the cursor and find\\n    // the last leaf node in its subtree.\\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\\n    textLength = getTextContentLength(lastLeaf);\\n  }\\n\\n  return {\\n    key: leafKey,\\n    offset: textLength\\n  };\\n}\\n\\n/**\\n * Return the length of a node's textContent, regarding single newline\\n * characters as zero-length. This allows us to avoid problems with identifying\\n * the correct selection offset for empty blocks in IE, in which we\\n * render newlines instead of break tags.\\n */\\nfunction getTextContentLength(node) {\\n  var textContent = node.textContent;\\n  return textContent === '\\\\n' ? 0 : textContent.length;\\n}\\n\\nmodule.exports = getDraftEditorSelectionWithNodes;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"getPointForNonTextNode\",\"editorRoot\",\"startNode\",\"childOffset\",\"node\",\"offsetKey\",\"findAncestorOffsetKey\",\"firstChild\",\"invariant\",\"Element\",\"getAttribute\",\"childNodes\",\"length\",\"key\",\"getSelectionOffsetKeyForNode\",\"nullthrows\",\"offset\",\"nodeBeforeCursor\",\"lastChild\",\"leafKey\",\"lastLeaf\",\"textLength\",\"getTextContentLength\",\"textContent\",\"getUpdatedSelectionState\",\"getDraftEditorSelectionWithNodes\",\"editorState\",\"root\",\"anchorNode\",\"anchorOffset\",\"focusNode\",\"focusOffset\",\"anchorIsTextNode\",\"nodeType\",\"Node\",\"TEXT_NODE\",\"focusIsTextNode\",\"selectionState\",\"needsRecovery\",\"anchorPoint\",\"focusPoint\",\"nodeName\"]\n}\n"]