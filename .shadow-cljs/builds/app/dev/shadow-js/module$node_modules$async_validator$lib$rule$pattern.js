["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/async-validator/lib/rule/pattern.js"],"~:js","shadow$provide.module$node_modules$async_validator$lib$rule$pattern=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,\"__esModule\",{value:!0});var util=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);newObj[\"default\"]=obj;return newObj}(require(\"module$node_modules$async_validator$lib$util\"));exports[\"default\"]=function(rule,value,source,errors,\noptions){rule.pattern&&(rule.pattern instanceof RegExp?(rule.pattern.lastIndex=0,rule.pattern.test(value)||errors.push(util.format(options.messages.pattern.mismatch,rule.fullField,value,rule.pattern))):\"string\"===typeof rule.pattern&&((new RegExp(rule.pattern)).test(value)||errors.push(util.format(options.messages.pattern.mismatch,rule.fullField,value,rule.pattern))))};module.exports=exports[\"default\"]}","~:source","shadow$provide[\"module$node_modules$async_validator$lib$rule$pattern\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util = require('../util');\n\nvar util = _interopRequireWildcard(_util);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n/**\n *  Rule for validating a regular expression pattern.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\nfunction pattern(rule, value, source, errors, options) {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n      // flag is accidentally set to `true`, which in a validation scenario\n      // is not necessary and the result might be misleading\n      rule.pattern.lastIndex = 0;\n      if (!rule.pattern.test(value)) {\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    } else if (typeof rule.pattern === 'string') {\n      var _pattern = new RegExp(rule.pattern);\n      if (!_pattern.test(value)) {\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    }\n  }\n}\n\nexports['default'] = pattern;\nmodule.exports = exports['default'];\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$async_validator$lib$util","~$shadow.js"]],"~:properties",["^5",["__esModule","lastIndex","value"]],"~:compiled-at",1532351402013,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$async_validator$lib$rule$pattern.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,qDAAA,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAGtIC,MAAAC,eAAA,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CI,MAAO,CAAA,CADoC,CAA7C,CAMA,KAAIC,KAEJC,QAAgC,CAACC,GAAD,CAAM,CAAE,GAAIA,GAAJ,EAAWA,GAAAC,WAAX,CAA6B,MAAOD,IAAc,KAAIE,OAAS,EAAI,IAAW,IAAX,EAAIF,GAAJ,CAAmB,IAAKG,IAAIA,GAAT,GAAgBH,IAAhB,CAA2BL,MAAAS,UAAAC,eAAAC,KAAA,CAAqCN,GAArC,CAA0CG,GAA1C,CAAJ,GAAoDD,MAAA,CAAOC,GAAP,CAApD,CAAkEH,GAAA,CAAIG,GAAJ,CAAlE,CAAgFD,OAAA,CAAO,SAAP,CAAA,CAAoBF,GAAK,OAAOE,OAA/N,CAF3B,CAFCX,OAAAgB,CAAQ,8CAARA,CAED,CAkCXd,QAAA,CAAQ,SAAR,CAAA,CAnBAe,QAAgB,CAACC,IAAD,CAAOZ,KAAP,CAAca,MAAd,CAAsBC,MAAtB;AAA8BC,OAA9B,CAAuC,CACjDH,IAAAD,QAAJ,GACMC,IAAAD,QAAJ,WAA4BK,OAA5B,EAIEJ,IAAAD,QAAAM,UACA,CADyB,CACzB,CAAKL,IAAAD,QAAAO,KAAA,CAAkBlB,KAAlB,CAAL,EACEc,MAAAK,KAAA,CAAYlB,IAAAmB,OAAA,CAAYL,OAAAM,SAAAV,QAAAW,SAAZ,CAA+CV,IAAAW,UAA/C,CAA+DvB,KAA/D,CAAsEY,IAAAD,QAAtE,CAAZ,CANJ,EAQmC,QARnC,GAQW,MAAOC,KAAAD,QARlB,GAUOO,CADUM,IAAIR,MAAJQ,CAAWZ,IAAAD,QAAXa,CACVN,MAAA,CAAclB,KAAd,CAVP,EAWIc,MAAAK,KAAA,CAAYlB,IAAAmB,OAAA,CAAYL,OAAAM,SAAAV,QAAAW,SAAZ,CAA+CV,IAAAW,UAA/C,CAA+DvB,KAA/D,CAAsEY,IAAAD,QAAtE,CAAZ,CAXJ,CADF,CADqD,CAoBvDhB,OAAAC,QAAA,CAAiBA,OAAA,CAAQ,SAAR,CA5CqH;\",\n\"sources\":[\"node_modules/async-validator/lib/rule/pattern.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$async_validator$lib$rule$pattern\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _util = require('../util');\\n\\nvar util = _interopRequireWildcard(_util);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\n/**\\n *  Rule for validating a regular expression pattern.\\n *\\n *  @param rule The validation rule.\\n *  @param value The value of the field on the source object.\\n *  @param source The source object being validated.\\n *  @param errors An array of errors that this rule may add\\n *  validation errors to.\\n *  @param options The validation options.\\n *  @param options.messages The validation messages.\\n */\\nfunction pattern(rule, value, source, errors, options) {\\n  if (rule.pattern) {\\n    if (rule.pattern instanceof RegExp) {\\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\\n      // flag is accidentally set to `true`, which in a validation scenario\\n      // is not necessary and the result might be misleading\\n      rule.pattern.lastIndex = 0;\\n      if (!rule.pattern.test(value)) {\\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\\n      }\\n    } else if (typeof rule.pattern === 'string') {\\n      var _pattern = new RegExp(rule.pattern);\\n      if (!_pattern.test(value)) {\\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\\n      }\\n    }\\n  }\\n}\\n\\nexports['default'] = pattern;\\nmodule.exports = exports['default'];\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"util\",\"_interopRequireWildcard\",\"obj\",\"__esModule\",\"newObj\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"_util\",\"pattern\",\"rule\",\"source\",\"errors\",\"options\",\"RegExp\",\"lastIndex\",\"test\",\"push\",\"format\",\"messages\",\"mismatch\",\"fullField\",\"_pattern\"]\n}\n"]