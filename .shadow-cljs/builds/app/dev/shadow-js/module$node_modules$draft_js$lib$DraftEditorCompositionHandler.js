["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/DraftEditorCompositionHandler.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$DraftEditorCompositionHandler=function(global,process,require,module,exports,shadow$shims){var DraftFeatureFlags=require(\"module$node_modules$draft_js$lib$DraftFeatureFlags\"),DraftModifier=require(\"module$node_modules$draft_js$lib$DraftModifier\"),EditorState=require(\"module$node_modules$draft_js$lib$EditorState\"),Keys=require(\"module$node_modules$fbjs$lib$Keys\"),getEntityKeyForSelection=require(\"module$node_modules$draft_js$lib$getEntityKeyForSelection\"),\nisEventHandled=require(\"module$node_modules$draft_js$lib$isEventHandled\"),isSelectionAtLeafStart=require(\"module$node_modules$draft_js$lib$isSelectionAtLeafStart\"),resolved=!1,stillComposing=!1,textInputData=\"\",DraftEditorCompositionHandler={onBeforeInput:function(editor,e){textInputData=(textInputData||\"\")+e.data},onCompositionStart:function(editor){stillComposing=!0},onCompositionEnd:function(editor){stillComposing=resolved=!1;setTimeout(function(){resolved||DraftEditorCompositionHandler.resolveComposition(editor)},\n20)},onKeyDown:function(editor,e){stillComposing?e.which!==Keys.RIGHT&&e.which!==Keys.LEFT||e.preventDefault():(DraftEditorCompositionHandler.resolveComposition(editor),editor._onKeyDown(e))},onKeyPress:function(editor,e){e.which===Keys.RETURN&&e.preventDefault()},resolveComposition:function(editor){if(!stillComposing){resolved=!0;var composedChars=textInputData;textInputData=\"\";var editorState=EditorState.set(editor._latestEditorState,{inCompositionMode:!1}),currentStyle=editorState.getCurrentInlineStyle(),\nentityKey=getEntityKeyForSelection(editorState.getCurrentContent(),editorState.getSelection()),mustReset=!composedChars||isSelectionAtLeafStart(editorState)||0<currentStyle.size||null!==entityKey;mustReset&&editor.restoreEditorDOM();editor.exitCurrentMode();composedChars?DraftFeatureFlags.draft_handlebeforeinput_composed_text&&editor.props.handleBeforeInput&&isEventHandled(editor.props.handleBeforeInput(composedChars,editorState))||(composedChars=DraftModifier.replaceText(editorState.getCurrentContent(),\neditorState.getSelection(),composedChars,currentStyle,entityKey),editor.update(EditorState.push(editorState,composedChars,\"insert-characters\"))):mustReset&&editor.update(EditorState.set(editorState,{nativelyRenderedContent:null,forceSelection:!0}))}}};module.exports=DraftEditorCompositionHandler}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$DraftEditorCompositionHandler\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DraftEditorCompositionHandler\n * @format\n * \n */\n\n'use strict';\n\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftModifier = require('./DraftModifier');\nvar EditorState = require('./EditorState');\nvar Keys = require('fbjs/lib/Keys');\n\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\nvar isEventHandled = require('./isEventHandled');\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\n\n/**\n * Millisecond delay to allow `compositionstart` to fire again upon\n * `compositionend`.\n *\n * This is used for Korean input to ensure that typing can continue without\n * the editor trying to render too quickly. More specifically, Safari 7.1+\n * triggers `compositionstart` a little slower than Chrome/FF, which\n * leads to composed characters being resolved and re-render occurring\n * sooner than we want.\n */\nvar RESOLVE_DELAY = 20;\n\n/**\n * A handful of variables used to track the current composition and its\n * resolution status. These exist at the module level because it is not\n * possible to have compositions occurring in multiple editors simultaneously,\n * and it simplifies state management with respect to the DraftEditor component.\n */\nvar resolved = false;\nvar stillComposing = false;\nvar textInputData = '';\n\nvar DraftEditorCompositionHandler = {\n  onBeforeInput: function onBeforeInput(editor, e) {\n    textInputData = (textInputData || '') + e.data;\n  },\n\n  /**\n   * A `compositionstart` event has fired while we're still in composition\n   * mode. Continue the current composition session to prevent a re-render.\n   */\n  onCompositionStart: function onCompositionStart(editor) {\n    stillComposing = true;\n  },\n\n  /**\n   * Attempt to end the current composition session.\n   *\n   * Defer handling because browser will still insert the chars into active\n   * element after `compositionend`. If a `compositionstart` event fires\n   * before `resolveComposition` executes, our composition session will\n   * continue.\n   *\n   * The `resolved` flag is useful because certain IME interfaces fire the\n   * `compositionend` event multiple times, thus queueing up multiple attempts\n   * at handling the composition. Since handling the same composition event\n   * twice could break the DOM, we only use the first event. Example: Arabic\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\n   */\n  onCompositionEnd: function onCompositionEnd(editor) {\n    resolved = false;\n    stillComposing = false;\n    setTimeout(function () {\n      if (!resolved) {\n        DraftEditorCompositionHandler.resolveComposition(editor);\n      }\n    }, RESOLVE_DELAY);\n  },\n\n  /**\n   * In Safari, keydown events may fire when committing compositions. If\n   * the arrow keys are used to commit, prevent default so that the cursor\n   * doesn't move, otherwise it will jump back noticeably on re-render.\n   */\n  onKeyDown: function onKeyDown(editor, e) {\n    if (!stillComposing) {\n      // If a keydown event is received after compositionend but before the\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\n      // backspace in 2-Set Korean), we should immediately resolve the\n      // composition and reinterpret the key press in edit mode.\n      DraftEditorCompositionHandler.resolveComposition(editor);\n      editor._onKeyDown(e);\n      return;\n    }\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\n      e.preventDefault();\n    }\n  },\n\n  /**\n   * Keypress events may fire when committing compositions. In Firefox,\n   * pressing RETURN commits the composition and inserts extra newline\n   * characters that we do not want. `preventDefault` allows the composition\n   * to be committed while preventing the extra characters.\n   */\n  onKeyPress: function onKeyPress(editor, e) {\n    if (e.which === Keys.RETURN) {\n      e.preventDefault();\n    }\n  },\n\n  /**\n   * Attempt to insert composed characters into the document.\n   *\n   * If we are still in a composition session, do nothing. Otherwise, insert\n   * the characters into the document and terminate the composition session.\n   *\n   * If no characters were composed -- for instance, the user\n   * deleted all composed characters and committed nothing new --\n   * force a re-render. We also re-render when the composition occurs\n   * at the beginning of a leaf, to ensure that if the browser has\n   * created a new text node for the composition, we will discard it.\n   *\n   * Resetting innerHTML will move focus to the beginning of the editor,\n   * so we update to force it back to the correct place.\n   */\n  resolveComposition: function resolveComposition(editor) {\n    if (stillComposing) {\n      return;\n    }\n\n    resolved = true;\n    var composedChars = textInputData;\n    textInputData = '';\n\n    var editorState = EditorState.set(editor._latestEditorState, {\n      inCompositionMode: false\n    });\n\n    var currentStyle = editorState.getCurrentInlineStyle();\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\n\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\n\n    if (mustReset) {\n      editor.restoreEditorDOM();\n    }\n\n    editor.exitCurrentMode();\n\n    if (composedChars) {\n      if (DraftFeatureFlags.draft_handlebeforeinput_composed_text && editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(composedChars, editorState))) {\n        return;\n      }\n      // If characters have been composed, re-rendering with the update\n      // is sufficient to reset the editor.\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\n      return;\n    }\n\n    if (mustReset) {\n      editor.update(EditorState.set(editorState, {\n        nativelyRenderedContent: null,\n        forceSelection: true\n      }));\n    }\n  }\n};\n\nmodule.exports = DraftEditorCompositionHandler;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$draft_js$lib$isEventHandled","~$module$node_modules$fbjs$lib$Keys","~$module$node_modules$draft_js$lib$getEntityKeyForSelection","~$shadow.js","~$module$node_modules$draft_js$lib$DraftFeatureFlags","~$module$node_modules$draft_js$lib$DraftModifier","~$module$node_modules$draft_js$lib$EditorState","~$module$node_modules$draft_js$lib$isSelectionAtLeafStart"]],"~:properties",["^5",["onCompositionStart","resolveComposition","onKeyPress","onBeforeInput","forceSelection","nativelyRenderedContent","inCompositionMode","onKeyDown","onCompositionEnd"]],"~:compiled-at",1532351402135,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$DraftEditorCompositionHandler.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/DraftEditorCompositionHandler.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$DraftEditorCompositionHandler\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule DraftEditorCompositionHandler\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\\nvar DraftModifier = require('./DraftModifier');\\nvar EditorState = require('./EditorState');\\nvar Keys = require('fbjs/lib/Keys');\\n\\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\\nvar isEventHandled = require('./isEventHandled');\\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\\n\\n/**\\n * Millisecond delay to allow `compositionstart` to fire again upon\\n * `compositionend`.\\n *\\n * This is used for Korean input to ensure that typing can continue without\\n * the editor trying to render too quickly. More specifically, Safari 7.1+\\n * triggers `compositionstart` a little slower than Chrome/FF, which\\n * leads to composed characters being resolved and re-render occurring\\n * sooner than we want.\\n */\\nvar RESOLVE_DELAY = 20;\\n\\n/**\\n * A handful of variables used to track the current composition and its\\n * resolution status. These exist at the module level because it is not\\n * possible to have compositions occurring in multiple editors simultaneously,\\n * and it simplifies state management with respect to the DraftEditor component.\\n */\\nvar resolved = false;\\nvar stillComposing = false;\\nvar textInputData = '';\\n\\nvar DraftEditorCompositionHandler = {\\n  onBeforeInput: function onBeforeInput(editor, e) {\\n    textInputData = (textInputData || '') + e.data;\\n  },\\n\\n  /**\\n   * A `compositionstart` event has fired while we're still in composition\\n   * mode. Continue the current composition session to prevent a re-render.\\n   */\\n  onCompositionStart: function onCompositionStart(editor) {\\n    stillComposing = true;\\n  },\\n\\n  /**\\n   * Attempt to end the current composition session.\\n   *\\n   * Defer handling because browser will still insert the chars into active\\n   * element after `compositionend`. If a `compositionstart` event fires\\n   * before `resolveComposition` executes, our composition session will\\n   * continue.\\n   *\\n   * The `resolved` flag is useful because certain IME interfaces fire the\\n   * `compositionend` event multiple times, thus queueing up multiple attempts\\n   * at handling the composition. Since handling the same composition event\\n   * twice could break the DOM, we only use the first event. Example: Arabic\\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\\n   */\\n  onCompositionEnd: function onCompositionEnd(editor) {\\n    resolved = false;\\n    stillComposing = false;\\n    setTimeout(function () {\\n      if (!resolved) {\\n        DraftEditorCompositionHandler.resolveComposition(editor);\\n      }\\n    }, RESOLVE_DELAY);\\n  },\\n\\n  /**\\n   * In Safari, keydown events may fire when committing compositions. If\\n   * the arrow keys are used to commit, prevent default so that the cursor\\n   * doesn't move, otherwise it will jump back noticeably on re-render.\\n   */\\n  onKeyDown: function onKeyDown(editor, e) {\\n    if (!stillComposing) {\\n      // If a keydown event is received after compositionend but before the\\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\\n      // backspace in 2-Set Korean), we should immediately resolve the\\n      // composition and reinterpret the key press in edit mode.\\n      DraftEditorCompositionHandler.resolveComposition(editor);\\n      editor._onKeyDown(e);\\n      return;\\n    }\\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\\n      e.preventDefault();\\n    }\\n  },\\n\\n  /**\\n   * Keypress events may fire when committing compositions. In Firefox,\\n   * pressing RETURN commits the composition and inserts extra newline\\n   * characters that we do not want. `preventDefault` allows the composition\\n   * to be committed while preventing the extra characters.\\n   */\\n  onKeyPress: function onKeyPress(editor, e) {\\n    if (e.which === Keys.RETURN) {\\n      e.preventDefault();\\n    }\\n  },\\n\\n  /**\\n   * Attempt to insert composed characters into the document.\\n   *\\n   * If we are still in a composition session, do nothing. Otherwise, insert\\n   * the characters into the document and terminate the composition session.\\n   *\\n   * If no characters were composed -- for instance, the user\\n   * deleted all composed characters and committed nothing new --\\n   * force a re-render. We also re-render when the composition occurs\\n   * at the beginning of a leaf, to ensure that if the browser has\\n   * created a new text node for the composition, we will discard it.\\n   *\\n   * Resetting innerHTML will move focus to the beginning of the editor,\\n   * so we update to force it back to the correct place.\\n   */\\n  resolveComposition: function resolveComposition(editor) {\\n    if (stillComposing) {\\n      return;\\n    }\\n\\n    resolved = true;\\n    var composedChars = textInputData;\\n    textInputData = '';\\n\\n    var editorState = EditorState.set(editor._latestEditorState, {\\n      inCompositionMode: false\\n    });\\n\\n    var currentStyle = editorState.getCurrentInlineStyle();\\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\\n\\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\\n\\n    if (mustReset) {\\n      editor.restoreEditorDOM();\\n    }\\n\\n    editor.exitCurrentMode();\\n\\n    if (composedChars) {\\n      if (DraftFeatureFlags.draft_handlebeforeinput_composed_text && editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(composedChars, editorState))) {\\n        return;\\n      }\\n      // If characters have been composed, re-rendering with the update\\n      // is sufficient to reset the editor.\\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\\n      return;\\n    }\\n\\n    if (mustReset) {\\n      editor.update(EditorState.set(editorState, {\\n        nativelyRenderedContent: null,\\n        forceSelection: true\\n      }));\\n    }\\n  }\\n};\\n\\nmodule.exports = DraftEditorCompositionHandler;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"DraftFeatureFlags\",\"DraftModifier\",\"EditorState\",\"Keys\",\"getEntityKeyForSelection\",\"isEventHandled\",\"isSelectionAtLeafStart\",\"resolved\",\"stillComposing\",\"textInputData\",\"DraftEditorCompositionHandler\",\"onBeforeInput\",\"editor\",\"e\",\"data\",\"onCompositionStart\",\"onCompositionEnd\",\"setTimeout\",\"resolveComposition\",\"RESOLVE_DELAY\",\"onKeyDown\",\"which\",\"RIGHT\",\"LEFT\",\"preventDefault\",\"_onKeyDown\",\"onKeyPress\",\"RETURN\",\"composedChars\",\"editorState\",\"set\",\"_latestEditorState\",\"inCompositionMode\",\"currentStyle\",\"getCurrentInlineStyle\",\"entityKey\",\"getCurrentContent\",\"getSelection\",\"mustReset\",\"size\",\"restoreEditorDOM\",\"exitCurrentMode\",\"draft_handlebeforeinput_composed_text\",\"props\",\"handleBeforeInput\",\"contentState\",\"replaceText\",\"update\",\"push\",\"nativelyRenderedContent\",\"forceSelection\"]\n}\n"]