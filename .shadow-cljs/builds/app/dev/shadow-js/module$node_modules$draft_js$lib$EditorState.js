["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/EditorState.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$EditorState=function(global,process,require,module,exports,shadow$shims){function updateSelection(editorState,selection,forceSelection){return EditorState.set(editorState,{selection:selection,forceSelection:forceSelection,nativelyRenderedContent:null,inlineStyleOverride:null})}function generateNewTreeMap(contentState,decorator){return contentState.getBlockMap().map(function(block){return BlockTree.generate(contentState,block,decorator)}).toOrderedMap()}\nfunction regenerateTreeForNewBlocks(editorState,newBlockMap,newEntityMap,decorator){var contentState=editorState.getCurrentContent().set(\"entityMap\",newEntityMap),prevBlockMap=contentState.getBlockMap();return editorState.getImmutable().get(\"treeMap\").merge(newBlockMap.toSeq().filter(function(block,key){return block!==prevBlockMap.get(key)}).map(function(block){return BlockTree.generate(contentState,block,decorator)}))}function regenerateTreeForNewDecorator(content,blockMap,previousTreeMap,decorator,\nexistingDecorator){return previousTreeMap.merge(blockMap.toSeq().filter(function(block){return decorator.getDecorations(block,content)!==existingDecorator.getDecorations(block,content)}).map(function(block){return BlockTree.generate(content,block,decorator)}))}function lookUpwardForInlineStyle(content,fromKey){return(content=content.getBlockMap().reverse().skipUntil(function(_,k){return k===fromKey}).skip(1).skipUntil(function(block,_){return block.getLength()}).first())?content.getInlineStyleAt(content.getLength()-\n1):OrderedSet()}var _extends=require(\"module$node_modules$object_assign$index\")||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},BlockTree=require(\"module$node_modules$draft_js$lib$BlockTree\"),ContentState=require(\"module$node_modules$draft_js$lib$ContentState\"),EditorBidiService=require(\"module$node_modules$draft_js$lib$EditorBidiService\");global=require(\"module$node_modules$immutable$dist$immutable\");\nvar SelectionState=require(\"module$node_modules$draft_js$lib$SelectionState\"),OrderedSet=global.OrderedSet;require=global.Record;var Stack=global.Stack;global={allowUndo:!0,currentContent:null,decorator:null,directionMap:null,forceSelection:!1,inCompositionMode:!1,inlineStyleOverride:null,lastChangeType:null,nativelyRenderedContent:null,redoStack:Stack(),selection:null,treeMap:null,undoStack:Stack()};var EditorStateRecord=require(global),EditorState=function(){function EditorState(immutable){if(!(this instanceof\nEditorState))throw new TypeError(\"Cannot call a class as a function\");this._immutable=immutable}EditorState.createEmpty=function(decorator){return EditorState.createWithContent(ContentState.createFromText(\"\"),decorator)};EditorState.createWithContent=function(contentState,decorator){var firstKey=contentState.getBlockMap().first().getKey();return EditorState.create({currentContent:contentState,undoStack:Stack(),redoStack:Stack(),decorator:decorator||null,selection:SelectionState.createEmpty(firstKey)})};\nEditorState.create=function(config){var currentContent=config.currentContent;config=_extends({},config,{treeMap:generateNewTreeMap(currentContent,config.decorator),directionMap:EditorBidiService.getDirectionMap(currentContent)});return new EditorState(new EditorStateRecord(config))};EditorState.set=function(editorState,put){var map=editorState.getImmutable().withMutations(function(state){var existingDecorator=state.get(\"decorator\"),decorator=existingDecorator;null===put.decorator?decorator=null:put.decorator&&\n(decorator=put.decorator);var newContent=put.currentContent||editorState.getCurrentContent();if(decorator!==existingDecorator){var treeMap=state.get(\"treeMap\");newContent=decorator&&existingDecorator?regenerateTreeForNewDecorator(newContent,newContent.getBlockMap(),treeMap,decorator,existingDecorator):generateNewTreeMap(newContent,decorator);state.merge({decorator:decorator,treeMap:newContent,nativelyRenderedContent:null})}else existingDecorator=editorState.getCurrentContent(),newContent!==existingDecorator&&\nstate.set(\"treeMap\",regenerateTreeForNewBlocks(editorState,newContent.getBlockMap(),newContent.getEntityMap(),decorator)),state.merge(put)});return new EditorState(map)};EditorState.prototype.toJS=function(){return this.getImmutable().toJS()};EditorState.prototype.getAllowUndo=function(){return this.getImmutable().get(\"allowUndo\")};EditorState.prototype.getCurrentContent=function(){return this.getImmutable().get(\"currentContent\")};EditorState.prototype.getUndoStack=function(){return this.getImmutable().get(\"undoStack\")};\nEditorState.prototype.getRedoStack=function(){return this.getImmutable().get(\"redoStack\")};EditorState.prototype.getSelection=function(){return this.getImmutable().get(\"selection\")};EditorState.prototype.getDecorator=function(){return this.getImmutable().get(\"decorator\")};EditorState.prototype.isInCompositionMode=function(){return this.getImmutable().get(\"inCompositionMode\")};EditorState.prototype.mustForceSelection=function(){return this.getImmutable().get(\"forceSelection\")};EditorState.prototype.getNativelyRenderedContent=\nfunction(){return this.getImmutable().get(\"nativelyRenderedContent\")};EditorState.prototype.getLastChangeType=function(){return this.getImmutable().get(\"lastChangeType\")};EditorState.prototype.getInlineStyleOverride=function(){return this.getImmutable().get(\"inlineStyleOverride\")};EditorState.setInlineStyleOverride=function(editorState,inlineStyleOverride){return EditorState.set(editorState,{inlineStyleOverride:inlineStyleOverride})};EditorState.prototype.getCurrentInlineStyle=function(){var override=\nthis.getInlineStyleOverride();if(null!=override)return override;override=this.getCurrentContent();var selection=this.getSelection();if(selection.isCollapsed()){var startKey=selection.getStartKey();selection=selection.getStartOffset();var startBlock=override.getBlockForKey(startKey);override=0<selection?startBlock.getInlineStyleAt(selection-1):startBlock.getLength()?startBlock.getInlineStyleAt(0):lookUpwardForInlineStyle(override,startKey);return override}startKey=selection.getStartKey();selection=\nselection.getStartOffset();startBlock=override.getBlockForKey(startKey);override=selection<startBlock.getLength()?startBlock.getInlineStyleAt(selection):0<selection?startBlock.getInlineStyleAt(selection-1):lookUpwardForInlineStyle(override,startKey);return override};EditorState.prototype.getBlockTree=function(blockKey){return this.getImmutable().getIn([\"treeMap\",blockKey])};EditorState.prototype.isSelectionAtStartOfContent=function(){var firstKey=this.getCurrentContent().getBlockMap().first().getKey();\nreturn this.getSelection().hasEdgeWithin(firstKey,0,0)};EditorState.prototype.isSelectionAtEndOfContent=function(){var last=this.getCurrentContent().getBlockMap().last(),end=last.getLength();return this.getSelection().hasEdgeWithin(last.getKey(),end,end)};EditorState.prototype.getDirectionMap=function(){return this.getImmutable().get(\"directionMap\")};EditorState.acceptSelection=function(editorState,selection){return updateSelection(editorState,selection,!1)};EditorState.forceSelection=function(editorState,\nselection){selection.getHasFocus()||(selection=selection.set(\"hasFocus\",!0));return updateSelection(editorState,selection,!0)};EditorState.moveSelectionToEnd=function(editorState){var lastBlock=editorState.getCurrentContent().getLastBlock(),lastKey=lastBlock.getKey();lastBlock=lastBlock.getLength();return EditorState.acceptSelection(editorState,new SelectionState({anchorKey:lastKey,anchorOffset:lastBlock,focusKey:lastKey,focusOffset:lastBlock,isBackward:!1}))};EditorState.moveFocusToEnd=function(editorState){editorState=\nEditorState.moveSelectionToEnd(editorState);return EditorState.forceSelection(editorState,editorState.getSelection())};EditorState.push=function(editorState,contentState,changeType){if(editorState.getCurrentContent()===contentState)return editorState;var forceSelection=\"insert-characters\"!==changeType,directionMap=EditorBidiService.getDirectionMap(contentState,editorState.getDirectionMap());if(!editorState.getAllowUndo())return EditorState.set(editorState,{currentContent:contentState,directionMap:directionMap,\nlastChangeType:changeType,selection:contentState.getSelectionAfter(),forceSelection:forceSelection,inlineStyleOverride:null});var selection=editorState.getSelection(),currentContent=editorState.getCurrentContent(),undoStack=editorState.getUndoStack(),newContent=contentState,JSCompiler_temp;(JSCompiler_temp=selection!==currentContent.getSelectionAfter())||(JSCompiler_temp=editorState.getLastChangeType(),JSCompiler_temp=changeType!==JSCompiler_temp||\"insert-characters\"!==changeType&&\"backspace-character\"!==\nchangeType&&\"delete-character\"!==changeType);if(JSCompiler_temp)undoStack=undoStack.push(currentContent),newContent=newContent.set(\"selectionBefore\",selection);else if(\"insert-characters\"===changeType||\"backspace-character\"===changeType||\"delete-character\"===changeType)newContent=newContent.set(\"selectionBefore\",currentContent.getSelectionBefore());selection=editorState.getInlineStyleOverride();-1===[\"adjust-depth\",\"change-block-type\",\"split-block\"].indexOf(changeType)&&(selection=null);contentState=\n{currentContent:newContent,directionMap:directionMap,undoStack:undoStack,redoStack:Stack(),lastChangeType:changeType,selection:contentState.getSelectionAfter(),forceSelection:forceSelection,inlineStyleOverride:selection};return EditorState.set(editorState,contentState)};EditorState.undo=function(editorState){if(!editorState.getAllowUndo())return editorState;var undoStack=editorState.getUndoStack(),newCurrentContent=undoStack.peek();if(!newCurrentContent)return editorState;var currentContent=editorState.getCurrentContent(),\ndirectionMap=EditorBidiService.getDirectionMap(newCurrentContent,editorState.getDirectionMap());return EditorState.set(editorState,{currentContent:newCurrentContent,directionMap:directionMap,undoStack:undoStack.shift(),redoStack:editorState.getRedoStack().push(currentContent),forceSelection:!0,inlineStyleOverride:null,lastChangeType:\"undo\",nativelyRenderedContent:null,selection:currentContent.getSelectionBefore()})};EditorState.redo=function(editorState){if(!editorState.getAllowUndo())return editorState;\nvar redoStack=editorState.getRedoStack(),newCurrentContent=redoStack.peek();if(!newCurrentContent)return editorState;var currentContent=editorState.getCurrentContent(),directionMap=EditorBidiService.getDirectionMap(newCurrentContent,editorState.getDirectionMap());return EditorState.set(editorState,{currentContent:newCurrentContent,directionMap:directionMap,undoStack:editorState.getUndoStack().push(currentContent),redoStack:redoStack.shift(),forceSelection:!0,inlineStyleOverride:null,lastChangeType:\"redo\",\nnativelyRenderedContent:null,selection:newCurrentContent.getSelectionAfter()})};EditorState.prototype.getImmutable=function(){return this._immutable};return EditorState}();module.exports=EditorState}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$EditorState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EditorState\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BlockTree = require('./BlockTree');\nvar ContentState = require('./ContentState');\nvar EditorBidiService = require('./EditorBidiService');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\n\nvar OrderedSet = Immutable.OrderedSet,\n    Record = Immutable.Record,\n    Stack = Immutable.Stack;\n\n\nvar defaultRecord = {\n  allowUndo: true,\n  currentContent: null,\n  decorator: null,\n  directionMap: null,\n  forceSelection: false,\n  inCompositionMode: false,\n  inlineStyleOverride: null,\n  lastChangeType: null,\n  nativelyRenderedContent: null,\n  redoStack: Stack(),\n  selection: null,\n  treeMap: null,\n  undoStack: Stack()\n};\n\nvar EditorStateRecord = Record(defaultRecord);\n\nvar EditorState = function () {\n  EditorState.createEmpty = function createEmpty(decorator) {\n    return EditorState.createWithContent(ContentState.createFromText(''), decorator);\n  };\n\n  EditorState.createWithContent = function createWithContent(contentState, decorator) {\n    var firstKey = contentState.getBlockMap().first().getKey();\n    return EditorState.create({\n      currentContent: contentState,\n      undoStack: Stack(),\n      redoStack: Stack(),\n      decorator: decorator || null,\n      selection: SelectionState.createEmpty(firstKey)\n    });\n  };\n\n  EditorState.create = function create(config) {\n    var currentContent = config.currentContent,\n        decorator = config.decorator;\n\n    var recordConfig = _extends({}, config, {\n      treeMap: generateNewTreeMap(currentContent, decorator),\n      directionMap: EditorBidiService.getDirectionMap(currentContent)\n    });\n    return new EditorState(new EditorStateRecord(recordConfig));\n  };\n\n  EditorState.set = function set(editorState, put) {\n    var map = editorState.getImmutable().withMutations(function (state) {\n      var existingDecorator = state.get('decorator');\n      var decorator = existingDecorator;\n      if (put.decorator === null) {\n        decorator = null;\n      } else if (put.decorator) {\n        decorator = put.decorator;\n      }\n\n      var newContent = put.currentContent || editorState.getCurrentContent();\n\n      if (decorator !== existingDecorator) {\n        var treeMap = state.get('treeMap');\n        var newTreeMap;\n        if (decorator && existingDecorator) {\n          newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);\n        } else {\n          newTreeMap = generateNewTreeMap(newContent, decorator);\n        }\n\n        state.merge({\n          decorator: decorator,\n          treeMap: newTreeMap,\n          nativelyRenderedContent: null\n        });\n        return;\n      }\n\n      var existingContent = editorState.getCurrentContent();\n      if (newContent !== existingContent) {\n        state.set('treeMap', regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));\n      }\n\n      state.merge(put);\n    });\n\n    return new EditorState(map);\n  };\n\n  EditorState.prototype.toJS = function toJS() {\n    return this.getImmutable().toJS();\n  };\n\n  EditorState.prototype.getAllowUndo = function getAllowUndo() {\n    return this.getImmutable().get('allowUndo');\n  };\n\n  EditorState.prototype.getCurrentContent = function getCurrentContent() {\n    return this.getImmutable().get('currentContent');\n  };\n\n  EditorState.prototype.getUndoStack = function getUndoStack() {\n    return this.getImmutable().get('undoStack');\n  };\n\n  EditorState.prototype.getRedoStack = function getRedoStack() {\n    return this.getImmutable().get('redoStack');\n  };\n\n  EditorState.prototype.getSelection = function getSelection() {\n    return this.getImmutable().get('selection');\n  };\n\n  EditorState.prototype.getDecorator = function getDecorator() {\n    return this.getImmutable().get('decorator');\n  };\n\n  EditorState.prototype.isInCompositionMode = function isInCompositionMode() {\n    return this.getImmutable().get('inCompositionMode');\n  };\n\n  EditorState.prototype.mustForceSelection = function mustForceSelection() {\n    return this.getImmutable().get('forceSelection');\n  };\n\n  EditorState.prototype.getNativelyRenderedContent = function getNativelyRenderedContent() {\n    return this.getImmutable().get('nativelyRenderedContent');\n  };\n\n  EditorState.prototype.getLastChangeType = function getLastChangeType() {\n    return this.getImmutable().get('lastChangeType');\n  };\n\n  /**\n   * While editing, the user may apply inline style commands with a collapsed\n   * cursor, intending to type text that adopts the specified style. In this\n   * case, we track the specified style as an \"override\" that takes precedence\n   * over the inline style of the text adjacent to the cursor.\n   *\n   * If null, there is no override in place.\n   */\n\n\n  EditorState.prototype.getInlineStyleOverride = function getInlineStyleOverride() {\n    return this.getImmutable().get('inlineStyleOverride');\n  };\n\n  EditorState.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {\n    return EditorState.set(editorState, { inlineStyleOverride: inlineStyleOverride });\n  };\n\n  /**\n   * Get the appropriate inline style for the editor state. If an\n   * override is in place, use it. Otherwise, the current style is\n   * based on the location of the selection state.\n   */\n\n\n  EditorState.prototype.getCurrentInlineStyle = function getCurrentInlineStyle() {\n    var override = this.getInlineStyleOverride();\n    if (override != null) {\n      return override;\n    }\n\n    var content = this.getCurrentContent();\n    var selection = this.getSelection();\n\n    if (selection.isCollapsed()) {\n      return getInlineStyleForCollapsedSelection(content, selection);\n    }\n\n    return getInlineStyleForNonCollapsedSelection(content, selection);\n  };\n\n  EditorState.prototype.getBlockTree = function getBlockTree(blockKey) {\n    return this.getImmutable().getIn(['treeMap', blockKey]);\n  };\n\n  EditorState.prototype.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {\n    var firstKey = this.getCurrentContent().getBlockMap().first().getKey();\n    return this.getSelection().hasEdgeWithin(firstKey, 0, 0);\n  };\n\n  EditorState.prototype.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {\n    var content = this.getCurrentContent();\n    var blockMap = content.getBlockMap();\n    var last = blockMap.last();\n    var end = last.getLength();\n    return this.getSelection().hasEdgeWithin(last.getKey(), end, end);\n  };\n\n  EditorState.prototype.getDirectionMap = function getDirectionMap() {\n    return this.getImmutable().get('directionMap');\n  };\n\n  /**\n   * Incorporate native DOM selection changes into the EditorState. This\n   * method can be used when we simply want to accept whatever the DOM\n   * has given us to represent selection, and we do not need to re-render\n   * the editor.\n   *\n   * To forcibly move the DOM selection, see `EditorState.forceSelection`.\n   */\n\n\n  EditorState.acceptSelection = function acceptSelection(editorState, selection) {\n    return updateSelection(editorState, selection, false);\n  };\n\n  /**\n   * At times, we need to force the DOM selection to be where we\n   * need it to be. This can occur when the anchor or focus nodes\n   * are non-text nodes, for instance. In this case, we want to trigger\n   * a re-render of the editor, which in turn forces selection into\n   * the correct place in the DOM. The `forceSelection` method\n   * accomplishes this.\n   *\n   * This method should be used in cases where you need to explicitly\n   * move the DOM selection from one place to another without a change\n   * in ContentState.\n   */\n\n\n  EditorState.forceSelection = function forceSelection(editorState, selection) {\n    if (!selection.getHasFocus()) {\n      selection = selection.set('hasFocus', true);\n    }\n    return updateSelection(editorState, selection, true);\n  };\n\n  /**\n   * Move selection to the end of the editor without forcing focus.\n   */\n\n\n  EditorState.moveSelectionToEnd = function moveSelectionToEnd(editorState) {\n    var content = editorState.getCurrentContent();\n    var lastBlock = content.getLastBlock();\n    var lastKey = lastBlock.getKey();\n    var length = lastBlock.getLength();\n\n    return EditorState.acceptSelection(editorState, new SelectionState({\n      anchorKey: lastKey,\n      anchorOffset: length,\n      focusKey: lastKey,\n      focusOffset: length,\n      isBackward: false\n    }));\n  };\n\n  /**\n   * Force focus to the end of the editor. This is useful in scenarios\n   * where we want to programmatically focus the input and it makes sense\n   * to allow the user to continue working seamlessly.\n   */\n\n\n  EditorState.moveFocusToEnd = function moveFocusToEnd(editorState) {\n    var afterSelectionMove = EditorState.moveSelectionToEnd(editorState);\n    return EditorState.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());\n  };\n\n  /**\n   * Push the current ContentState onto the undo stack if it should be\n   * considered a boundary state, and set the provided ContentState as the\n   * new current content.\n   */\n\n\n  EditorState.push = function push(editorState, contentState, changeType) {\n    if (editorState.getCurrentContent() === contentState) {\n      return editorState;\n    }\n\n    var forceSelection = changeType !== 'insert-characters';\n    var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());\n\n    if (!editorState.getAllowUndo()) {\n      return EditorState.set(editorState, {\n        currentContent: contentState,\n        directionMap: directionMap,\n        lastChangeType: changeType,\n        selection: contentState.getSelectionAfter(),\n        forceSelection: forceSelection,\n        inlineStyleOverride: null\n      });\n    }\n\n    var selection = editorState.getSelection();\n    var currentContent = editorState.getCurrentContent();\n    var undoStack = editorState.getUndoStack();\n    var newContent = contentState;\n\n    if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {\n      undoStack = undoStack.push(currentContent);\n      newContent = newContent.set('selectionBefore', selection);\n    } else if (changeType === 'insert-characters' || changeType === 'backspace-character' || changeType === 'delete-character') {\n      // Preserve the previous selection.\n      newContent = newContent.set('selectionBefore', currentContent.getSelectionBefore());\n    }\n\n    var inlineStyleOverride = editorState.getInlineStyleOverride();\n\n    // Don't discard inline style overrides for the following change types:\n    var overrideChangeTypes = ['adjust-depth', 'change-block-type', 'split-block'];\n\n    if (overrideChangeTypes.indexOf(changeType) === -1) {\n      inlineStyleOverride = null;\n    }\n\n    var editorStateChanges = {\n      currentContent: newContent,\n      directionMap: directionMap,\n      undoStack: undoStack,\n      redoStack: Stack(),\n      lastChangeType: changeType,\n      selection: contentState.getSelectionAfter(),\n      forceSelection: forceSelection,\n      inlineStyleOverride: inlineStyleOverride\n    };\n\n    return EditorState.set(editorState, editorStateChanges);\n  };\n\n  /**\n   * Make the top ContentState in the undo stack the new current content and\n   * push the current content onto the redo stack.\n   */\n\n\n  EditorState.undo = function undo(editorState) {\n    if (!editorState.getAllowUndo()) {\n      return editorState;\n    }\n\n    var undoStack = editorState.getUndoStack();\n    var newCurrentContent = undoStack.peek();\n    if (!newCurrentContent) {\n      return editorState;\n    }\n\n    var currentContent = editorState.getCurrentContent();\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\n\n    return EditorState.set(editorState, {\n      currentContent: newCurrentContent,\n      directionMap: directionMap,\n      undoStack: undoStack.shift(),\n      redoStack: editorState.getRedoStack().push(currentContent),\n      forceSelection: true,\n      inlineStyleOverride: null,\n      lastChangeType: 'undo',\n      nativelyRenderedContent: null,\n      selection: currentContent.getSelectionBefore()\n    });\n  };\n\n  /**\n   * Make the top ContentState in the redo stack the new current content and\n   * push the current content onto the undo stack.\n   */\n\n\n  EditorState.redo = function redo(editorState) {\n    if (!editorState.getAllowUndo()) {\n      return editorState;\n    }\n\n    var redoStack = editorState.getRedoStack();\n    var newCurrentContent = redoStack.peek();\n    if (!newCurrentContent) {\n      return editorState;\n    }\n\n    var currentContent = editorState.getCurrentContent();\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\n\n    return EditorState.set(editorState, {\n      currentContent: newCurrentContent,\n      directionMap: directionMap,\n      undoStack: editorState.getUndoStack().push(currentContent),\n      redoStack: redoStack.shift(),\n      forceSelection: true,\n      inlineStyleOverride: null,\n      lastChangeType: 'redo',\n      nativelyRenderedContent: null,\n      selection: newCurrentContent.getSelectionAfter()\n    });\n  };\n\n  /**\n   * Not for public consumption.\n   */\n\n\n  function EditorState(immutable) {\n    _classCallCheck(this, EditorState);\n\n    this._immutable = immutable;\n  }\n\n  /**\n   * Not for public consumption.\n   */\n\n\n  EditorState.prototype.getImmutable = function getImmutable() {\n    return this._immutable;\n  };\n\n  return EditorState;\n}();\n\n/**\n * Set the supplied SelectionState as the new current selection, and set\n * the `force` flag to trigger manual selection placement by the view.\n */\n\n\nfunction updateSelection(editorState, selection, forceSelection) {\n  return EditorState.set(editorState, {\n    selection: selection,\n    forceSelection: forceSelection,\n    nativelyRenderedContent: null,\n    inlineStyleOverride: null\n  });\n}\n\n/**\n * Regenerate the entire tree map for a given ContentState and decorator.\n * Returns an OrderedMap that maps all available ContentBlock objects.\n */\nfunction generateNewTreeMap(contentState, decorator) {\n  return contentState.getBlockMap().map(function (block) {\n    return BlockTree.generate(contentState, block, decorator);\n  }).toOrderedMap();\n}\n\n/**\n * Regenerate tree map objects for all ContentBlocks that have changed\n * between the current editorState and newContent. Returns an OrderedMap\n * with only changed regenerated tree map objects.\n */\nfunction regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {\n  var contentState = editorState.getCurrentContent().set('entityMap', newEntityMap);\n  var prevBlockMap = contentState.getBlockMap();\n  var prevTreeMap = editorState.getImmutable().get('treeMap');\n  return prevTreeMap.merge(newBlockMap.toSeq().filter(function (block, key) {\n    return block !== prevBlockMap.get(key);\n  }).map(function (block) {\n    return BlockTree.generate(contentState, block, decorator);\n  }));\n}\n\n/**\n * Generate tree map objects for a new decorator object, preserving any\n * decorations that are unchanged from the previous decorator.\n *\n * Note that in order for this to perform optimally, decoration Lists for\n * decorators should be preserved when possible to allow for direct immutable\n * List comparison.\n */\nfunction regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {\n  return previousTreeMap.merge(blockMap.toSeq().filter(function (block) {\n    return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);\n  }).map(function (block) {\n    return BlockTree.generate(content, block, decorator);\n  }));\n}\n\n/**\n * Return whether a change should be considered a boundary state, given\n * the previous change type. Allows us to discard potential boundary states\n * during standard typing or deletion behavior.\n */\nfunction mustBecomeBoundary(editorState, changeType) {\n  var lastChangeType = editorState.getLastChangeType();\n  return changeType !== lastChangeType || changeType !== 'insert-characters' && changeType !== 'backspace-character' && changeType !== 'delete-character';\n}\n\nfunction getInlineStyleForCollapsedSelection(content, selection) {\n  var startKey = selection.getStartKey();\n  var startOffset = selection.getStartOffset();\n  var startBlock = content.getBlockForKey(startKey);\n\n  // If the cursor is not at the start of the block, look backward to\n  // preserve the style of the preceding character.\n  if (startOffset > 0) {\n    return startBlock.getInlineStyleAt(startOffset - 1);\n  }\n\n  // The caret is at position zero in this block. If the block has any\n  // text at all, use the style of the first character.\n  if (startBlock.getLength()) {\n    return startBlock.getInlineStyleAt(0);\n  }\n\n  // Otherwise, look upward in the document to find the closest character.\n  return lookUpwardForInlineStyle(content, startKey);\n}\n\nfunction getInlineStyleForNonCollapsedSelection(content, selection) {\n  var startKey = selection.getStartKey();\n  var startOffset = selection.getStartOffset();\n  var startBlock = content.getBlockForKey(startKey);\n\n  // If there is a character just inside the selection, use its style.\n  if (startOffset < startBlock.getLength()) {\n    return startBlock.getInlineStyleAt(startOffset);\n  }\n\n  // Check if the selection at the end of a non-empty block. Use the last\n  // style in the block.\n  if (startOffset > 0) {\n    return startBlock.getInlineStyleAt(startOffset - 1);\n  }\n\n  // Otherwise, look upward in the document to find the closest character.\n  return lookUpwardForInlineStyle(content, startKey);\n}\n\nfunction lookUpwardForInlineStyle(content, fromKey) {\n  var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function (_, k) {\n    return k === fromKey;\n  }).skip(1).skipUntil(function (block, _) {\n    return block.getLength();\n  }).first();\n\n  if (lastNonEmpty) return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);\n  return OrderedSet();\n}\n\nmodule.exports = EditorState;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$draft_js$lib$ContentState","~$module$node_modules$draft_js$lib$EditorBidiService","~$module$node_modules$object_assign$index","~$shadow.js","~$module$node_modules$draft_js$lib$SelectionState","~$module$node_modules$draft_js$lib$BlockTree","~$module$node_modules$immutable$dist$immutable"]],"~:properties",["^5",["getCurrentInlineStyle","getImmutable","getDirectionMap","allowUndo","anchorOffset","redo","getBlockTree","isBackward","createEmpty","getSelection","createWithContent","getInlineStyleOverride","isInCompositionMode","redoStack","getRedoStack","forceSelection","push","getAllowUndo","undo","getCurrentContent","getDecorator","anchorKey","mustForceSelection","undoStack","getNativelyRenderedContent","acceptSelection","focusKey","isSelectionAtStartOfContent","_immutable","setInlineStyleOverride","nativelyRenderedContent","focusOffset","inCompositionMode","directionMap","inlineStyleOverride","getLastChangeType","create","isSelectionAtEndOfContent","set","selection","treeMap","toJS","decorator","moveSelectionToEnd","currentContent","lastChangeType","getUndoStack","moveFocusToEnd"]],"~:compiled-at",1532351402133,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$EditorState.js\",\n\"lineCount\":22,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/EditorState.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$EditorState\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule EditorState\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar _assign = require('object-assign');\\n\\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar BlockTree = require('./BlockTree');\\nvar ContentState = require('./ContentState');\\nvar EditorBidiService = require('./EditorBidiService');\\nvar Immutable = require('immutable');\\nvar SelectionState = require('./SelectionState');\\n\\nvar OrderedSet = Immutable.OrderedSet,\\n    Record = Immutable.Record,\\n    Stack = Immutable.Stack;\\n\\n\\nvar defaultRecord = {\\n  allowUndo: true,\\n  currentContent: null,\\n  decorator: null,\\n  directionMap: null,\\n  forceSelection: false,\\n  inCompositionMode: false,\\n  inlineStyleOverride: null,\\n  lastChangeType: null,\\n  nativelyRenderedContent: null,\\n  redoStack: Stack(),\\n  selection: null,\\n  treeMap: null,\\n  undoStack: Stack()\\n};\\n\\nvar EditorStateRecord = Record(defaultRecord);\\n\\nvar EditorState = function () {\\n  EditorState.createEmpty = function createEmpty(decorator) {\\n    return EditorState.createWithContent(ContentState.createFromText(''), decorator);\\n  };\\n\\n  EditorState.createWithContent = function createWithContent(contentState, decorator) {\\n    var firstKey = contentState.getBlockMap().first().getKey();\\n    return EditorState.create({\\n      currentContent: contentState,\\n      undoStack: Stack(),\\n      redoStack: Stack(),\\n      decorator: decorator || null,\\n      selection: SelectionState.createEmpty(firstKey)\\n    });\\n  };\\n\\n  EditorState.create = function create(config) {\\n    var currentContent = config.currentContent,\\n        decorator = config.decorator;\\n\\n    var recordConfig = _extends({}, config, {\\n      treeMap: generateNewTreeMap(currentContent, decorator),\\n      directionMap: EditorBidiService.getDirectionMap(currentContent)\\n    });\\n    return new EditorState(new EditorStateRecord(recordConfig));\\n  };\\n\\n  EditorState.set = function set(editorState, put) {\\n    var map = editorState.getImmutable().withMutations(function (state) {\\n      var existingDecorator = state.get('decorator');\\n      var decorator = existingDecorator;\\n      if (put.decorator === null) {\\n        decorator = null;\\n      } else if (put.decorator) {\\n        decorator = put.decorator;\\n      }\\n\\n      var newContent = put.currentContent || editorState.getCurrentContent();\\n\\n      if (decorator !== existingDecorator) {\\n        var treeMap = state.get('treeMap');\\n        var newTreeMap;\\n        if (decorator && existingDecorator) {\\n          newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);\\n        } else {\\n          newTreeMap = generateNewTreeMap(newContent, decorator);\\n        }\\n\\n        state.merge({\\n          decorator: decorator,\\n          treeMap: newTreeMap,\\n          nativelyRenderedContent: null\\n        });\\n        return;\\n      }\\n\\n      var existingContent = editorState.getCurrentContent();\\n      if (newContent !== existingContent) {\\n        state.set('treeMap', regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));\\n      }\\n\\n      state.merge(put);\\n    });\\n\\n    return new EditorState(map);\\n  };\\n\\n  EditorState.prototype.toJS = function toJS() {\\n    return this.getImmutable().toJS();\\n  };\\n\\n  EditorState.prototype.getAllowUndo = function getAllowUndo() {\\n    return this.getImmutable().get('allowUndo');\\n  };\\n\\n  EditorState.prototype.getCurrentContent = function getCurrentContent() {\\n    return this.getImmutable().get('currentContent');\\n  };\\n\\n  EditorState.prototype.getUndoStack = function getUndoStack() {\\n    return this.getImmutable().get('undoStack');\\n  };\\n\\n  EditorState.prototype.getRedoStack = function getRedoStack() {\\n    return this.getImmutable().get('redoStack');\\n  };\\n\\n  EditorState.prototype.getSelection = function getSelection() {\\n    return this.getImmutable().get('selection');\\n  };\\n\\n  EditorState.prototype.getDecorator = function getDecorator() {\\n    return this.getImmutable().get('decorator');\\n  };\\n\\n  EditorState.prototype.isInCompositionMode = function isInCompositionMode() {\\n    return this.getImmutable().get('inCompositionMode');\\n  };\\n\\n  EditorState.prototype.mustForceSelection = function mustForceSelection() {\\n    return this.getImmutable().get('forceSelection');\\n  };\\n\\n  EditorState.prototype.getNativelyRenderedContent = function getNativelyRenderedContent() {\\n    return this.getImmutable().get('nativelyRenderedContent');\\n  };\\n\\n  EditorState.prototype.getLastChangeType = function getLastChangeType() {\\n    return this.getImmutable().get('lastChangeType');\\n  };\\n\\n  /**\\n   * While editing, the user may apply inline style commands with a collapsed\\n   * cursor, intending to type text that adopts the specified style. In this\\n   * case, we track the specified style as an \\\"override\\\" that takes precedence\\n   * over the inline style of the text adjacent to the cursor.\\n   *\\n   * If null, there is no override in place.\\n   */\\n\\n\\n  EditorState.prototype.getInlineStyleOverride = function getInlineStyleOverride() {\\n    return this.getImmutable().get('inlineStyleOverride');\\n  };\\n\\n  EditorState.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {\\n    return EditorState.set(editorState, { inlineStyleOverride: inlineStyleOverride });\\n  };\\n\\n  /**\\n   * Get the appropriate inline style for the editor state. If an\\n   * override is in place, use it. Otherwise, the current style is\\n   * based on the location of the selection state.\\n   */\\n\\n\\n  EditorState.prototype.getCurrentInlineStyle = function getCurrentInlineStyle() {\\n    var override = this.getInlineStyleOverride();\\n    if (override != null) {\\n      return override;\\n    }\\n\\n    var content = this.getCurrentContent();\\n    var selection = this.getSelection();\\n\\n    if (selection.isCollapsed()) {\\n      return getInlineStyleForCollapsedSelection(content, selection);\\n    }\\n\\n    return getInlineStyleForNonCollapsedSelection(content, selection);\\n  };\\n\\n  EditorState.prototype.getBlockTree = function getBlockTree(blockKey) {\\n    return this.getImmutable().getIn(['treeMap', blockKey]);\\n  };\\n\\n  EditorState.prototype.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {\\n    var firstKey = this.getCurrentContent().getBlockMap().first().getKey();\\n    return this.getSelection().hasEdgeWithin(firstKey, 0, 0);\\n  };\\n\\n  EditorState.prototype.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {\\n    var content = this.getCurrentContent();\\n    var blockMap = content.getBlockMap();\\n    var last = blockMap.last();\\n    var end = last.getLength();\\n    return this.getSelection().hasEdgeWithin(last.getKey(), end, end);\\n  };\\n\\n  EditorState.prototype.getDirectionMap = function getDirectionMap() {\\n    return this.getImmutable().get('directionMap');\\n  };\\n\\n  /**\\n   * Incorporate native DOM selection changes into the EditorState. This\\n   * method can be used when we simply want to accept whatever the DOM\\n   * has given us to represent selection, and we do not need to re-render\\n   * the editor.\\n   *\\n   * To forcibly move the DOM selection, see `EditorState.forceSelection`.\\n   */\\n\\n\\n  EditorState.acceptSelection = function acceptSelection(editorState, selection) {\\n    return updateSelection(editorState, selection, false);\\n  };\\n\\n  /**\\n   * At times, we need to force the DOM selection to be where we\\n   * need it to be. This can occur when the anchor or focus nodes\\n   * are non-text nodes, for instance. In this case, we want to trigger\\n   * a re-render of the editor, which in turn forces selection into\\n   * the correct place in the DOM. The `forceSelection` method\\n   * accomplishes this.\\n   *\\n   * This method should be used in cases where you need to explicitly\\n   * move the DOM selection from one place to another without a change\\n   * in ContentState.\\n   */\\n\\n\\n  EditorState.forceSelection = function forceSelection(editorState, selection) {\\n    if (!selection.getHasFocus()) {\\n      selection = selection.set('hasFocus', true);\\n    }\\n    return updateSelection(editorState, selection, true);\\n  };\\n\\n  /**\\n   * Move selection to the end of the editor without forcing focus.\\n   */\\n\\n\\n  EditorState.moveSelectionToEnd = function moveSelectionToEnd(editorState) {\\n    var content = editorState.getCurrentContent();\\n    var lastBlock = content.getLastBlock();\\n    var lastKey = lastBlock.getKey();\\n    var length = lastBlock.getLength();\\n\\n    return EditorState.acceptSelection(editorState, new SelectionState({\\n      anchorKey: lastKey,\\n      anchorOffset: length,\\n      focusKey: lastKey,\\n      focusOffset: length,\\n      isBackward: false\\n    }));\\n  };\\n\\n  /**\\n   * Force focus to the end of the editor. This is useful in scenarios\\n   * where we want to programmatically focus the input and it makes sense\\n   * to allow the user to continue working seamlessly.\\n   */\\n\\n\\n  EditorState.moveFocusToEnd = function moveFocusToEnd(editorState) {\\n    var afterSelectionMove = EditorState.moveSelectionToEnd(editorState);\\n    return EditorState.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());\\n  };\\n\\n  /**\\n   * Push the current ContentState onto the undo stack if it should be\\n   * considered a boundary state, and set the provided ContentState as the\\n   * new current content.\\n   */\\n\\n\\n  EditorState.push = function push(editorState, contentState, changeType) {\\n    if (editorState.getCurrentContent() === contentState) {\\n      return editorState;\\n    }\\n\\n    var forceSelection = changeType !== 'insert-characters';\\n    var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());\\n\\n    if (!editorState.getAllowUndo()) {\\n      return EditorState.set(editorState, {\\n        currentContent: contentState,\\n        directionMap: directionMap,\\n        lastChangeType: changeType,\\n        selection: contentState.getSelectionAfter(),\\n        forceSelection: forceSelection,\\n        inlineStyleOverride: null\\n      });\\n    }\\n\\n    var selection = editorState.getSelection();\\n    var currentContent = editorState.getCurrentContent();\\n    var undoStack = editorState.getUndoStack();\\n    var newContent = contentState;\\n\\n    if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {\\n      undoStack = undoStack.push(currentContent);\\n      newContent = newContent.set('selectionBefore', selection);\\n    } else if (changeType === 'insert-characters' || changeType === 'backspace-character' || changeType === 'delete-character') {\\n      // Preserve the previous selection.\\n      newContent = newContent.set('selectionBefore', currentContent.getSelectionBefore());\\n    }\\n\\n    var inlineStyleOverride = editorState.getInlineStyleOverride();\\n\\n    // Don't discard inline style overrides for the following change types:\\n    var overrideChangeTypes = ['adjust-depth', 'change-block-type', 'split-block'];\\n\\n    if (overrideChangeTypes.indexOf(changeType) === -1) {\\n      inlineStyleOverride = null;\\n    }\\n\\n    var editorStateChanges = {\\n      currentContent: newContent,\\n      directionMap: directionMap,\\n      undoStack: undoStack,\\n      redoStack: Stack(),\\n      lastChangeType: changeType,\\n      selection: contentState.getSelectionAfter(),\\n      forceSelection: forceSelection,\\n      inlineStyleOverride: inlineStyleOverride\\n    };\\n\\n    return EditorState.set(editorState, editorStateChanges);\\n  };\\n\\n  /**\\n   * Make the top ContentState in the undo stack the new current content and\\n   * push the current content onto the redo stack.\\n   */\\n\\n\\n  EditorState.undo = function undo(editorState) {\\n    if (!editorState.getAllowUndo()) {\\n      return editorState;\\n    }\\n\\n    var undoStack = editorState.getUndoStack();\\n    var newCurrentContent = undoStack.peek();\\n    if (!newCurrentContent) {\\n      return editorState;\\n    }\\n\\n    var currentContent = editorState.getCurrentContent();\\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\\n\\n    return EditorState.set(editorState, {\\n      currentContent: newCurrentContent,\\n      directionMap: directionMap,\\n      undoStack: undoStack.shift(),\\n      redoStack: editorState.getRedoStack().push(currentContent),\\n      forceSelection: true,\\n      inlineStyleOverride: null,\\n      lastChangeType: 'undo',\\n      nativelyRenderedContent: null,\\n      selection: currentContent.getSelectionBefore()\\n    });\\n  };\\n\\n  /**\\n   * Make the top ContentState in the redo stack the new current content and\\n   * push the current content onto the undo stack.\\n   */\\n\\n\\n  EditorState.redo = function redo(editorState) {\\n    if (!editorState.getAllowUndo()) {\\n      return editorState;\\n    }\\n\\n    var redoStack = editorState.getRedoStack();\\n    var newCurrentContent = redoStack.peek();\\n    if (!newCurrentContent) {\\n      return editorState;\\n    }\\n\\n    var currentContent = editorState.getCurrentContent();\\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\\n\\n    return EditorState.set(editorState, {\\n      currentContent: newCurrentContent,\\n      directionMap: directionMap,\\n      undoStack: editorState.getUndoStack().push(currentContent),\\n      redoStack: redoStack.shift(),\\n      forceSelection: true,\\n      inlineStyleOverride: null,\\n      lastChangeType: 'redo',\\n      nativelyRenderedContent: null,\\n      selection: newCurrentContent.getSelectionAfter()\\n    });\\n  };\\n\\n  /**\\n   * Not for public consumption.\\n   */\\n\\n\\n  function EditorState(immutable) {\\n    _classCallCheck(this, EditorState);\\n\\n    this._immutable = immutable;\\n  }\\n\\n  /**\\n   * Not for public consumption.\\n   */\\n\\n\\n  EditorState.prototype.getImmutable = function getImmutable() {\\n    return this._immutable;\\n  };\\n\\n  return EditorState;\\n}();\\n\\n/**\\n * Set the supplied SelectionState as the new current selection, and set\\n * the `force` flag to trigger manual selection placement by the view.\\n */\\n\\n\\nfunction updateSelection(editorState, selection, forceSelection) {\\n  return EditorState.set(editorState, {\\n    selection: selection,\\n    forceSelection: forceSelection,\\n    nativelyRenderedContent: null,\\n    inlineStyleOverride: null\\n  });\\n}\\n\\n/**\\n * Regenerate the entire tree map for a given ContentState and decorator.\\n * Returns an OrderedMap that maps all available ContentBlock objects.\\n */\\nfunction generateNewTreeMap(contentState, decorator) {\\n  return contentState.getBlockMap().map(function (block) {\\n    return BlockTree.generate(contentState, block, decorator);\\n  }).toOrderedMap();\\n}\\n\\n/**\\n * Regenerate tree map objects for all ContentBlocks that have changed\\n * between the current editorState and newContent. Returns an OrderedMap\\n * with only changed regenerated tree map objects.\\n */\\nfunction regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {\\n  var contentState = editorState.getCurrentContent().set('entityMap', newEntityMap);\\n  var prevBlockMap = contentState.getBlockMap();\\n  var prevTreeMap = editorState.getImmutable().get('treeMap');\\n  return prevTreeMap.merge(newBlockMap.toSeq().filter(function (block, key) {\\n    return block !== prevBlockMap.get(key);\\n  }).map(function (block) {\\n    return BlockTree.generate(contentState, block, decorator);\\n  }));\\n}\\n\\n/**\\n * Generate tree map objects for a new decorator object, preserving any\\n * decorations that are unchanged from the previous decorator.\\n *\\n * Note that in order for this to perform optimally, decoration Lists for\\n * decorators should be preserved when possible to allow for direct immutable\\n * List comparison.\\n */\\nfunction regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {\\n  return previousTreeMap.merge(blockMap.toSeq().filter(function (block) {\\n    return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);\\n  }).map(function (block) {\\n    return BlockTree.generate(content, block, decorator);\\n  }));\\n}\\n\\n/**\\n * Return whether a change should be considered a boundary state, given\\n * the previous change type. Allows us to discard potential boundary states\\n * during standard typing or deletion behavior.\\n */\\nfunction mustBecomeBoundary(editorState, changeType) {\\n  var lastChangeType = editorState.getLastChangeType();\\n  return changeType !== lastChangeType || changeType !== 'insert-characters' && changeType !== 'backspace-character' && changeType !== 'delete-character';\\n}\\n\\nfunction getInlineStyleForCollapsedSelection(content, selection) {\\n  var startKey = selection.getStartKey();\\n  var startOffset = selection.getStartOffset();\\n  var startBlock = content.getBlockForKey(startKey);\\n\\n  // If the cursor is not at the start of the block, look backward to\\n  // preserve the style of the preceding character.\\n  if (startOffset > 0) {\\n    return startBlock.getInlineStyleAt(startOffset - 1);\\n  }\\n\\n  // The caret is at position zero in this block. If the block has any\\n  // text at all, use the style of the first character.\\n  if (startBlock.getLength()) {\\n    return startBlock.getInlineStyleAt(0);\\n  }\\n\\n  // Otherwise, look upward in the document to find the closest character.\\n  return lookUpwardForInlineStyle(content, startKey);\\n}\\n\\nfunction getInlineStyleForNonCollapsedSelection(content, selection) {\\n  var startKey = selection.getStartKey();\\n  var startOffset = selection.getStartOffset();\\n  var startBlock = content.getBlockForKey(startKey);\\n\\n  // If there is a character just inside the selection, use its style.\\n  if (startOffset < startBlock.getLength()) {\\n    return startBlock.getInlineStyleAt(startOffset);\\n  }\\n\\n  // Check if the selection at the end of a non-empty block. Use the last\\n  // style in the block.\\n  if (startOffset > 0) {\\n    return startBlock.getInlineStyleAt(startOffset - 1);\\n  }\\n\\n  // Otherwise, look upward in the document to find the closest character.\\n  return lookUpwardForInlineStyle(content, startKey);\\n}\\n\\nfunction lookUpwardForInlineStyle(content, fromKey) {\\n  var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function (_, k) {\\n    return k === fromKey;\\n  }).skip(1).skipUntil(function (block, _) {\\n    return block.getLength();\\n  }).first();\\n\\n  if (lastNonEmpty) return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);\\n  return OrderedSet();\\n}\\n\\nmodule.exports = EditorState;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"updateSelection\",\"editorState\",\"selection\",\"forceSelection\",\"EditorState\",\"set\",\"nativelyRenderedContent\",\"inlineStyleOverride\",\"generateNewTreeMap\",\"contentState\",\"decorator\",\"getBlockMap\",\"map\",\"block\",\"BlockTree\",\"generate\",\"toOrderedMap\",\"regenerateTreeForNewBlocks\",\"newBlockMap\",\"newEntityMap\",\"getCurrentContent\",\"prevBlockMap\",\"getImmutable\",\"get\",\"prevTreeMap\",\"merge\",\"toSeq\",\"filter\",\"key\",\"regenerateTreeForNewDecorator\",\"content\",\"blockMap\",\"previousTreeMap\",\"existingDecorator\",\"getDecorations\",\"lookUpwardForInlineStyle\",\"fromKey\",\"lastNonEmpty\",\"reverse\",\"skipUntil\",\"_\",\"k\",\"skip\",\"getLength\",\"first\",\"getInlineStyleAt\",\"OrderedSet\",\"_extends\",\"_assign\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"ContentState\",\"EditorBidiService\",\"Immutable\",\"SelectionState\",\"Record\",\"Stack\",\"defaultRecord\",\"allowUndo\",\"currentContent\",\"directionMap\",\"inCompositionMode\",\"lastChangeType\",\"redoStack\",\"treeMap\",\"undoStack\",\"EditorStateRecord\",\"immutable\",\"instance\",\"TypeError\",\"_immutable\",\"createEmpty\",\"EditorState.createEmpty\",\"createWithContent\",\"createFromText\",\"EditorState.createWithContent\",\"firstKey\",\"getKey\",\"create\",\"EditorState.create\",\"config\",\"recordConfig\",\"getDirectionMap\",\"EditorState.set\",\"put\",\"withMutations\",\"state\",\"newContent\",\"newTreeMap\",\"existingContent\",\"getEntityMap\",\"toJS\",\"EditorState.prototype.toJS\",\"getAllowUndo\",\"EditorState.prototype.getAllowUndo\",\"EditorState.prototype.getCurrentContent\",\"getUndoStack\",\"EditorState.prototype.getUndoStack\",\"getRedoStack\",\"EditorState.prototype.getRedoStack\",\"getSelection\",\"EditorState.prototype.getSelection\",\"getDecorator\",\"EditorState.prototype.getDecorator\",\"isInCompositionMode\",\"EditorState.prototype.isInCompositionMode\",\"mustForceSelection\",\"EditorState.prototype.mustForceSelection\",\"getNativelyRenderedContent\",\"EditorState.prototype.getNativelyRenderedContent\",\"getLastChangeType\",\"EditorState.prototype.getLastChangeType\",\"getInlineStyleOverride\",\"EditorState.prototype.getInlineStyleOverride\",\"setInlineStyleOverride\",\"EditorState.setInlineStyleOverride\",\"getCurrentInlineStyle\",\"EditorState.prototype.getCurrentInlineStyle\",\"override\",\"isCollapsed\",\"startKey\",\"getStartKey\",\"startOffset\",\"getStartOffset\",\"startBlock\",\"getBlockForKey\",\"getBlockTree\",\"EditorState.prototype.getBlockTree\",\"blockKey\",\"getIn\",\"isSelectionAtStartOfContent\",\"EditorState.prototype.isSelectionAtStartOfContent\",\"hasEdgeWithin\",\"isSelectionAtEndOfContent\",\"EditorState.prototype.isSelectionAtEndOfContent\",\"last\",\"end\",\"EditorState.prototype.getDirectionMap\",\"acceptSelection\",\"EditorState.acceptSelection\",\"EditorState.forceSelection\",\"getHasFocus\",\"moveSelectionToEnd\",\"EditorState.moveSelectionToEnd\",\"lastBlock\",\"getLastBlock\",\"lastKey\",\"anchorKey\",\"anchorOffset\",\"focusKey\",\"focusOffset\",\"isBackward\",\"moveFocusToEnd\",\"EditorState.moveFocusToEnd\",\"afterSelectionMove\",\"push\",\"EditorState.push\",\"changeType\",\"getSelectionAfter\",\"getSelectionBefore\",\"overrideChangeTypes\",\"indexOf\",\"editorStateChanges\",\"undo\",\"EditorState.undo\",\"newCurrentContent\",\"peek\",\"shift\",\"redo\",\"EditorState.redo\",\"EditorState.prototype.getImmutable\"]\n}\n"]