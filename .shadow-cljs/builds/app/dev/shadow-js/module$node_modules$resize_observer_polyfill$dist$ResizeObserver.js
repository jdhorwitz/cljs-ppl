["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/resize-observer-polyfill/dist/ResizeObserver.js"],"~:js","shadow$provide.module$node_modules$resize_observer_polyfill$dist$ResizeObserver=function(global$jscomp$0,process,require,module,exports,shadow$shims){(function(global,factory){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=factory():\"function\"===typeof define&&define.amd?define(factory):global.ResizeObserver=factory()})(this,function(){function getBordersSize(styles){for(var positions=[],len=arguments.length-1;0<len--;)positions[len]=arguments[len+1];return positions.reduce(function(size,\nposition){return size+(parseFloat(styles[\"border-\"+position+\"-width\"])||0)},0)}var MapShim=function(){function getIndex(arr,key){var result=-1;arr.some(function(entry,index){return entry[0]===key?(result=index,!0):!1});return result}return\"undefined\"!==typeof Map?Map:function(){function anonymous(){this.__entries__=[]}var prototypeAccessors={size:{configurable:!0}};prototypeAccessors.size.get=function(){return this.__entries__.length};anonymous.prototype.get=function(key){key=getIndex(this.__entries__,\nkey);return(key=this.__entries__[key])&&key[1]};anonymous.prototype.set=function(key,value){var index=getIndex(this.__entries__,key);~index?this.__entries__[index][1]=value:this.__entries__.push([key,value])};anonymous.prototype.delete=function(key){var entries=this.__entries__;key=getIndex(entries,key);~key&&entries.splice(key,1)};anonymous.prototype.has=function(key){return!!~getIndex(this.__entries__,key)};anonymous.prototype.clear=function(){this.__entries__.splice(0)};anonymous.prototype.forEach=\nfunction(callback,ctx){void 0===ctx&&(ctx=null);for(var i=0,list=this.__entries__;i<list.length;i+=1){var entry=list[i];callback.call(ctx,entry[1],entry[0])}};Object.defineProperties(anonymous.prototype,prototypeAccessors);return anonymous}()}(),isBrowser=\"undefined\"!==typeof window&&\"undefined\"!==typeof document&&window.document===document,global$1=\"undefined\"!==typeof global$jscomp$0&&global$jscomp$0.Math===Math?global$jscomp$0:\"undefined\"!==typeof self&&self.Math===Math?self:\"undefined\"!==typeof window&&\nMath===Math?window:Function(\"return this\")(),requestAnimationFrame$1=function(){return\"function\"===typeof requestAnimationFrame?requestAnimationFrame.bind(global$1):function(callback){return setTimeout(function(){return callback(Date.now())},1E3/60)}}(),throttle=function(callback,delay){function resolvePending(){leadingCall&&(leadingCall=!1,callback());trailingCall&&proxy()}function timeoutCallback(){requestAnimationFrame$1(resolvePending)}function proxy(){var timeStamp=Date.now();if(leadingCall){if(2>\ntimeStamp-lastCallTime)return;trailingCall=!0}else leadingCall=!0,trailingCall=!1,setTimeout(timeoutCallback,delay);lastCallTime=timeStamp}var leadingCall=!1,trailingCall=!1,lastCallTime=0;return proxy},transitionKeys=\"top right bottom left width height size weight\".split(\" \"),mutationObserverSupported=\"undefined\"!==typeof MutationObserver,ResizeObserverController=function(){this.mutationEventsAdded_=this.connected_=!1;this.mutationsObserver_=null;this.observers_=[];this.onTransitionEnd_=this.onTransitionEnd_.bind(this);\nthis.refresh=throttle(this.refresh.bind(this),20)};ResizeObserverController.prototype.addObserver=function(observer){~this.observers_.indexOf(observer)||this.observers_.push(observer);this.connected_||this.connect_()};ResizeObserverController.prototype.removeObserver=function(observer){var observers=this.observers_;observer=observers.indexOf(observer);~observer&&observers.splice(observer,1);!observers.length&&this.connected_&&this.disconnect_()};ResizeObserverController.prototype.refresh=function(){this.updateObservers_()&&\nthis.refresh()};ResizeObserverController.prototype.updateObservers_=function(){var activeObservers=this.observers_.filter(function(observer){return observer.gatherActive(),observer.hasActive()});activeObservers.forEach(function(observer){return observer.broadcastActive()});return 0<activeObservers.length};ResizeObserverController.prototype.connect_=function(){isBrowser&&!this.connected_&&(document.addEventListener(\"transitionend\",this.onTransitionEnd_),window.addEventListener(\"resize\",this.refresh),\nmutationObserverSupported?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener(\"DOMSubtreeModified\",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)};ResizeObserverController.prototype.disconnect_=function(){isBrowser&&this.connected_&&(document.removeEventListener(\"transitionend\",this.onTransitionEnd_),window.removeEventListener(\"resize\",this.refresh),\nthis.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener(\"DOMSubtreeModified\",this.refresh),this.mutationsObserver_=null,this.connected_=this.mutationEventsAdded_=!1)};ResizeObserverController.prototype.onTransitionEnd_=function(ref){var propertyName=ref.propertyName;void 0===propertyName&&(propertyName=\"\");transitionKeys.some(function(key){return!!~propertyName.indexOf(key)})&&this.refresh()};ResizeObserverController.getInstance=function(){this.instance_||\n(this.instance_=new ResizeObserverController);return this.instance_};ResizeObserverController.instance_=null;var defineConfigurable=function(target,props){for(var i=0,list=Object.keys(props);i<list.length;i+=1){var key=list[i];Object.defineProperty(target,key,{value:props[key],enumerable:!1,writable:!1,configurable:!0})}return target},getWindowOf=function(target){return target&&target.ownerDocument&&target.ownerDocument.defaultView||global$1},emptyRect={x:0,y:0,width:0,height:0},isSVGGraphicsElement=\nfunction(){return\"undefined\"!==typeof SVGGraphicsElement?function(target){return target instanceof getWindowOf(target).SVGGraphicsElement}:function(target){return target instanceof getWindowOf(target).SVGElement&&\"function\"===typeof target.getBBox}}(),ResizeObservation=function(target){this.broadcastHeight=this.broadcastWidth=0;this.contentRect_={x:0,y:0,width:0,height:0};this.target=target};ResizeObservation.prototype.isActive=function(){var target=this.target;if(isBrowser)if(isSVGGraphicsElement(target)){var rect=\ntarget.getBBox();rect={x:0,y:0,width:rect.width,height:rect.height}}else{var clientWidth=target.clientWidth,clientHeight=target.clientHeight;if(clientWidth||clientHeight){var styles=getWindowOf(target).getComputedStyle(target);rect={};for(var i=0,list=[\"top\",\"right\",\"bottom\",\"left\"];i<list.length;i+=1){var position=list[i];rect[position]=parseFloat(styles[\"padding-\"+position])||0}var horizPad=rect.left+rect.right;position=rect.top+rect.bottom;i=parseFloat(styles.width)||0;list=parseFloat(styles.height)||\n0;\"border-box\"===styles.boxSizing&&(Math.round(i+horizPad)!==clientWidth&&(i-=getBordersSize(styles,\"left\",\"right\")+horizPad),Math.round(list+position)!==clientHeight&&(list-=getBordersSize(styles,\"top\",\"bottom\")+position));target!==getWindowOf(target).document.documentElement&&(target=Math.round(i+horizPad)-clientWidth,clientHeight=Math.round(list+position)-clientHeight,1!==Math.abs(target)&&(i-=target),1!==Math.abs(clientHeight)&&(list-=clientHeight));rect={x:rect.left,y:rect.top,width:i,height:list}}else rect=\nemptyRect}else rect=emptyRect;this.contentRect_=rect;return rect.width!==this.broadcastWidth||rect.height!==this.broadcastHeight};ResizeObservation.prototype.broadcastRect=function(){var rect=this.contentRect_;this.broadcastWidth=rect.width;this.broadcastHeight=rect.height;return rect};var ResizeObserverEntry=function(target,rectInit){var x=rectInit.x,y=rectInit.y,width=rectInit.width;rectInit=rectInit.height;var rect=Object.create((\"undefined\"!==typeof DOMRectReadOnly?DOMRectReadOnly:Object).prototype);\ndefineConfigurable(rect,{x:x,y:y,width:width,height:rectInit,top:y,right:x+width,bottom:rectInit+y,left:x});defineConfigurable(this,{target:target,contentRect:rect})},ResizeObserverSPI=function(callback,controller,callbackCtx){this.activeObservations_=[];this.observations_=new MapShim;if(\"function\"!==typeof callback)throw new TypeError(\"The callback provided as parameter 1 is not a function.\");this.callback_=callback;this.controller_=controller;this.callbackCtx_=callbackCtx};ResizeObserverSPI.prototype.observe=\nfunction(target){if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");if(\"undefined\"!==typeof Element&&Element instanceof Object){if(!(target instanceof getWindowOf(target).Element))throw new TypeError('parameter 1 is not of type \"Element\".');var observations=this.observations_;observations.has(target)||(observations.set(target,new ResizeObservation(target)),this.controller_.addObserver(this),this.controller_.refresh())}};ResizeObserverSPI.prototype.unobserve=function(target){if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");\nif(\"undefined\"!==typeof Element&&Element instanceof Object){if(!(target instanceof getWindowOf(target).Element))throw new TypeError('parameter 1 is not of type \"Element\".');var observations=this.observations_;observations.has(target)&&(observations.delete(target),observations.size||this.controller_.removeObserver(this))}};ResizeObserverSPI.prototype.disconnect=function(){this.clearActive();this.observations_.clear();this.controller_.removeObserver(this)};ResizeObserverSPI.prototype.gatherActive=function(){var this$1=\nthis;this.clearActive();this.observations_.forEach(function(observation){observation.isActive()&&this$1.activeObservations_.push(observation)})};ResizeObserverSPI.prototype.broadcastActive=function(){if(this.hasActive()){var ctx=this.callbackCtx_,entries=this.activeObservations_.map(function(observation){return new ResizeObserverEntry(observation.target,observation.broadcastRect())});this.callback_.call(ctx,entries,ctx);this.clearActive()}};ResizeObserverSPI.prototype.clearActive=function(){this.activeObservations_.splice(0)};\nResizeObserverSPI.prototype.hasActive=function(){return 0<this.activeObservations_.length};var observers=\"undefined\"!==typeof WeakMap?new WeakMap:new MapShim,ResizeObserver=function(callback){if(!(this instanceof ResizeObserver))throw new TypeError(\"Cannot call a class as a function.\");if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");var controller=ResizeObserverController.getInstance();controller=new ResizeObserverSPI(callback,controller,this);observers.set(this,\ncontroller)};[\"observe\",\"unobserve\",\"disconnect\"].forEach(function(method){ResizeObserver.prototype[method]=function(){return(ref=observers.get(this))[method].apply(ref,arguments);var ref}});var index$jscomp$0=\"undefined\"!==typeof global$1.ResizeObserver?global$1.ResizeObserver:ResizeObserver;return index$jscomp$0})}","~:source","shadow$provide[\"module$node_modules$resize_observer_polyfill$dist$ResizeObserver\"] = function(global,process,require,module,exports,shadow$shims) {\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ResizeObserver = factory());\n}(this, (function () { 'use strict';\n\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = (function () {\n    if (typeof Map !== 'undefined') {\n        return Map;\n    }\n\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\n    function getIndex(arr, key) {\n        var result = -1;\n\n        arr.some(function (entry, index) {\n            if (entry[0] === key) {\n                result = index;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    return (function () {\n        function anonymous() {\n            this.__entries__ = [];\n        }\n\n        var prototypeAccessors = { size: { configurable: true } };\n\n        /**\r\n         * @returns {boolean}\r\n         */\n        prototypeAccessors.size.get = function () {\n            return this.__entries__.length;\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\n        anonymous.prototype.get = function (key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n\n            return entry && entry[1];\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.set = function (key, value) {\n            var index = getIndex(this.__entries__, key);\n\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([key, value]);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.delete = function (key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.has = function (key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n\n        /**\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.clear = function () {\n            this.__entries__.splice(0);\n        };\n\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.forEach = function (callback, ctx) {\n            var this$1 = this;\n            if ( ctx === void 0 ) ctx = null;\n\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\n                var entry = list[i];\n\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\n\n        return anonymous;\n    }());\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = (function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n        return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n        return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n        return window;\n    }\n\n    // eslint-disable-next-line no-new-func\n    return Function('return this')();\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = (function () {\n    if (typeof requestAnimationFrame === 'function') {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n})();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nvar throttle = function (callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\n    function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n\n            callback();\n        }\n\n        if (trailingCall) {\n            proxy();\n        }\n    }\n\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\n    function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\n    function proxy() {\n        var timeStamp = Date.now();\n\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n\n            setTimeout(timeoutCallback, delay);\n        }\n\n        lastCallTime = timeStamp;\n    }\n\n    return proxy;\n};\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = function() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n};\n\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\n\n\n/**\r\n * Keeps reference to the instance of MutationObserver.\r\n *\r\n * @private {MutationObserver}\r\n */\n\n/**\r\n * Indicates whether DOM listeners have been added.\r\n *\r\n * @private {boolean}\r\n */\nResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n    }\n\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n        this.connect_();\n    }\n};\n\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n\n    // Remove observer if it's present in registry.\n    if (~index) {\n        observers.splice(index, 1);\n    }\n\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n        this.disconnect_();\n    }\n};\n\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\nResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n    });\n\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n\n    return activeObservers.length > 0;\n};\n\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n        return;\n    }\n\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n\n        this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n    } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n\n        this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n};\n\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n        return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n};\n\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\n\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\nResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n};\n\nResizeObserverController.instance_ = null;\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = (function (target, props) {\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\n        var key = list[i];\n\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n\n    return target;\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = (function (target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n});\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n    var positions = [], len = arguments.length - 1;\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\n\n    return positions.reduce(function (size, position) {\n        var value = styles['border-' + position + '-width'];\n\n        return size + toFloat(value);\n    }, 0);\n}\n\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var i = 0, list = positions; i < list.length; i += 1) {\n        var position = list[i];\n\n        var value = styles['padding-' + position];\n\n        paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n}\n\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n    var bbox = target.getBBox();\n\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth;\n    var clientHeight = target.clientHeight;\n\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height);\n\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === 'border-box') {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n        }\n\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n        }\n    }\n\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = (function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n    }\n\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\n})();\n\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n}\n\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var width = ref.width;\n    var height = ref.height;\n\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x, y: y, width: width, height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n\n    return rect;\n}\n\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n    return { x: x, y: y, width: width, height: height };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = function(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n\n    this.target = target;\n};\n\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\n\n\n/**\r\n * Reference to the last observed content rectangle.\r\n *\r\n * @private {DOMRectInit}\r\n */\n\n\n/**\r\n * Broadcasted width of content rectangle.\r\n *\r\n * @type {number}\r\n */\nResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n\n    this.contentRect_ = rect;\n\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n};\n\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\nResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n\n    return rect;\n};\n\nvar ResizeObserverEntry = function(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, { target: target, contentRect: contentRect });\n};\n\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n};\n\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Registry of the ResizeObservation instances.\r\n *\r\n * @private {Map<Element, ResizeObservation>}\r\n */\n\n\n/**\r\n * Public ResizeObserver instance which will be passed to the callback\r\n * function and used as a value of it's \"this\" binding.\r\n *\r\n * @private {ResizeObserver}\r\n */\n\n/**\r\n * Collection of resize observations that have detected changes in dimensions\r\n * of elements.\r\n *\r\n * @private {Array<ResizeObservation>}\r\n */\nResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n        return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n\n    this.controller_.addObserver(this);\n\n    // Force the update of observations.\n    this.controller_.refresh();\n};\n\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n        return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n        this.controller_.removeObserver(this);\n    }\n};\n\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n};\n\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.gatherActive = function () {\n        var this$1 = this;\n\n    this.clearActive();\n\n    this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n            this$1.activeObservations_.push(observation);\n        }\n    });\n};\n\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n        return;\n    }\n\n    var ctx = this.callbackCtx_;\n\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n};\n\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n};\n\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\nResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n};\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = function(callback) {\n    if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n\n    observers.set(this, observer);\n};\n\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n        return (ref = observers.get(this))[method].apply(ref, arguments);\n        var ref;\n    };\n});\n\nvar index = (function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n        return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n})();\n\nreturn index;\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["clearActive","isActive","width","observe","right","forEach","top","removeObserver","childList","broadcastHeight","contentRect","height","contentRect_","delete","mutationEventsAdded_","callback_","disconnect","addObserver","hasActive","x","connected_","controller_","activeObservations_","observers_","unobserve","mutationsObserver_","refresh","disconnect_","configurable","value","characterData","enumerable","getInstance","broadcastRect","writable","observations_","onTransitionEnd_","ResizeObserver","attributes","y","__entries__","target","connect_","bottom","set","broadcastActive","size","has","clear","updateObservers_","instance_","get","subtree","broadcastWidth","left","callbackCtx_","gatherActive"]],"~:compiled-at",1532351401926,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$resize_observer_polyfill$dist$ResizeObserver.js\",\n\"lineCount\":21,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/resize-observer-polyfill/dist/ResizeObserver.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$resize_observer_polyfill$dist$ResizeObserver\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n(function (global, factory) {\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n\\ttypeof define === 'function' && define.amd ? define(factory) :\\n\\t(global.ResizeObserver = factory());\\n}(this, (function () { 'use strict';\\n\\n/**\\r\\n * A collection of shims that provide minimal functionality of the ES6 collections.\\r\\n *\\r\\n * These implementations are not meant to be used outside of the ResizeObserver\\r\\n * modules as they cover only a limited range of use cases.\\r\\n */\\n/* eslint-disable require-jsdoc, valid-jsdoc */\\nvar MapShim = (function () {\\n    if (typeof Map !== 'undefined') {\\n        return Map;\\n    }\\n\\n    /**\\r\\n     * Returns index in provided array that matches the specified key.\\r\\n     *\\r\\n     * @param {Array<Array>} arr\\r\\n     * @param {*} key\\r\\n     * @returns {number}\\r\\n     */\\n    function getIndex(arr, key) {\\n        var result = -1;\\n\\n        arr.some(function (entry, index) {\\n            if (entry[0] === key) {\\n                result = index;\\n\\n                return true;\\n            }\\n\\n            return false;\\n        });\\n\\n        return result;\\n    }\\n\\n    return (function () {\\n        function anonymous() {\\n            this.__entries__ = [];\\n        }\\n\\n        var prototypeAccessors = { size: { configurable: true } };\\n\\n        /**\\r\\n         * @returns {boolean}\\r\\n         */\\n        prototypeAccessors.size.get = function () {\\n            return this.__entries__.length;\\n        };\\n\\n        /**\\r\\n         * @param {*} key\\r\\n         * @returns {*}\\r\\n         */\\n        anonymous.prototype.get = function (key) {\\n            var index = getIndex(this.__entries__, key);\\n            var entry = this.__entries__[index];\\n\\n            return entry && entry[1];\\n        };\\n\\n        /**\\r\\n         * @param {*} key\\r\\n         * @param {*} value\\r\\n         * @returns {void}\\r\\n         */\\n        anonymous.prototype.set = function (key, value) {\\n            var index = getIndex(this.__entries__, key);\\n\\n            if (~index) {\\n                this.__entries__[index][1] = value;\\n            } else {\\n                this.__entries__.push([key, value]);\\n            }\\n        };\\n\\n        /**\\r\\n         * @param {*} key\\r\\n         * @returns {void}\\r\\n         */\\n        anonymous.prototype.delete = function (key) {\\n            var entries = this.__entries__;\\n            var index = getIndex(entries, key);\\n\\n            if (~index) {\\n                entries.splice(index, 1);\\n            }\\n        };\\n\\n        /**\\r\\n         * @param {*} key\\r\\n         * @returns {void}\\r\\n         */\\n        anonymous.prototype.has = function (key) {\\n            return !!~getIndex(this.__entries__, key);\\n        };\\n\\n        /**\\r\\n         * @returns {void}\\r\\n         */\\n        anonymous.prototype.clear = function () {\\n            this.__entries__.splice(0);\\n        };\\n\\n        /**\\r\\n         * @param {Function} callback\\r\\n         * @param {*} [ctx=null]\\r\\n         * @returns {void}\\r\\n         */\\n        anonymous.prototype.forEach = function (callback, ctx) {\\n            var this$1 = this;\\n            if ( ctx === void 0 ) ctx = null;\\n\\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\\n                var entry = list[i];\\n\\n                callback.call(ctx, entry[1], entry[0]);\\n            }\\n        };\\n\\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\\n\\n        return anonymous;\\n    }());\\n})();\\n\\n/**\\r\\n * Detects whether window and document objects are available in current environment.\\r\\n */\\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\\n\\n// Returns global object of a current environment.\\nvar global$1 = (function () {\\n    if (typeof global !== 'undefined' && global.Math === Math) {\\n        return global;\\n    }\\n\\n    if (typeof self !== 'undefined' && self.Math === Math) {\\n        return self;\\n    }\\n\\n    if (typeof window !== 'undefined' && window.Math === Math) {\\n        return window;\\n    }\\n\\n    // eslint-disable-next-line no-new-func\\n    return Function('return this')();\\n})();\\n\\n/**\\r\\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\\r\\n * first one is not supported.\\r\\n *\\r\\n * @returns {number} Requests' identifier.\\r\\n */\\nvar requestAnimationFrame$1 = (function () {\\n    if (typeof requestAnimationFrame === 'function') {\\n        // It's required to use a bounded function because IE sometimes throws\\n        // an \\\"Invalid calling object\\\" error if rAF is invoked without the global\\n        // object on the left hand side.\\n        return requestAnimationFrame.bind(global$1);\\n    }\\n\\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\\n})();\\n\\n// Defines minimum timeout before adding a trailing call.\\nvar trailingTimeout = 2;\\n\\n/**\\r\\n * Creates a wrapper function which ensures that provided callback will be\\r\\n * invoked only once during the specified delay period.\\r\\n *\\r\\n * @param {Function} callback - Function to be invoked after the delay period.\\r\\n * @param {number} delay - Delay after which to invoke callback.\\r\\n * @returns {Function}\\r\\n */\\nvar throttle = function (callback, delay) {\\n    var leadingCall = false,\\n        trailingCall = false,\\n        lastCallTime = 0;\\n\\n    /**\\r\\n     * Invokes the original callback function and schedules new invocation if\\r\\n     * the \\\"proxy\\\" was called during current request.\\r\\n     *\\r\\n     * @returns {void}\\r\\n     */\\n    function resolvePending() {\\n        if (leadingCall) {\\n            leadingCall = false;\\n\\n            callback();\\n        }\\n\\n        if (trailingCall) {\\n            proxy();\\n        }\\n    }\\n\\n    /**\\r\\n     * Callback invoked after the specified delay. It will further postpone\\r\\n     * invocation of the original function delegating it to the\\r\\n     * requestAnimationFrame.\\r\\n     *\\r\\n     * @returns {void}\\r\\n     */\\n    function timeoutCallback() {\\n        requestAnimationFrame$1(resolvePending);\\n    }\\n\\n    /**\\r\\n     * Schedules invocation of the original function.\\r\\n     *\\r\\n     * @returns {void}\\r\\n     */\\n    function proxy() {\\n        var timeStamp = Date.now();\\n\\n        if (leadingCall) {\\n            // Reject immediately following calls.\\n            if (timeStamp - lastCallTime < trailingTimeout) {\\n                return;\\n            }\\n\\n            // Schedule new call to be in invoked when the pending one is resolved.\\n            // This is important for \\\"transitions\\\" which never actually start\\n            // immediately so there is a chance that we might miss one if change\\n            // happens amids the pending invocation.\\n            trailingCall = true;\\n        } else {\\n            leadingCall = true;\\n            trailingCall = false;\\n\\n            setTimeout(timeoutCallback, delay);\\n        }\\n\\n        lastCallTime = timeStamp;\\n    }\\n\\n    return proxy;\\n};\\n\\n// Minimum delay before invoking the update of observers.\\nvar REFRESH_DELAY = 20;\\n\\n// A list of substrings of CSS properties used to find transition events that\\n// might affect dimensions of observed elements.\\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\\n\\n// Check if MutationObserver is available.\\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\\n\\n/**\\r\\n * Singleton controller class which handles updates of ResizeObserver instances.\\r\\n */\\nvar ResizeObserverController = function() {\\n    this.connected_ = false;\\n    this.mutationEventsAdded_ = false;\\n    this.mutationsObserver_ = null;\\n    this.observers_ = [];\\n\\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\\n};\\n\\n/**\\r\\n * Adds observer to observers list.\\r\\n *\\r\\n * @param {ResizeObserverSPI} observer - Observer to be added.\\r\\n * @returns {void}\\r\\n */\\n\\n\\n/**\\r\\n * Holds reference to the controller's instance.\\r\\n *\\r\\n * @private {ResizeObserverController}\\r\\n */\\n\\n\\n/**\\r\\n * Keeps reference to the instance of MutationObserver.\\r\\n *\\r\\n * @private {MutationObserver}\\r\\n */\\n\\n/**\\r\\n * Indicates whether DOM listeners have been added.\\r\\n *\\r\\n * @private {boolean}\\r\\n */\\nResizeObserverController.prototype.addObserver = function (observer) {\\n    if (!~this.observers_.indexOf(observer)) {\\n        this.observers_.push(observer);\\n    }\\n\\n    // Add listeners if they haven't been added yet.\\n    if (!this.connected_) {\\n        this.connect_();\\n    }\\n};\\n\\n/**\\r\\n * Removes observer from observers list.\\r\\n *\\r\\n * @param {ResizeObserverSPI} observer - Observer to be removed.\\r\\n * @returns {void}\\r\\n */\\nResizeObserverController.prototype.removeObserver = function (observer) {\\n    var observers = this.observers_;\\n    var index = observers.indexOf(observer);\\n\\n    // Remove observer if it's present in registry.\\n    if (~index) {\\n        observers.splice(index, 1);\\n    }\\n\\n    // Remove listeners if controller has no connected observers.\\n    if (!observers.length && this.connected_) {\\n        this.disconnect_();\\n    }\\n};\\n\\n/**\\r\\n * Invokes the update of observers. It will continue running updates insofar\\r\\n * it detects changes.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\nResizeObserverController.prototype.refresh = function () {\\n    var changesDetected = this.updateObservers_();\\n\\n    // Continue running updates if changes have been detected as there might\\n    // be future ones caused by CSS transitions.\\n    if (changesDetected) {\\n        this.refresh();\\n    }\\n};\\n\\n/**\\r\\n * Updates every observer from observers list and notifies them of queued\\r\\n * entries.\\r\\n *\\r\\n * @private\\r\\n * @returns {boolean} Returns \\\"true\\\" if any observer has detected changes in\\r\\n *  dimensions of it's elements.\\r\\n */\\nResizeObserverController.prototype.updateObservers_ = function () {\\n    // Collect observers that have active observations.\\n    var activeObservers = this.observers_.filter(function (observer) {\\n        return observer.gatherActive(), observer.hasActive();\\n    });\\n\\n    // Deliver notifications in a separate cycle in order to avoid any\\n    // collisions between observers, e.g. when multiple instances of\\n    // ResizeObserver are tracking the same element and the callback of one\\n    // of them changes content dimensions of the observed target. Sometimes\\n    // this may result in notifications being blocked for the rest of observers.\\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\\n\\n    return activeObservers.length > 0;\\n};\\n\\n/**\\r\\n * Initializes DOM listeners.\\r\\n *\\r\\n * @private\\r\\n * @returns {void}\\r\\n */\\nResizeObserverController.prototype.connect_ = function () {\\n    // Do nothing if running in a non-browser environment or if listeners\\n    // have been already added.\\n    if (!isBrowser || this.connected_) {\\n        return;\\n    }\\n\\n    // Subscription to the \\\"Transitionend\\\" event is used as a workaround for\\n    // delayed transitions. This way it's possible to capture at least the\\n    // final state of an element.\\n    document.addEventListener('transitionend', this.onTransitionEnd_);\\n\\n    window.addEventListener('resize', this.refresh);\\n\\n    if (mutationObserverSupported) {\\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\\n\\n        this.mutationsObserver_.observe(document, {\\n            attributes: true,\\n            childList: true,\\n            characterData: true,\\n            subtree: true\\n        });\\n    } else {\\n        document.addEventListener('DOMSubtreeModified', this.refresh);\\n\\n        this.mutationEventsAdded_ = true;\\n    }\\n\\n    this.connected_ = true;\\n};\\n\\n/**\\r\\n * Removes DOM listeners.\\r\\n *\\r\\n * @private\\r\\n * @returns {void}\\r\\n */\\nResizeObserverController.prototype.disconnect_ = function () {\\n    // Do nothing if running in a non-browser environment or if listeners\\n    // have been already removed.\\n    if (!isBrowser || !this.connected_) {\\n        return;\\n    }\\n\\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\\n    window.removeEventListener('resize', this.refresh);\\n\\n    if (this.mutationsObserver_) {\\n        this.mutationsObserver_.disconnect();\\n    }\\n\\n    if (this.mutationEventsAdded_) {\\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\\n    }\\n\\n    this.mutationsObserver_ = null;\\n    this.mutationEventsAdded_ = false;\\n    this.connected_ = false;\\n};\\n\\n/**\\r\\n * \\\"Transitionend\\\" event handler.\\r\\n *\\r\\n * @private\\r\\n * @param {TransitionEvent} event\\r\\n * @returns {void}\\r\\n */\\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\\n\\n    // Detect whether transition may affect dimensions of an element.\\n    var isReflowProperty = transitionKeys.some(function (key) {\\n        return !!~propertyName.indexOf(key);\\n    });\\n\\n    if (isReflowProperty) {\\n        this.refresh();\\n    }\\n};\\n\\n/**\\r\\n * Returns instance of the ResizeObserverController.\\r\\n *\\r\\n * @returns {ResizeObserverController}\\r\\n */\\nResizeObserverController.getInstance = function () {\\n    if (!this.instance_) {\\n        this.instance_ = new ResizeObserverController();\\n    }\\n\\n    return this.instance_;\\n};\\n\\nResizeObserverController.instance_ = null;\\n\\n/**\\r\\n * Defines non-writable/enumerable properties of the provided target object.\\r\\n *\\r\\n * @param {Object} target - Object for which to define properties.\\r\\n * @param {Object} props - Properties to be defined.\\r\\n * @returns {Object} Target object.\\r\\n */\\nvar defineConfigurable = (function (target, props) {\\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\\n        var key = list[i];\\n\\n        Object.defineProperty(target, key, {\\n            value: props[key],\\n            enumerable: false,\\n            writable: false,\\n            configurable: true\\n        });\\n    }\\n\\n    return target;\\n});\\n\\n/**\\r\\n * Returns the global object associated with provided element.\\r\\n *\\r\\n * @param {Object} target\\r\\n * @returns {Object}\\r\\n */\\nvar getWindowOf = (function (target) {\\n    // Assume that the element is an instance of Node, which means that it\\n    // has the \\\"ownerDocument\\\" property from which we can retrieve a\\n    // corresponding global object.\\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\\n\\n    // Return the local global object if it's not possible extract one from\\n    // provided element.\\n    return ownerGlobal || global$1;\\n});\\n\\n// Placeholder of an empty content rectangle.\\nvar emptyRect = createRectInit(0, 0, 0, 0);\\n\\n/**\\r\\n * Converts provided string to a number.\\r\\n *\\r\\n * @param {number|string} value\\r\\n * @returns {number}\\r\\n */\\nfunction toFloat(value) {\\n    return parseFloat(value) || 0;\\n}\\n\\n/**\\r\\n * Extracts borders size from provided styles.\\r\\n *\\r\\n * @param {CSSStyleDeclaration} styles\\r\\n * @param {...string} positions - Borders positions (top, right, ...)\\r\\n * @returns {number}\\r\\n */\\nfunction getBordersSize(styles) {\\n    var positions = [], len = arguments.length - 1;\\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\\n\\n    return positions.reduce(function (size, position) {\\n        var value = styles['border-' + position + '-width'];\\n\\n        return size + toFloat(value);\\n    }, 0);\\n}\\n\\n/**\\r\\n * Extracts paddings sizes from provided styles.\\r\\n *\\r\\n * @param {CSSStyleDeclaration} styles\\r\\n * @returns {Object} Paddings box.\\r\\n */\\nfunction getPaddings(styles) {\\n    var positions = ['top', 'right', 'bottom', 'left'];\\n    var paddings = {};\\n\\n    for (var i = 0, list = positions; i < list.length; i += 1) {\\n        var position = list[i];\\n\\n        var value = styles['padding-' + position];\\n\\n        paddings[position] = toFloat(value);\\n    }\\n\\n    return paddings;\\n}\\n\\n/**\\r\\n * Calculates content rectangle of provided SVG element.\\r\\n *\\r\\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\\r\\n *      to be calculated.\\r\\n * @returns {DOMRectInit}\\r\\n */\\nfunction getSVGContentRect(target) {\\n    var bbox = target.getBBox();\\n\\n    return createRectInit(0, 0, bbox.width, bbox.height);\\n}\\n\\n/**\\r\\n * Calculates content rectangle of provided HTMLElement.\\r\\n *\\r\\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\\r\\n * @returns {DOMRectInit}\\r\\n */\\nfunction getHTMLElementContentRect(target) {\\n    // Client width & height properties can't be\\n    // used exclusively as they provide rounded values.\\n    var clientWidth = target.clientWidth;\\n    var clientHeight = target.clientHeight;\\n\\n    // By this condition we can catch all non-replaced inline, hidden and\\n    // detached elements. Though elements with width & height properties less\\n    // than 0.5 will be discarded as well.\\n    //\\n    // Without it we would need to implement separate methods for each of\\n    // those cases and it's not possible to perform a precise and performance\\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\\n    // gives wrong results for elements with width & height less than 0.5.\\n    if (!clientWidth && !clientHeight) {\\n        return emptyRect;\\n    }\\n\\n    var styles = getWindowOf(target).getComputedStyle(target);\\n    var paddings = getPaddings(styles);\\n    var horizPad = paddings.left + paddings.right;\\n    var vertPad = paddings.top + paddings.bottom;\\n\\n    // Computed styles of width & height are being used because they are the\\n    // only dimensions available to JS that contain non-rounded values. It could\\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\\n    var width = toFloat(styles.width),\\n        height = toFloat(styles.height);\\n\\n    // Width & height include paddings and borders when the 'border-box' box\\n    // model is applied (except for IE).\\n    if (styles.boxSizing === 'border-box') {\\n        // Following conditions are required to handle Internet Explorer which\\n        // doesn't include paddings and borders to computed CSS dimensions.\\n        //\\n        // We can say that if CSS dimensions + paddings are equal to the \\\"client\\\"\\n        // properties then it's either IE, and thus we don't need to subtract\\n        // anything, or an element merely doesn't have paddings/borders styles.\\n        if (Math.round(width + horizPad) !== clientWidth) {\\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\\n        }\\n\\n        if (Math.round(height + vertPad) !== clientHeight) {\\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\\n        }\\n    }\\n\\n    // Following steps can't be applied to the document's root element as its\\n    // client[Width/Height] properties represent viewport area of the window.\\n    // Besides, it's as well not necessary as the <html> itself neither has\\n    // rendered scroll bars nor it can be clipped.\\n    if (!isDocumentElement(target)) {\\n        // In some browsers (only in Firefox, actually) CSS width & height\\n        // include scroll bars size which can be removed at this step as scroll\\n        // bars are the only difference between rounded dimensions + paddings\\n        // and \\\"client\\\" properties, though that is not always true in Chrome.\\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\\n\\n        // Chrome has a rather weird rounding of \\\"client\\\" properties.\\n        // E.g. for an element with content width of 314.2px it sometimes gives\\n        // the client width of 315px and for the width of 314.7px it may give\\n        // 314px. And it doesn't happen all the time. So just ignore this delta\\n        // as a non-relevant.\\n        if (Math.abs(vertScrollbar) !== 1) {\\n            width -= vertScrollbar;\\n        }\\n\\n        if (Math.abs(horizScrollbar) !== 1) {\\n            height -= horizScrollbar;\\n        }\\n    }\\n\\n    return createRectInit(paddings.left, paddings.top, width, height);\\n}\\n\\n/**\\r\\n * Checks whether provided element is an instance of the SVGGraphicsElement.\\r\\n *\\r\\n * @param {Element} target - Element to be checked.\\r\\n * @returns {boolean}\\r\\n */\\nvar isSVGGraphicsElement = (function () {\\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\\n    // interface.\\n    if (typeof SVGGraphicsElement !== 'undefined') {\\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\\n    }\\n\\n    // If it's so, then check that element is at least an instance of the\\n    // SVGElement and that it has the \\\"getBBox\\\" method.\\n    // eslint-disable-next-line no-extra-parens\\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\\n})();\\n\\n/**\\r\\n * Checks whether provided element is a document element (<html>).\\r\\n *\\r\\n * @param {Element} target - Element to be checked.\\r\\n * @returns {boolean}\\r\\n */\\nfunction isDocumentElement(target) {\\n    return target === getWindowOf(target).document.documentElement;\\n}\\n\\n/**\\r\\n * Calculates an appropriate content rectangle for provided html or svg element.\\r\\n *\\r\\n * @param {Element} target - Element content rectangle of which needs to be calculated.\\r\\n * @returns {DOMRectInit}\\r\\n */\\nfunction getContentRect(target) {\\n    if (!isBrowser) {\\n        return emptyRect;\\n    }\\n\\n    if (isSVGGraphicsElement(target)) {\\n        return getSVGContentRect(target);\\n    }\\n\\n    return getHTMLElementContentRect(target);\\n}\\n\\n/**\\r\\n * Creates rectangle with an interface of the DOMRectReadOnly.\\r\\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\\r\\n *\\r\\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\\r\\n * @returns {DOMRectReadOnly}\\r\\n */\\nfunction createReadOnlyRect(ref) {\\n    var x = ref.x;\\n    var y = ref.y;\\n    var width = ref.width;\\n    var height = ref.height;\\n\\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\\n    var rect = Object.create(Constr.prototype);\\n\\n    // Rectangle's properties are not writable and non-enumerable.\\n    defineConfigurable(rect, {\\n        x: x, y: y, width: width, height: height,\\n        top: y,\\n        right: x + width,\\n        bottom: height + y,\\n        left: x\\n    });\\n\\n    return rect;\\n}\\n\\n/**\\r\\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\\r\\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\\r\\n *\\r\\n * @param {number} x - X coordinate.\\r\\n * @param {number} y - Y coordinate.\\r\\n * @param {number} width - Rectangle's width.\\r\\n * @param {number} height - Rectangle's height.\\r\\n * @returns {DOMRectInit}\\r\\n */\\nfunction createRectInit(x, y, width, height) {\\n    return { x: x, y: y, width: width, height: height };\\n}\\n\\n/**\\r\\n * Class that is responsible for computations of the content rectangle of\\r\\n * provided DOM element and for keeping track of it's changes.\\r\\n */\\nvar ResizeObservation = function(target) {\\n    this.broadcastWidth = 0;\\n    this.broadcastHeight = 0;\\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\\n\\n    this.target = target;\\n};\\n\\n/**\\r\\n * Updates content rectangle and tells whether it's width or height properties\\r\\n * have changed since the last broadcast.\\r\\n *\\r\\n * @returns {boolean}\\r\\n */\\n\\n\\n/**\\r\\n * Reference to the last observed content rectangle.\\r\\n *\\r\\n * @private {DOMRectInit}\\r\\n */\\n\\n\\n/**\\r\\n * Broadcasted width of content rectangle.\\r\\n *\\r\\n * @type {number}\\r\\n */\\nResizeObservation.prototype.isActive = function () {\\n    var rect = getContentRect(this.target);\\n\\n    this.contentRect_ = rect;\\n\\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\\n};\\n\\n/**\\r\\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\\r\\n * from the corresponding properties of the last observed content rectangle.\\r\\n *\\r\\n * @returns {DOMRectInit} Last observed content rectangle.\\r\\n */\\nResizeObservation.prototype.broadcastRect = function () {\\n    var rect = this.contentRect_;\\n\\n    this.broadcastWidth = rect.width;\\n    this.broadcastHeight = rect.height;\\n\\n    return rect;\\n};\\n\\nvar ResizeObserverEntry = function(target, rectInit) {\\n    var contentRect = createReadOnlyRect(rectInit);\\n\\n    // According to the specification following properties are not writable\\n    // and are also not enumerable in the native implementation.\\n    //\\n    // Property accessors are not being used as they'd require to define a\\n    // private WeakMap storage which may cause memory leaks in browsers that\\n    // don't support this type of collections.\\n    defineConfigurable(this, { target: target, contentRect: contentRect });\\n};\\n\\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\\n    this.activeObservations_ = [];\\n    this.observations_ = new MapShim();\\n\\n    if (typeof callback !== 'function') {\\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\\n    }\\n\\n    this.callback_ = callback;\\n    this.controller_ = controller;\\n    this.callbackCtx_ = callbackCtx;\\n};\\n\\n/**\\r\\n * Starts observing provided element.\\r\\n *\\r\\n * @param {Element} target - Element to be observed.\\r\\n * @returns {void}\\r\\n */\\n\\n\\n/**\\r\\n * Registry of the ResizeObservation instances.\\r\\n *\\r\\n * @private {Map<Element, ResizeObservation>}\\r\\n */\\n\\n\\n/**\\r\\n * Public ResizeObserver instance which will be passed to the callback\\r\\n * function and used as a value of it's \\\"this\\\" binding.\\r\\n *\\r\\n * @private {ResizeObserver}\\r\\n */\\n\\n/**\\r\\n * Collection of resize observations that have detected changes in dimensions\\r\\n * of elements.\\r\\n *\\r\\n * @private {Array<ResizeObservation>}\\r\\n */\\nResizeObserverSPI.prototype.observe = function (target) {\\n    if (!arguments.length) {\\n        throw new TypeError('1 argument required, but only 0 present.');\\n    }\\n\\n    // Do nothing if current environment doesn't have the Element interface.\\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\\n        return;\\n    }\\n\\n    if (!(target instanceof getWindowOf(target).Element)) {\\n        throw new TypeError('parameter 1 is not of type \\\"Element\\\".');\\n    }\\n\\n    var observations = this.observations_;\\n\\n    // Do nothing if element is already being observed.\\n    if (observations.has(target)) {\\n        return;\\n    }\\n\\n    observations.set(target, new ResizeObservation(target));\\n\\n    this.controller_.addObserver(this);\\n\\n    // Force the update of observations.\\n    this.controller_.refresh();\\n};\\n\\n/**\\r\\n * Stops observing provided element.\\r\\n *\\r\\n * @param {Element} target - Element to stop observing.\\r\\n * @returns {void}\\r\\n */\\nResizeObserverSPI.prototype.unobserve = function (target) {\\n    if (!arguments.length) {\\n        throw new TypeError('1 argument required, but only 0 present.');\\n    }\\n\\n    // Do nothing if current environment doesn't have the Element interface.\\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\\n        return;\\n    }\\n\\n    if (!(target instanceof getWindowOf(target).Element)) {\\n        throw new TypeError('parameter 1 is not of type \\\"Element\\\".');\\n    }\\n\\n    var observations = this.observations_;\\n\\n    // Do nothing if element is not being observed.\\n    if (!observations.has(target)) {\\n        return;\\n    }\\n\\n    observations.delete(target);\\n\\n    if (!observations.size) {\\n        this.controller_.removeObserver(this);\\n    }\\n};\\n\\n/**\\r\\n * Stops observing all elements.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\nResizeObserverSPI.prototype.disconnect = function () {\\n    this.clearActive();\\n    this.observations_.clear();\\n    this.controller_.removeObserver(this);\\n};\\n\\n/**\\r\\n * Collects observation instances the associated element of which has changed\\r\\n * it's content rectangle.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\nResizeObserverSPI.prototype.gatherActive = function () {\\n        var this$1 = this;\\n\\n    this.clearActive();\\n\\n    this.observations_.forEach(function (observation) {\\n        if (observation.isActive()) {\\n            this$1.activeObservations_.push(observation);\\n        }\\n    });\\n};\\n\\n/**\\r\\n * Invokes initial callback function with a list of ResizeObserverEntry\\r\\n * instances collected from active resize observations.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\nResizeObserverSPI.prototype.broadcastActive = function () {\\n    // Do nothing if observer doesn't have active observations.\\n    if (!this.hasActive()) {\\n        return;\\n    }\\n\\n    var ctx = this.callbackCtx_;\\n\\n    // Create ResizeObserverEntry instance for every active observation.\\n    var entries = this.activeObservations_.map(function (observation) {\\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\\n    });\\n\\n    this.callback_.call(ctx, entries, ctx);\\n    this.clearActive();\\n};\\n\\n/**\\r\\n * Clears the collection of active observations.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\nResizeObserverSPI.prototype.clearActive = function () {\\n    this.activeObservations_.splice(0);\\n};\\n\\n/**\\r\\n * Tells whether observer has active observations.\\r\\n *\\r\\n * @returns {boolean}\\r\\n */\\nResizeObserverSPI.prototype.hasActive = function () {\\n    return this.activeObservations_.length > 0;\\n};\\n\\n// Registry of internal observers. If WeakMap is not available use current shim\\n// for the Map collection as it has all required methods and because WeakMap\\n// can't be fully polyfilled anyway.\\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\\n\\n/**\\r\\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\\r\\n * exposing only those methods and properties that are defined in the spec.\\r\\n */\\nvar ResizeObserver = function(callback) {\\n    if (!(this instanceof ResizeObserver)) {\\n        throw new TypeError('Cannot call a class as a function.');\\n    }\\n    if (!arguments.length) {\\n        throw new TypeError('1 argument required, but only 0 present.');\\n    }\\n\\n    var controller = ResizeObserverController.getInstance();\\n    var observer = new ResizeObserverSPI(callback, controller, this);\\n\\n    observers.set(this, observer);\\n};\\n\\n// Expose public methods of ResizeObserver.\\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\\n    ResizeObserver.prototype[method] = function () {\\n        return (ref = observers.get(this))[method].apply(ref, arguments);\\n        var ref;\\n    };\\n});\\n\\nvar index = (function () {\\n    // Export existing implementation if available.\\n    if (typeof global$1.ResizeObserver !== 'undefined') {\\n        return global$1.ResizeObserver;\\n    }\\n\\n    return ResizeObserver;\\n})();\\n\\nreturn index;\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"factory\",\"define\",\"amd\",\"ResizeObserver\",\"getBordersSize\",\"styles\",\"positions\",\"len\",\"arguments\",\"length\",\"reduce\",\"size\",\"position\",\"parseFloat\",\"value\",\"MapShim\",\"getIndex\",\"arr\",\"key\",\"result\",\"some\",\"entry\",\"index\",\"Map\",\"anonymous\",\"__entries__\",\"prototypeAccessors\",\"configurable\",\"get\",\"prototypeAccessors.size.get\",\"prototype\",\"anonymous.prototype.get\",\"set\",\"anonymous.prototype.set\",\"push\",\"delete\",\"anonymous.prototype.delete\",\"entries\",\"splice\",\"has\",\"anonymous.prototype.has\",\"clear\",\"anonymous.prototype.clear\",\"forEach\",\"anonymous.prototype.forEach\",\"callback\",\"ctx\",\"i\",\"list\",\"this$1\",\"call\",\"Object\",\"defineProperties\",\"isBrowser\",\"window\",\"document\",\"global$1\",\"Math\",\"self\",\"Function\",\"requestAnimationFrame$1\",\"requestAnimationFrame\",\"bind\",\"setTimeout\",\"Date\",\"now\",\"throttle\",\"delay\",\"resolvePending\",\"leadingCall\",\"trailingCall\",\"proxy\",\"timeoutCallback\",\"timeStamp\",\"trailingTimeout\",\"lastCallTime\",\"transitionKeys\",\"mutationObserverSupported\",\"MutationObserver\",\"ResizeObserverController\",\"mutationEventsAdded_\",\"connected_\",\"mutationsObserver_\",\"observers_\",\"onTransitionEnd_\",\"refresh\",\"REFRESH_DELAY\",\"addObserver\",\"ResizeObserverController.prototype.addObserver\",\"observer\",\"indexOf\",\"connect_\",\"removeObserver\",\"ResizeObserverController.prototype.removeObserver\",\"observers\",\"disconnect_\",\"ResizeObserverController.prototype.refresh\",\"updateObservers_\",\"changesDetected\",\"ResizeObserverController.prototype.updateObservers_\",\"activeObservers\",\"filter\",\"gatherActive\",\"hasActive\",\"broadcastActive\",\"ResizeObserverController.prototype.connect_\",\"addEventListener\",\"observe\",\"attributes\",\"childList\",\"characterData\",\"subtree\",\"ResizeObserverController.prototype.disconnect_\",\"removeEventListener\",\"disconnect\",\"ResizeObserverController.prototype.onTransitionEnd_\",\"ref\",\"propertyName\",\"isReflowProperty\",\"getInstance\",\"ResizeObserverController.getInstance\",\"instance_\",\"defineConfigurable\",\"target\",\"props\",\"keys\",\"defineProperty\",\"enumerable\",\"writable\",\"getWindowOf\",\"ownerDocument\",\"defaultView\",\"emptyRect\",\"x\",\"y\",\"width\",\"height\",\"isSVGGraphicsElement\",\"SVGGraphicsElement\",\"SVGElement\",\"getBBox\",\"ResizeObservation\",\"broadcastHeight\",\"broadcastWidth\",\"contentRect_\",\"isActive\",\"ResizeObservation.prototype.isActive\",\"bbox\",\"clientWidth\",\"clientHeight\",\"getComputedStyle\",\"paddings\",\"horizPad\",\"left\",\"right\",\"vertPad\",\"top\",\"bottom\",\"boxSizing\",\"round\",\"documentElement\",\"vertScrollbar\",\"horizScrollbar\",\"abs\",\"rect\",\"broadcastRect\",\"ResizeObservation.prototype.broadcastRect\",\"ResizeObserverEntry\",\"rectInit\",\"create\",\"Constr\",\"DOMRectReadOnly\",\"contentRect\",\"ResizeObserverSPI\",\"controller\",\"callbackCtx\",\"activeObservations_\",\"observations_\",\"TypeError\",\"callback_\",\"controller_\",\"callbackCtx_\",\"ResizeObserverSPI.prototype.observe\",\"Element\",\"observations\",\"unobserve\",\"ResizeObserverSPI.prototype.unobserve\",\"ResizeObserverSPI.prototype.disconnect\",\"clearActive\",\"ResizeObserverSPI.prototype.gatherActive\",\"observation\",\"ResizeObserverSPI.prototype.broadcastActive\",\"map\",\"ResizeObserverSPI.prototype.clearActive\",\"ResizeObserverSPI.prototype.hasActive\",\"WeakMap\",\"method\",\"apply\"]\n}\n"]