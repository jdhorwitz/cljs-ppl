["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$insertFragmentIntoContentState=function(global,process,require,module,exports,shadow$shims){var BlockMapBuilder=require(\"module$node_modules$draft_js$lib$BlockMapBuilder\"),ContentBlockNode=require(\"module$node_modules$draft_js$lib$ContentBlockNode\");global=require(\"module$node_modules$immutable$dist$immutable\");var insertIntoList=require(\"module$node_modules$draft_js$lib$insertIntoList\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),randomizeBlockMapKeys=\nrequire(\"module$node_modules$draft_js$lib$randomizeBlockMapKeys\"),List=global.List,updateHead=function(block,targetOffset,fragment){var text=block.getText(),chars=block.getCharacterList();text=text.slice(0,targetOffset);targetOffset=chars.slice(0,targetOffset);fragment=fragment.first();return block.merge({text:text+fragment.getText(),characterList:targetOffset.concat(fragment.getCharacterList()),type:text?block.getType():fragment.getType(),data:fragment.getData()})},updateTail=function(block,targetOffset,\nfragment){var text=block.getText();block=block.getCharacterList();var blockSize=text.length;text=text.slice(targetOffset,blockSize);targetOffset=block.slice(targetOffset,blockSize);fragment=fragment.last();return fragment.merge({text:fragment.getText()+text,characterList:fragment.getCharacterList().concat(targetOffset),data:fragment.getData()})},getRootBlocks=function(block,blockMap){var headKey=block.getKey(),rootBlock=block;block=[];for(blockMap.get(headKey)&&block.push(headKey);rootBlock&&rootBlock.getNextSiblingKey();){headKey=\nrootBlock.getNextSiblingKey();if(!headKey)break;block.push(headKey);rootBlock=blockMap.get(headKey)}return block},updateBlockMapLinks=function(blockMap,originalBlockMap,targetBlock,fragmentHeadBlock){return blockMap.withMutations(function(blockMapState){var targetKey=targetBlock.getKey(),headKey=fragmentHeadBlock.getKey(),targetNextKey=targetBlock.getNextSiblingKey(),targetParentKey=targetBlock.getParentKey(),fragmentRootBlocks=getRootBlocks(fragmentHeadBlock,blockMap),lastRootFragmentBlockKey=fragmentRootBlocks[fragmentRootBlocks.length-\n1];blockMapState.get(headKey)?(blockMapState.setIn([targetKey,\"nextSibling\"],headKey),blockMapState.setIn([headKey,\"prevSibling\"],targetKey)):(blockMapState.setIn([targetKey,\"nextSibling\"],fragmentHeadBlock.getNextSiblingKey()),blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(),\"prevSibling\"],targetKey));blockMapState.setIn([lastRootFragmentBlockKey,\"nextSibling\"],targetNextKey);targetNextKey&&blockMapState.setIn([targetNextKey,\"prevSibling\"],lastRootFragmentBlockKey);fragmentRootBlocks.forEach(function(blockKey){return blockMapState.setIn([blockKey,\n\"parent\"],targetParentKey)});targetParentKey&&(headKey=blockMap.get(targetParentKey).getChildKeys(),targetKey=headKey.indexOf(targetKey)+1,headKey=headKey.toArray(),headKey.splice.apply(headKey,[targetKey,0].concat(fragmentRootBlocks)),blockMapState.setIn([targetParentKey,\"children\"],List(headKey)))})},insertFragment=function(contentState,selectionState,blockMap,fragment,targetKey,targetOffset){var isTreeBasedBlockMap=blockMap.first()instanceof ContentBlockNode,newBlockArr=[],fragmentSize=fragment.size,\ntarget=blockMap.get(targetKey),head=fragment.first(),tail=fragment.last(),finalOffset=tail.getLength();tail=tail.getKey();var shouldNotUpdateFromFragmentBlock=isTreeBasedBlockMap&&(!target.getChildKeys().isEmpty()||!head.getChildKeys().isEmpty());blockMap.forEach(function(block,blockKey){blockKey!==targetKey?newBlockArr.push(block):(shouldNotUpdateFromFragmentBlock?newBlockArr.push(block):newBlockArr.push(updateHead(block,targetOffset,fragment)),fragment.slice(shouldNotUpdateFromFragmentBlock?0:1,\nfragmentSize-1).forEach(function(fragmentBlock){return newBlockArr.push(fragmentBlock)}),newBlockArr.push(updateTail(block,targetOffset,fragment)))});var updatedBlockMap=BlockMapBuilder.createFromArray(newBlockArr);isTreeBasedBlockMap&&(updatedBlockMap=updateBlockMapLinks(updatedBlockMap,blockMap,target,head));return contentState.merge({blockMap:updatedBlockMap,selectionBefore:selectionState,selectionAfter:selectionState.merge({anchorKey:tail,anchorOffset:finalOffset,focusKey:tail,focusOffset:finalOffset,\nisBackward:!1})})};module.exports=function(contentState,selectionState,fragmentBlockMap){selectionState.isCollapsed()?void 0:invariant(!1,\"`insertFragment` should only be called with a collapsed selection state.\");var blockMap=contentState.getBlockMap(),fragment=randomizeBlockMapKeys(fragmentBlockMap);fragmentBlockMap=selectionState.getStartKey();var targetOffset=selectionState.getStartOffset(),targetBlock=blockMap.get(fragmentBlockMap);targetBlock instanceof ContentBlockNode&&(targetBlock.getChildKeys().isEmpty()?\nvoid 0:invariant(!1,\"`insertFragment` should not be called when a container node is selected.\"));if(1===fragment.size){targetBlock=fragment.first();var targetBlock$jscomp$0=blockMap.get(fragmentBlockMap),text=targetBlock$jscomp$0.getText(),chars=targetBlock$jscomp$0.getCharacterList();fragment=targetOffset+targetBlock.getText().length;targetOffset=targetBlock$jscomp$0.merge({text:text.slice(0,targetOffset)+targetBlock.getText()+text.slice(targetOffset),characterList:insertIntoList(chars,targetBlock.getCharacterList(),\ntargetOffset),data:targetBlock.getData()});return contentState.merge({blockMap:blockMap.set(fragmentBlockMap,targetOffset),selectionBefore:selectionState,selectionAfter:selectionState.merge({anchorKey:fragmentBlockMap,anchorOffset:fragment,focusKey:fragmentBlockMap,focusOffset:fragment,isBackward:!1})})}return insertFragment(contentState,selectionState,blockMap,fragment,fragmentBlockMap,targetOffset)}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$insertFragmentIntoContentState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar insertIntoList = require('./insertIntoList');\nvar invariant = require('fbjs/lib/invariant');\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar List = Immutable.List;\n\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = [];\n\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    }\n\n    // update the last root block fragment\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\n\n    // update the original target next block\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    }\n\n    // update fragment parent links\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    });\n\n    // update targetBlock parent child links\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\n\n      // insert fragment children\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    }\n\n    // Insert fragment blocks after the head and before the tail.\n    fragment\n    // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    });\n\n    // update tail\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  }\n\n  // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$draft_js$lib$insertIntoList","~$module$node_modules$draft_js$lib$BlockMapBuilder","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$draft_js$lib$ContentBlockNode","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$draft_js$lib$randomizeBlockMapKeys"]],"~:properties",["^5",["selectionBefore","anchorOffset","isBackward","selectionAfter","anchorKey","text","focusKey","focusOffset","characterList","blockMap","type","data"]],"~:compiled-at",1532351402128,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$insertFragmentIntoContentState.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/insertFragmentIntoContentState.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$insertFragmentIntoContentState\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule insertFragmentIntoContentState\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar BlockMapBuilder = require('./BlockMapBuilder');\\nvar ContentBlockNode = require('./ContentBlockNode');\\nvar Immutable = require('immutable');\\n\\nvar insertIntoList = require('./insertIntoList');\\nvar invariant = require('fbjs/lib/invariant');\\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\\n\\nvar List = Immutable.List;\\n\\n\\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\\n  var targetBlock = blockMap.get(targetKey);\\n  var text = targetBlock.getText();\\n  var chars = targetBlock.getCharacterList();\\n  var finalKey = targetKey;\\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\\n\\n  var newBlock = targetBlock.merge({\\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\\n    data: fragmentBlock.getData()\\n  });\\n\\n  return contentState.merge({\\n    blockMap: blockMap.set(targetKey, newBlock),\\n    selectionBefore: selectionState,\\n    selectionAfter: selectionState.merge({\\n      anchorKey: finalKey,\\n      anchorOffset: finalOffset,\\n      focusKey: finalKey,\\n      focusOffset: finalOffset,\\n      isBackward: false\\n    })\\n  });\\n};\\n\\n/**\\n * Appends text/characterList from the fragment first block to\\n * target block.\\n */\\nvar updateHead = function updateHead(block, targetOffset, fragment) {\\n  var text = block.getText();\\n  var chars = block.getCharacterList();\\n\\n  // Modify head portion of block.\\n  var headText = text.slice(0, targetOffset);\\n  var headCharacters = chars.slice(0, targetOffset);\\n  var appendToHead = fragment.first();\\n\\n  return block.merge({\\n    text: headText + appendToHead.getText(),\\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\\n    type: headText ? block.getType() : appendToHead.getType(),\\n    data: appendToHead.getData()\\n  });\\n};\\n\\n/**\\n * Appends offset text/characterList from the target block to the last\\n * fragment block.\\n */\\nvar updateTail = function updateTail(block, targetOffset, fragment) {\\n  // Modify tail portion of block.\\n  var text = block.getText();\\n  var chars = block.getCharacterList();\\n\\n  // Modify head portion of block.\\n  var blockSize = text.length;\\n  var tailText = text.slice(targetOffset, blockSize);\\n  var tailCharacters = chars.slice(targetOffset, blockSize);\\n  var prependToTail = fragment.last();\\n\\n  return prependToTail.merge({\\n    text: prependToTail.getText() + tailText,\\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\\n    data: prependToTail.getData()\\n  });\\n};\\n\\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\\n  var headKey = block.getKey();\\n  var rootBlock = block;\\n  var rootBlocks = [];\\n\\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\\n  // the fragment head is used to update the target block, however when this does not happen we need\\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\\n  // fragment root block\\n  if (blockMap.get(headKey)) {\\n    rootBlocks.push(headKey);\\n  }\\n\\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\\n\\n    if (!lastSiblingKey) {\\n      break;\\n    }\\n\\n    rootBlocks.push(lastSiblingKey);\\n    rootBlock = blockMap.get(lastSiblingKey);\\n  }\\n\\n  return rootBlocks;\\n};\\n\\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\\n  return blockMap.withMutations(function (blockMapState) {\\n    var targetKey = targetBlock.getKey();\\n    var headKey = fragmentHeadBlock.getKey();\\n    var targetNextKey = targetBlock.getNextSiblingKey();\\n    var targetParentKey = targetBlock.getParentKey();\\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\\n\\n    if (blockMapState.get(headKey)) {\\n      // update the fragment head when it is part of the blockMap otherwise\\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\\n    } else {\\n      // update the target block that had the fragment head contents merged into it\\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\\n    }\\n\\n    // update the last root block fragment\\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\\n\\n    // update the original target next block\\n    if (targetNextKey) {\\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\\n    }\\n\\n    // update fragment parent links\\n    fragmentRootBlocks.forEach(function (blockKey) {\\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\\n    });\\n\\n    // update targetBlock parent child links\\n    if (targetParentKey) {\\n      var targetParent = blockMap.get(targetParentKey);\\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\\n\\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\\n      var insertionIndex = targetBlockIndex + 1;\\n\\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\\n\\n      // insert fragment children\\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\\n\\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\\n    }\\n  });\\n};\\n\\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\\n  var newBlockArr = [];\\n  var fragmentSize = fragment.size;\\n  var target = blockMap.get(targetKey);\\n  var head = fragment.first();\\n  var tail = fragment.last();\\n  var finalOffset = tail.getLength();\\n  var finalKey = tail.getKey();\\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\\n\\n  blockMap.forEach(function (block, blockKey) {\\n    if (blockKey !== targetKey) {\\n      newBlockArr.push(block);\\n      return;\\n    }\\n\\n    if (shouldNotUpdateFromFragmentBlock) {\\n      newBlockArr.push(block);\\n    } else {\\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\\n    }\\n\\n    // Insert fragment blocks after the head and before the tail.\\n    fragment\\n    // when we are updating the target block with the head fragment block we skip the first fragment\\n    // head since its contents have already been merged with the target block otherwise we include\\n    // the whole fragment\\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\\n      return newBlockArr.push(fragmentBlock);\\n    });\\n\\n    // update tail\\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\\n  });\\n\\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\\n\\n  if (isTreeBasedBlockMap) {\\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\\n  }\\n\\n  return contentState.merge({\\n    blockMap: updatedBlockMap,\\n    selectionBefore: selectionState,\\n    selectionAfter: selectionState.merge({\\n      anchorKey: finalKey,\\n      anchorOffset: finalOffset,\\n      focusKey: finalKey,\\n      focusOffset: finalOffset,\\n      isBackward: false\\n    })\\n  });\\n};\\n\\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\\n\\n  var blockMap = contentState.getBlockMap();\\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\\n  var targetKey = selectionState.getStartKey();\\n  var targetOffset = selectionState.getStartOffset();\\n\\n  var targetBlock = blockMap.get(targetKey);\\n\\n  if (targetBlock instanceof ContentBlockNode) {\\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\\n  }\\n\\n  // When we insert a fragment with a single block we simply update the target block\\n  // with the contents of the inserted fragment block\\n  if (fragment.size === 1) {\\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\\n  }\\n\\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\\n};\\n\\nmodule.exports = insertFragmentIntoContentState;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"BlockMapBuilder\",\"ContentBlockNode\",\"Immutable\",\"insertIntoList\",\"invariant\",\"randomizeBlockMapKeys\",\"List\",\"updateHead\",\"block\",\"targetOffset\",\"fragment\",\"text\",\"getText\",\"chars\",\"getCharacterList\",\"headText\",\"slice\",\"headCharacters\",\"appendToHead\",\"first\",\"merge\",\"characterList\",\"concat\",\"type\",\"getType\",\"data\",\"getData\",\"updateTail\",\"blockSize\",\"length\",\"tailText\",\"tailCharacters\",\"prependToTail\",\"last\",\"getRootBlocks\",\"blockMap\",\"headKey\",\"getKey\",\"rootBlock\",\"rootBlocks\",\"get\",\"push\",\"getNextSiblingKey\",\"lastSiblingKey\",\"updateBlockMapLinks\",\"originalBlockMap\",\"targetBlock\",\"fragmentHeadBlock\",\"withMutations\",\"blockMapState\",\"targetKey\",\"targetNextKey\",\"targetParentKey\",\"getParentKey\",\"fragmentRootBlocks\",\"lastRootFragmentBlockKey\",\"setIn\",\"forEach\",\"blockKey\",\"originalTargetParentChildKeys\",\"targetParent\",\"getChildKeys\",\"insertionIndex\",\"indexOf\",\"targetBlockIndex\",\"newChildrenKeysArray\",\"toArray\",\"splice\",\"apply\",\"insertFragment\",\"contentState\",\"selectionState\",\"isTreeBasedBlockMap\",\"newBlockArr\",\"fragmentSize\",\"size\",\"target\",\"head\",\"tail\",\"finalOffset\",\"getLength\",\"finalKey\",\"shouldNotUpdateFromFragmentBlock\",\"isEmpty\",\"fragmentBlock\",\"updatedBlockMap\",\"createFromArray\",\"selectionBefore\",\"selectionAfter\",\"anchorKey\",\"anchorOffset\",\"focusKey\",\"focusOffset\",\"isBackward\",\"insertFragmentIntoContentState\",\"fragmentBlockMap\",\"isCollapsed\",\"getBlockMap\",\"getStartKey\",\"getStartOffset\",\"newBlock\",\"set\"]\n}\n"]