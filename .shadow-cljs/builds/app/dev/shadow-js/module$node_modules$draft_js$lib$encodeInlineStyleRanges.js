["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/encodeInlineStyleRanges.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$encodeInlineStyleRanges=function(global,process,require,module,exports,shadow$shims){function getEncodedInlinesForType(block,styleList,styleToEncode){var ranges=[];styleList=styleList.map(function(style){return style.has(styleToEncode)}).toList();findRangesImmutable(styleList,areEqual,isTruthy,function(start,end){var text=block.getText();ranges.push({offset:UnicodeUtils.strlen(text.slice(0,start)),length:UnicodeUtils.strlen(text.slice(start,end)),style:styleToEncode})});\nreturn ranges}var UnicodeUtils=require(\"module$node_modules$fbjs$lib$UnicodeUtils\"),findRangesImmutable=require(\"module$node_modules$draft_js$lib$findRangesImmutable\"),areEqual=function(a,b){return a===b},isTruthy=function(a){return!!a},EMPTY_ARRAY=[];module.exports=function(block){var styleList=block.getCharacterList().map(function(c){return c.getStyle()}).toList(),ranges=styleList.flatten().toSet().map(function(style){return getEncodedInlinesForType(block,styleList,style)});return Array.prototype.concat.apply(EMPTY_ARRAY,\nranges.toJS())}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$encodeInlineStyleRanges\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule encodeInlineStyleRanges\n * @format\n * \n */\n\n'use strict';\n\nvar UnicodeUtils = require('fbjs/lib/UnicodeUtils');\n\nvar findRangesImmutable = require('./findRangesImmutable');\n\nvar areEqual = function areEqual(a, b) {\n  return a === b;\n};\nvar isTruthy = function isTruthy(a) {\n  return !!a;\n};\nvar EMPTY_ARRAY = [];\n\n/**\n * Helper function for getting encoded styles for each inline style. Convert\n * to UTF-8 character counts for storage.\n */\nfunction getEncodedInlinesForType(block, styleList, styleToEncode) {\n  var ranges = [];\n\n  // Obtain an array with ranges for only the specified style.\n  var filteredInlines = styleList.map(function (style) {\n    return style.has(styleToEncode);\n  }).toList();\n\n  findRangesImmutable(filteredInlines, areEqual,\n  // We only want to keep ranges with nonzero style values.\n  isTruthy, function (start, end) {\n    var text = block.getText();\n    ranges.push({\n      offset: UnicodeUtils.strlen(text.slice(0, start)),\n      length: UnicodeUtils.strlen(text.slice(start, end)),\n      style: styleToEncode\n    });\n  });\n\n  return ranges;\n}\n\n/*\n * Retrieve the encoded arrays of inline styles, with each individual style\n * treated separately.\n */\nfunction encodeInlineStyleRanges(block) {\n  var styleList = block.getCharacterList().map(function (c) {\n    return c.getStyle();\n  }).toList();\n  var ranges = styleList.flatten().toSet().map(function (style) {\n    return getEncodedInlinesForType(block, styleList, style);\n  });\n\n  return Array.prototype.concat.apply(EMPTY_ARRAY, ranges.toJS());\n}\n\nmodule.exports = encodeInlineStyleRanges;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$UnicodeUtils","~$module$node_modules$draft_js$lib$findRangesImmutable"]],"~:properties",["^5",["offset","style","length"]],"~:compiled-at",1532351402153,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$encodeInlineStyleRanges.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,yDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAgC1IC,QAASA,yBAAwB,CAACC,KAAD,CAAQC,SAAR,CAAmBC,aAAnB,CAAkC,CACjE,IAAIC,OAAS,EAGTC,UAAAA,CAAkBH,SAAAI,IAAA,CAAc,QAAS,CAACC,KAAD,CAAQ,CACnD,MAAOA,MAAAC,IAAA,CAAUL,aAAV,CAD4C,CAA/B,CAAAM,OAAA,EAItBC,oBAAA,CAAoBL,SAApB,CAAqCM,QAArC,CAEAC,QAFA,CAEU,QAAS,CAACC,KAAD,CAAQC,GAAR,CAAa,CAC9B,IAAIC,KAAOd,KAAAe,QAAA,EACXZ,OAAAa,KAAA,CAAY,CACVC,OAAQC,YAAAC,OAAA,CAAoBL,IAAAM,MAAA,CAAW,CAAX,CAAcR,KAAd,CAApB,CADE,CAEVS,OAAQH,YAAAC,OAAA,CAAoBL,IAAAM,MAAA,CAAWR,KAAX,CAAkBC,GAAlB,CAApB,CAFE,CAGVP,MAAOJ,aAHG,CAAZ,CAF8B,CAFhC,CAWA;MAAOC,OAnB0D,CAhBnE,IAAIe,aAAevB,OAAA,CAAQ,2CAAR,CAAnB,CAEIc,oBAAsBd,OAAA,CAAQ,sDAAR,CAF1B,CAIIe,SAAWA,QAAiB,CAACY,CAAD,CAAIC,CAAJ,CAAO,CACrC,MAAOD,EAAP,GAAaC,CADwB,CAJvC,CAOIZ,SAAWA,QAAiB,CAACW,CAAD,CAAI,CAClC,MAAO,CAAC,CAACA,CADyB,CAPpC,CAUIE,YAAc,EA2ClB5B,OAAAC,QAAA,CAXA4B,QAAgC,CAACzB,KAAD,CAAQ,CACtC,IAAIC,UAAYD,KAAA0B,iBAAA,EAAArB,IAAA,CAA6B,QAAS,CAACsB,CAAD,CAAI,CACxD,MAAOA,EAAAC,SAAA,EADiD,CAA1C,CAAApB,OAAA,EAAhB,CAGIL,OAASF,SAAA4B,QAAA,EAAAC,MAAA,EAAAzB,IAAA,CAAgC,QAAS,CAACC,KAAD,CAAQ,CAC5D,MAAOP,yBAAA,CAAyBC,KAAzB,CAAgCC,SAAhC,CAA2CK,KAA3C,CADqD,CAAjD,CAIb,OAAOyB,MAAAC,UAAAC,OAAAC,MAAA,CAA6BV,WAA7B;AAA0CrB,MAAAgC,KAAA,EAA1C,CAR+B,CA1DkG;\",\n\"sources\":[\"node_modules/draft-js/lib/encodeInlineStyleRanges.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$encodeInlineStyleRanges\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule encodeInlineStyleRanges\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar UnicodeUtils = require('fbjs/lib/UnicodeUtils');\\n\\nvar findRangesImmutable = require('./findRangesImmutable');\\n\\nvar areEqual = function areEqual(a, b) {\\n  return a === b;\\n};\\nvar isTruthy = function isTruthy(a) {\\n  return !!a;\\n};\\nvar EMPTY_ARRAY = [];\\n\\n/**\\n * Helper function for getting encoded styles for each inline style. Convert\\n * to UTF-8 character counts for storage.\\n */\\nfunction getEncodedInlinesForType(block, styleList, styleToEncode) {\\n  var ranges = [];\\n\\n  // Obtain an array with ranges for only the specified style.\\n  var filteredInlines = styleList.map(function (style) {\\n    return style.has(styleToEncode);\\n  }).toList();\\n\\n  findRangesImmutable(filteredInlines, areEqual,\\n  // We only want to keep ranges with nonzero style values.\\n  isTruthy, function (start, end) {\\n    var text = block.getText();\\n    ranges.push({\\n      offset: UnicodeUtils.strlen(text.slice(0, start)),\\n      length: UnicodeUtils.strlen(text.slice(start, end)),\\n      style: styleToEncode\\n    });\\n  });\\n\\n  return ranges;\\n}\\n\\n/*\\n * Retrieve the encoded arrays of inline styles, with each individual style\\n * treated separately.\\n */\\nfunction encodeInlineStyleRanges(block) {\\n  var styleList = block.getCharacterList().map(function (c) {\\n    return c.getStyle();\\n  }).toList();\\n  var ranges = styleList.flatten().toSet().map(function (style) {\\n    return getEncodedInlinesForType(block, styleList, style);\\n  });\\n\\n  return Array.prototype.concat.apply(EMPTY_ARRAY, ranges.toJS());\\n}\\n\\nmodule.exports = encodeInlineStyleRanges;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"getEncodedInlinesForType\",\"block\",\"styleList\",\"styleToEncode\",\"ranges\",\"filteredInlines\",\"map\",\"style\",\"has\",\"toList\",\"findRangesImmutable\",\"areEqual\",\"isTruthy\",\"start\",\"end\",\"text\",\"getText\",\"push\",\"offset\",\"UnicodeUtils\",\"strlen\",\"slice\",\"length\",\"a\",\"b\",\"EMPTY_ARRAY\",\"encodeInlineStyleRanges\",\"getCharacterList\",\"c\",\"getStyle\",\"flatten\",\"toSet\",\"Array\",\"prototype\",\"concat\",\"apply\",\"toJS\"]\n}\n"]