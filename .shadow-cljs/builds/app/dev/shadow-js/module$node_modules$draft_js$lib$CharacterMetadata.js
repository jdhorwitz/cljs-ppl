["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/CharacterMetadata.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$CharacterMetadata=function(global,process,require,module,exports,shadow$shims){function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}});superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,\nsuperClass):subClass.__proto__=superClass)}process=require(\"module$node_modules$immutable$dist$immutable\");var Map=process.Map;global=process.OrderedSet;process=process.Record;var EMPTY_SET=global();global={style:EMPTY_SET,entity:null};process=function(_CharacterMetadataRec){function CharacterMetadata(){if(!(this instanceof CharacterMetadata))throw new TypeError(\"Cannot call a class as a function\");var call=_CharacterMetadataRec.apply(this,arguments);if(!this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nreturn!call||\"object\"!==typeof call&&\"function\"!==typeof call?this:call}_inherits(CharacterMetadata,_CharacterMetadataRec);CharacterMetadata.prototype.getStyle=function(){return this.get(\"style\")};CharacterMetadata.prototype.getEntity=function(){return this.get(\"entity\")};CharacterMetadata.prototype.hasStyle=function(style){return this.getStyle().includes(style)};CharacterMetadata.applyStyle=function(record,style){record=record.set(\"style\",record.getStyle().add(style));return CharacterMetadata.create(record)};\nCharacterMetadata.removeStyle=function(record,style){record=record.set(\"style\",record.getStyle().remove(style));return CharacterMetadata.create(record)};CharacterMetadata.applyEntity=function(record,entityKey){record=record.getEntity()===entityKey?record:record.set(\"entity\",entityKey);return CharacterMetadata.create(record)};CharacterMetadata.create=function(config){if(!config)return EMPTY;config=Map({style:EMPTY_SET,entity:null}).merge(config);var existing=pool.get(config);if(existing)return existing;\nexisting=new CharacterMetadata(config);pool=pool.set(config,existing);return existing};return CharacterMetadata}(process(global));var EMPTY=new process,pool=Map([[Map(global),EMPTY]]);process.EMPTY=EMPTY;module.exports=process}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$CharacterMetadata\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CharacterMetadata\n * @format\n * \n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = require('immutable'),\n    Map = _require.Map,\n    OrderedSet = _require.OrderedSet,\n    Record = _require.Record;\n\n// Immutable.map is typed such that the value for every key in the map\n// must be the same type\n\n\nvar EMPTY_SET = OrderedSet();\n\nvar defaultRecord = {\n  style: EMPTY_SET,\n  entity: null\n};\n\nvar CharacterMetadataRecord = Record(defaultRecord);\n\nvar CharacterMetadata = function (_CharacterMetadataRec) {\n  _inherits(CharacterMetadata, _CharacterMetadataRec);\n\n  function CharacterMetadata() {\n    _classCallCheck(this, CharacterMetadata);\n\n    return _possibleConstructorReturn(this, _CharacterMetadataRec.apply(this, arguments));\n  }\n\n  CharacterMetadata.prototype.getStyle = function getStyle() {\n    return this.get('style');\n  };\n\n  CharacterMetadata.prototype.getEntity = function getEntity() {\n    return this.get('entity');\n  };\n\n  CharacterMetadata.prototype.hasStyle = function hasStyle(style) {\n    return this.getStyle().includes(style);\n  };\n\n  CharacterMetadata.applyStyle = function applyStyle(record, style) {\n    var withStyle = record.set('style', record.getStyle().add(style));\n    return CharacterMetadata.create(withStyle);\n  };\n\n  CharacterMetadata.removeStyle = function removeStyle(record, style) {\n    var withoutStyle = record.set('style', record.getStyle().remove(style));\n    return CharacterMetadata.create(withoutStyle);\n  };\n\n  CharacterMetadata.applyEntity = function applyEntity(record, entityKey) {\n    var withEntity = record.getEntity() === entityKey ? record : record.set('entity', entityKey);\n    return CharacterMetadata.create(withEntity);\n  };\n\n  /**\n   * Use this function instead of the `CharacterMetadata` constructor.\n   * Since most content generally uses only a very small number of\n   * style/entity permutations, we can reuse these objects as often as\n   * possible.\n   */\n\n\n  CharacterMetadata.create = function create(config) {\n    if (!config) {\n      return EMPTY;\n    }\n\n    var defaultConfig = {\n      style: EMPTY_SET,\n      entity: null\n    };\n\n    // Fill in unspecified properties, if necessary.\n    var configMap = Map(defaultConfig).merge(config);\n\n    var existing = pool.get(configMap);\n    if (existing) {\n      return existing;\n    }\n\n    var newCharacter = new CharacterMetadata(configMap);\n    pool = pool.set(configMap, newCharacter);\n    return newCharacter;\n  };\n\n  return CharacterMetadata;\n}(CharacterMetadataRecord);\n\nvar EMPTY = new CharacterMetadata();\nvar pool = Map([[Map(defaultRecord), EMPTY]]);\n\nCharacterMetadata.EMPTY = EMPTY;\n\nmodule.exports = CharacterMetadata;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$immutable$dist$immutable"]],"~:properties",["^5",["getEntity","prototype","configurable","style","value","enumerable","applyEntity","writable","EMPTY","__proto__","hasStyle","create","applyStyle","entity","removeStyle","constructor","getStyle"]],"~:compiled-at",1532351402125,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$CharacterMetadata.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/CharacterMetadata.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$CharacterMetadata\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule CharacterMetadata\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _require = require('immutable'),\\n    Map = _require.Map,\\n    OrderedSet = _require.OrderedSet,\\n    Record = _require.Record;\\n\\n// Immutable.map is typed such that the value for every key in the map\\n// must be the same type\\n\\n\\nvar EMPTY_SET = OrderedSet();\\n\\nvar defaultRecord = {\\n  style: EMPTY_SET,\\n  entity: null\\n};\\n\\nvar CharacterMetadataRecord = Record(defaultRecord);\\n\\nvar CharacterMetadata = function (_CharacterMetadataRec) {\\n  _inherits(CharacterMetadata, _CharacterMetadataRec);\\n\\n  function CharacterMetadata() {\\n    _classCallCheck(this, CharacterMetadata);\\n\\n    return _possibleConstructorReturn(this, _CharacterMetadataRec.apply(this, arguments));\\n  }\\n\\n  CharacterMetadata.prototype.getStyle = function getStyle() {\\n    return this.get('style');\\n  };\\n\\n  CharacterMetadata.prototype.getEntity = function getEntity() {\\n    return this.get('entity');\\n  };\\n\\n  CharacterMetadata.prototype.hasStyle = function hasStyle(style) {\\n    return this.getStyle().includes(style);\\n  };\\n\\n  CharacterMetadata.applyStyle = function applyStyle(record, style) {\\n    var withStyle = record.set('style', record.getStyle().add(style));\\n    return CharacterMetadata.create(withStyle);\\n  };\\n\\n  CharacterMetadata.removeStyle = function removeStyle(record, style) {\\n    var withoutStyle = record.set('style', record.getStyle().remove(style));\\n    return CharacterMetadata.create(withoutStyle);\\n  };\\n\\n  CharacterMetadata.applyEntity = function applyEntity(record, entityKey) {\\n    var withEntity = record.getEntity() === entityKey ? record : record.set('entity', entityKey);\\n    return CharacterMetadata.create(withEntity);\\n  };\\n\\n  /**\\n   * Use this function instead of the `CharacterMetadata` constructor.\\n   * Since most content generally uses only a very small number of\\n   * style/entity permutations, we can reuse these objects as often as\\n   * possible.\\n   */\\n\\n\\n  CharacterMetadata.create = function create(config) {\\n    if (!config) {\\n      return EMPTY;\\n    }\\n\\n    var defaultConfig = {\\n      style: EMPTY_SET,\\n      entity: null\\n    };\\n\\n    // Fill in unspecified properties, if necessary.\\n    var configMap = Map(defaultConfig).merge(config);\\n\\n    var existing = pool.get(configMap);\\n    if (existing) {\\n      return existing;\\n    }\\n\\n    var newCharacter = new CharacterMetadata(configMap);\\n    pool = pool.set(configMap, newCharacter);\\n    return newCharacter;\\n  };\\n\\n  return CharacterMetadata;\\n}(CharacterMetadataRecord);\\n\\nvar EMPTY = new CharacterMetadata();\\nvar pool = Map([[Map(defaultRecord), EMPTY]]);\\n\\nCharacterMetadata.EMPTY = EMPTY;\\n\\nmodule.exports = CharacterMetadata;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"prototype\",\"Object\",\"create\",\"constructor\",\"value\",\"enumerable\",\"writable\",\"configurable\",\"setPrototypeOf\",\"__proto__\",\"_require\",\"Map\",\"OrderedSet\",\"Record\",\"EMPTY_SET\",\"defaultRecord\",\"style\",\"entity\",\"CharacterMetadata\",\"_CharacterMetadataRec\",\"instance\",\"apply\",\"arguments\",\"self\",\"ReferenceError\",\"call\",\"getStyle\",\"CharacterMetadata.prototype.getStyle\",\"get\",\"getEntity\",\"CharacterMetadata.prototype.getEntity\",\"hasStyle\",\"CharacterMetadata.prototype.hasStyle\",\"includes\",\"applyStyle\",\"CharacterMetadata.applyStyle\",\"record\",\"withStyle\",\"set\",\"add\",\"removeStyle\",\"CharacterMetadata.removeStyle\",\"withoutStyle\",\"remove\",\"applyEntity\",\"CharacterMetadata.applyEntity\",\"entityKey\",\"withEntity\",\"CharacterMetadata.create\",\"config\",\"EMPTY\",\"configMap\",\"defaultConfig\",\"merge\",\"existing\",\"pool\",\"newCharacter\",\"CharacterMetadataRecord\"]\n}\n"]