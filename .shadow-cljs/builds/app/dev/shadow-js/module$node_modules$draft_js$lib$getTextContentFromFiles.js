["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/getTextContentFromFiles.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$getTextContentFromFiles=function(global,process,require,module,exports,shadow$shims){function readFile(file,callback){if(global.FileReader&&(!file.type||file.type in TEXT_TYPES))if(\"\"===file.type){var contents=\"\";TEXT_CLIPPING_REGEX.test(file.name)&&(contents=file.name.replace(TEXT_CLIPPING_REGEX,\"\"));callback(contents)}else{var reader=new FileReader;reader.onload=function(){var result=reader.result;\"string\"!==typeof result?invariant(!1,'We should be calling \"FileReader.readAsText\" which returns a string'):\nvoid 0;callback(result)};reader.onerror=function(){callback(\"\")};reader.readAsText(file)}else callback(\"\")}var invariant=require(\"module$node_modules$fbjs$lib$invariant\"),TEXT_CLIPPING_REGEX=/\\.textClipping$/,TEXT_TYPES={\"text/plain\":!0,\"text/html\":!0,\"text/rtf\":!0};module.exports=function(files,callback){var readCount=0,results=[];files.forEach(function(file){readFile(file,function(text){readCount++;text&&results.push(text.slice(0,5E3));readCount==files.length&&callback(results.join(\"\\r\"))})})}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$getTextContentFromFiles\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentFromFiles\n * @format\n * \n */\n\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar TEXT_CLIPPING_REGEX = /\\.textClipping$/;\n\nvar TEXT_TYPES = {\n  'text/plain': true,\n  'text/html': true,\n  'text/rtf': true\n};\n\n// Somewhat arbitrary upper bound on text size. Let's not lock up the browser.\nvar TEXT_SIZE_UPPER_BOUND = 5000;\n\n/**\n * Extract the text content from a file list.\n */\nfunction getTextContentFromFiles(files, callback) {\n  var readCount = 0;\n  var results = [];\n  files.forEach(function ( /*blob*/file) {\n    readFile(file, function ( /*string*/text) {\n      readCount++;\n      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));\n      if (readCount == files.length) {\n        callback(results.join('\\r'));\n      }\n    });\n  });\n}\n\n/**\n * todo isaac: Do work to turn html/rtf into a content fragment.\n */\nfunction readFile(file, callback) {\n  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {\n    callback('');\n    return;\n  }\n\n  if (file.type === '') {\n    var contents = '';\n    // Special-case text clippings, which have an empty type but include\n    // `.textClipping` in the file name. `readAsText` results in an empty\n    // string for text clippings, so we force the file name to serve\n    // as the text value for the file.\n    if (TEXT_CLIPPING_REGEX.test(file.name)) {\n      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');\n    }\n    callback(contents);\n    return;\n  }\n\n  var reader = new FileReader();\n  reader.onload = function () {\n    var result = reader.result;\n    !(typeof result === 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'We should be calling \"FileReader.readAsText\" which returns a string') : invariant(false) : void 0;\n    callback(result);\n  };\n  reader.onerror = function () {\n    callback('');\n  };\n  reader.readAsText(file);\n}\n\nmodule.exports = getTextContentFromFiles;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant"]],"~:properties",["^5",["onerror","onload"]],"~:compiled-at",1532351402142,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$getTextContentFromFiles.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,yDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAiD1IC,QAASA,SAAQ,CAACC,IAAD,CAAOC,QAAP,CAAiB,CAChC,GAAKR,MAAAS,WAAL,GAA0BC,CAAAH,IAAAG,KAA1B,EAAyCH,IAAAG,KAAzC,GAAsDC,WAAtD,EAKA,GAAkB,EAAlB,GAAIJ,IAAAG,KAAJ,CAAsB,CACpB,IAAIE,SAAW,EAKXC,oBAAAC,KAAA,CAAyBP,IAAAQ,KAAzB,CAAJ,GACEH,QADF,CACaL,IAAAQ,KAAAC,QAAA,CAAkBH,mBAAlB,CAAuC,EAAvC,CADb,CAGAL,SAAA,CAASI,QAAT,CAToB,CAAtB,IAAA,CAaA,IAAIK,OAAS,IAAIR,UACjBQ,OAAAC,OAAA,CAAgBC,QAAS,EAAG,CAC1B,IAAIC,OAASH,MAAAG,OACO,SAApB,GAAE,MAAOA,OAAT,CAAwEC,SAAA,CAAU,CAAA,CAAV,CAAiB,qEAAjB,CAAxE;AAAqL,IAAK,EAC1Lb,SAAA,CAASY,MAAT,CAH0B,CAK5BH,OAAAK,QAAA,CAAiBC,QAAS,EAAG,CAC3Bf,QAAA,CAAS,EAAT,CAD2B,CAG7BS,OAAAO,WAAA,CAAkBjB,IAAlB,CAtBA,CALA,IACEC,SAAA,CAAS,EAAT,CAF8B,CAjClC,IAAIa,UAAYnB,OAAA,CAAQ,wCAAR,CAAhB,CAEIW,oBAAsB,iBAF1B,CAIIF,WAAa,CACf,aAAc,CAAA,CADC,CAEf,YAAa,CAAA,CAFE,CAGf,WAAY,CAAA,CAHG,CA4DjBR,OAAAC,QAAA,CAhDAqB,QAAgC,CAACC,KAAD,CAAQlB,QAAR,CAAkB,CAChD,IAAImB,UAAY,CAAhB,CACIC,QAAU,EACdF,MAAAG,QAAA,CAAc,QAAS,CAAUtB,IAAV,CAAgB,CACrCD,QAAA,CAASC,IAAT,CAAe,QAAS,CAAYuB,IAAZ,CAAkB,CACxCH,SAAA,EACAG,KAAA,EAAQF,OAAAG,KAAA,CAAaD,IAAAE,MAAA,CAAW,CAAX,CAXCC,GAWD,CAAb,CACJN,UAAJ,EAAiBD,KAAAQ,OAAjB,EACE1B,QAAA,CAASoB,OAAAO,KAAA,CAAa,IAAb,CAAT,CAJsC,CAA1C,CADqC,CAAvC,CAHgD,CAhCwF;\",\n\"sources\":[\"node_modules/draft-js/lib/getTextContentFromFiles.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$getTextContentFromFiles\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule getTextContentFromFiles\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\nvar TEXT_CLIPPING_REGEX = /\\\\.textClipping$/;\\n\\nvar TEXT_TYPES = {\\n  'text/plain': true,\\n  'text/html': true,\\n  'text/rtf': true\\n};\\n\\n// Somewhat arbitrary upper bound on text size. Let's not lock up the browser.\\nvar TEXT_SIZE_UPPER_BOUND = 5000;\\n\\n/**\\n * Extract the text content from a file list.\\n */\\nfunction getTextContentFromFiles(files, callback) {\\n  var readCount = 0;\\n  var results = [];\\n  files.forEach(function ( /*blob*/file) {\\n    readFile(file, function ( /*string*/text) {\\n      readCount++;\\n      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));\\n      if (readCount == files.length) {\\n        callback(results.join('\\\\r'));\\n      }\\n    });\\n  });\\n}\\n\\n/**\\n * todo isaac: Do work to turn html/rtf into a content fragment.\\n */\\nfunction readFile(file, callback) {\\n  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {\\n    callback('');\\n    return;\\n  }\\n\\n  if (file.type === '') {\\n    var contents = '';\\n    // Special-case text clippings, which have an empty type but include\\n    // `.textClipping` in the file name. `readAsText` results in an empty\\n    // string for text clippings, so we force the file name to serve\\n    // as the text value for the file.\\n    if (TEXT_CLIPPING_REGEX.test(file.name)) {\\n      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');\\n    }\\n    callback(contents);\\n    return;\\n  }\\n\\n  var reader = new FileReader();\\n  reader.onload = function () {\\n    var result = reader.result;\\n    !(typeof result === 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'We should be calling \\\"FileReader.readAsText\\\" which returns a string') : invariant(false) : void 0;\\n    callback(result);\\n  };\\n  reader.onerror = function () {\\n    callback('');\\n  };\\n  reader.readAsText(file);\\n}\\n\\nmodule.exports = getTextContentFromFiles;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"readFile\",\"file\",\"callback\",\"FileReader\",\"type\",\"TEXT_TYPES\",\"contents\",\"TEXT_CLIPPING_REGEX\",\"test\",\"name\",\"replace\",\"reader\",\"onload\",\"reader.onload\",\"result\",\"invariant\",\"onerror\",\"reader.onerror\",\"readAsText\",\"getTextContentFromFiles\",\"files\",\"readCount\",\"results\",\"forEach\",\"text\",\"push\",\"slice\",\"TEXT_SIZE_UPPER_BOUND\",\"length\",\"join\"]\n}\n"]