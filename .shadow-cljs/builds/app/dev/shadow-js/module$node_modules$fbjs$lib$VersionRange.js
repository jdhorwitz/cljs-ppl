["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/fbjs/lib/VersionRange.js"],"~:js","shadow$provide.module$node_modules$fbjs$lib$VersionRange=function(global,process,require,module,exports,shadow$shims){function checkOrExpression(range$jscomp$0,version){range$jscomp$0=range$jscomp$0.split(orRegex);if(1<range$jscomp$0.length)return range$jscomp$0.some(function(range){return VersionRange.contains(range,version)});range$jscomp$0=range$jscomp$0[0].trim();return checkRangeExpression(range$jscomp$0,version)}function checkRangeExpression(range,version){var expressions=range.split(rangeRegex);\n0<expressions.length&&2>=expressions.length?void 0:invariant(!1,'the \"-\" operator expects exactly 2 operands');if(1===expressions.length)return checkSimpleExpression(expressions[0],version);range=expressions[0];expressions=expressions[1];getModifierAndComponents(range).modifier||getModifierAndComponents(expressions).modifier?invariant(!1,'operands to the \"-\" operator must be simple (no modifiers)'):void 0;return checkSimpleExpression(\"\\x3e\\x3d\"+range,version)&&checkSimpleExpression(\"\\x3c\\x3d\"+expressions,\nversion)}function checkSimpleExpression(range,version){range=range.trim();if(\"\"===range)return!0;version=version.split(componentRegex);range=getModifierAndComponents(range);var rangeComponents=range.rangeComponents;switch(range.modifier){case \"\\x3c\":return-1===compareComponents(version,rangeComponents);case \"\\x3c\\x3d\":return version=compareComponents(version,rangeComponents),-1===version||0===version;case \"\\x3e\\x3d\":return checkGreaterThanOrEqual(version,rangeComponents);case \"\\x3e\":return 1===compareComponents(version,\nrangeComponents);case \"~\":case \"~\\x3e\":range=rangeComponents.slice();rangeComponents=rangeComponents.slice();1<rangeComponents.length&&rangeComponents.pop();var lastIndex=rangeComponents.length-1,numeric=parseInt(rangeComponents[lastIndex],10);isNumber(numeric)&&(rangeComponents[lastIndex]=numeric+1+\"\");return checkGreaterThanOrEqual(version,range)&&-1===compareComponents(version,rangeComponents);default:return 0===compareComponents(version,rangeComponents)}}function checkGreaterThanOrEqual(a,b){a=\ncompareComponents(a,b);return 1===a||0===a}function getModifierAndComponents(range){range=range.split(componentRegex);var matches=range[0].match(modifierRegex);matches?void 0:invariant(!1,\"expected regex to match but it did not\");return{modifier:matches[1],rangeComponents:[matches[2]].concat(range.slice(1))}}function isNumber(number){return!isNaN(number)&&isFinite(number)}function zeroPad(array,length){for(var i=array.length;i<length;i++)array[i]=\"0\"}function compare(a,b){typeof a!==typeof b?invariant(!1,\n'\"a\" and \"b\" must be of the same type'):void 0;return a>b?1:a<b?-1:0}function compareComponents(a,b$jscomp$0){a=a.slice();b$jscomp$0=b$jscomp$0.slice();zeroPad(a,b$jscomp$0.length);for(var i=0;i<b$jscomp$0.length;i++){var matches=b$jscomp$0[i].match(/^[x*]$/i);if(matches&&(b$jscomp$0[i]=a[i]=\"0\",\"*\"===matches[0]&&i===b$jscomp$0.length-1))for(matches=i;matches<a.length;matches++)a[matches]=\"0\"}zeroPad(b$jscomp$0,a.length);a=[a,b$jscomp$0];b$jscomp$0=a[0];a=a[1];for(i=0;i<a.length;i++){matches=b$jscomp$0[i];\nvar b=a[i],aPrefix=matches.match(numericRegex)[1],bPrefix=b.match(numericRegex)[1];aPrefix=parseInt(aPrefix,10);bPrefix=parseInt(bPrefix,10);matches=isNumber(aPrefix)&&isNumber(bPrefix)&&aPrefix!==bPrefix?compare(aPrefix,bPrefix):compare(matches,b);if(matches)return matches}return 0}var invariant=require(\"module$node_modules$fbjs$lib$invariant\"),componentRegex=/\\./,orRegex=/\\|\\|/,rangeRegex=/\\s+\\-\\s+/,modifierRegex=/^(<=|<|=|>=|~>|~|>|)?\\s*(.+)/,numericRegex=/^(\\d*)(.*)/,VersionRange={contains:function(range,\nversion){return checkOrExpression(range.trim(),version.trim())}};module.exports=VersionRange}","~:source","shadow$provide[\"module$node_modules$fbjs$lib$VersionRange\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar invariant = require('./invariant');\n\nvar componentRegex = /\\./;\nvar orRegex = /\\|\\|/;\nvar rangeRegex = /\\s+\\-\\s+/;\nvar modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\\s*(.+)/;\nvar numericRegex = /^(\\d*)(.*)/;\n\n/**\n * Splits input `range` on \"||\" and returns true if any subrange matches\n * `version`.\n *\n * @param {string} range\n * @param {string} version\n * @returns {boolean}\n */\nfunction checkOrExpression(range, version) {\n  var expressions = range.split(orRegex);\n\n  if (expressions.length > 1) {\n    return expressions.some(function (range) {\n      return VersionRange.contains(range, version);\n    });\n  } else {\n    range = expressions[0].trim();\n    return checkRangeExpression(range, version);\n  }\n}\n\n/**\n * Splits input `range` on \" - \" (the surrounding whitespace is required) and\n * returns true if version falls between the two operands.\n *\n * @param {string} range\n * @param {string} version\n * @returns {boolean}\n */\nfunction checkRangeExpression(range, version) {\n  var expressions = range.split(rangeRegex);\n\n  !(expressions.length > 0 && expressions.length <= 2) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'the \"-\" operator expects exactly 2 operands') : invariant(false) : void 0;\n\n  if (expressions.length === 1) {\n    return checkSimpleExpression(expressions[0], version);\n  } else {\n    var startVersion = expressions[0],\n        endVersion = expressions[1];\n\n    !(isSimpleVersion(startVersion) && isSimpleVersion(endVersion)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'operands to the \"-\" operator must be simple (no modifiers)') : invariant(false) : void 0;\n\n    return checkSimpleExpression('>=' + startVersion, version) && checkSimpleExpression('<=' + endVersion, version);\n  }\n}\n\n/**\n * Checks if `range` matches `version`. `range` should be a \"simple\" range (ie.\n * not a compound range using the \" - \" or \"||\" operators).\n *\n * @param {string} range\n * @param {string} version\n * @returns {boolean}\n */\nfunction checkSimpleExpression(range, version) {\n  range = range.trim();\n  if (range === '') {\n    return true;\n  }\n\n  var versionComponents = version.split(componentRegex);\n\n  var _getModifierAndCompon = getModifierAndComponents(range),\n      modifier = _getModifierAndCompon.modifier,\n      rangeComponents = _getModifierAndCompon.rangeComponents;\n\n  switch (modifier) {\n    case '<':\n      return checkLessThan(versionComponents, rangeComponents);\n    case '<=':\n      return checkLessThanOrEqual(versionComponents, rangeComponents);\n    case '>=':\n      return checkGreaterThanOrEqual(versionComponents, rangeComponents);\n    case '>':\n      return checkGreaterThan(versionComponents, rangeComponents);\n    case '~':\n    case '~>':\n      return checkApproximateVersion(versionComponents, rangeComponents);\n    default:\n      return checkEqual(versionComponents, rangeComponents);\n  }\n}\n\n/**\n * Checks whether `a` is less than `b`.\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {boolean}\n */\nfunction checkLessThan(a, b) {\n  return compareComponents(a, b) === -1;\n}\n\n/**\n * Checks whether `a` is less than or equal to `b`.\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {boolean}\n */\nfunction checkLessThanOrEqual(a, b) {\n  var result = compareComponents(a, b);\n  return result === -1 || result === 0;\n}\n\n/**\n * Checks whether `a` is equal to `b`.\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {boolean}\n */\nfunction checkEqual(a, b) {\n  return compareComponents(a, b) === 0;\n}\n\n/**\n * Checks whether `a` is greater than or equal to `b`.\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {boolean}\n */\nfunction checkGreaterThanOrEqual(a, b) {\n  var result = compareComponents(a, b);\n  return result === 1 || result === 0;\n}\n\n/**\n * Checks whether `a` is greater than `b`.\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {boolean}\n */\nfunction checkGreaterThan(a, b) {\n  return compareComponents(a, b) === 1;\n}\n\n/**\n * Checks whether `a` is \"reasonably close\" to `b` (as described in\n * https://www.npmjs.org/doc/misc/semver.html). For example, if `b` is \"1.3.1\"\n * then \"reasonably close\" is defined as \">= 1.3.1 and < 1.4\".\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {boolean}\n */\nfunction checkApproximateVersion(a, b) {\n  var lowerBound = b.slice();\n  var upperBound = b.slice();\n\n  if (upperBound.length > 1) {\n    upperBound.pop();\n  }\n  var lastIndex = upperBound.length - 1;\n  var numeric = parseInt(upperBound[lastIndex], 10);\n  if (isNumber(numeric)) {\n    upperBound[lastIndex] = numeric + 1 + '';\n  }\n\n  return checkGreaterThanOrEqual(a, lowerBound) && checkLessThan(a, upperBound);\n}\n\n/**\n * Extracts the optional modifier (<, <=, =, >=, >, ~, ~>) and version\n * components from `range`.\n *\n * For example, given `range` \">= 1.2.3\" returns an object with a `modifier` of\n * `\">=\"` and `components` of `[1, 2, 3]`.\n *\n * @param {string} range\n * @returns {object}\n */\nfunction getModifierAndComponents(range) {\n  var rangeComponents = range.split(componentRegex);\n  var matches = rangeComponents[0].match(modifierRegex);\n  !matches ? process.env.NODE_ENV !== 'production' ? invariant(false, 'expected regex to match but it did not') : invariant(false) : void 0;\n\n  return {\n    modifier: matches[1],\n    rangeComponents: [matches[2]].concat(rangeComponents.slice(1))\n  };\n}\n\n/**\n * Determines if `number` is a number.\n *\n * @param {mixed} number\n * @returns {boolean}\n */\nfunction isNumber(number) {\n  return !isNaN(number) && isFinite(number);\n}\n\n/**\n * Tests whether `range` is a \"simple\" version number without any modifiers\n * (\">\", \"~\" etc).\n *\n * @param {string} range\n * @returns {boolean}\n */\nfunction isSimpleVersion(range) {\n  return !getModifierAndComponents(range).modifier;\n}\n\n/**\n * Zero-pads array `array` until it is at least `length` long.\n *\n * @param {array} array\n * @param {number} length\n */\nfunction zeroPad(array, length) {\n  for (var i = array.length; i < length; i++) {\n    array[i] = '0';\n  }\n}\n\n/**\n * Normalizes `a` and `b` in preparation for comparison by doing the following:\n *\n * - zero-pads `a` and `b`\n * - marks any \"x\", \"X\" or \"*\" component in `b` as equivalent by zero-ing it out\n *   in both `a` and `b`\n * - marks any final \"*\" component in `b` as a greedy wildcard by zero-ing it\n *   and all of its successors in `a`\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {array<array<string>>}\n */\nfunction normalizeVersions(a, b) {\n  a = a.slice();\n  b = b.slice();\n\n  zeroPad(a, b.length);\n\n  // mark \"x\" and \"*\" components as equal\n  for (var i = 0; i < b.length; i++) {\n    var matches = b[i].match(/^[x*]$/i);\n    if (matches) {\n      b[i] = a[i] = '0';\n\n      // final \"*\" greedily zeros all remaining components\n      if (matches[0] === '*' && i === b.length - 1) {\n        for (var j = i; j < a.length; j++) {\n          a[j] = '0';\n        }\n      }\n    }\n  }\n\n  zeroPad(b, a.length);\n\n  return [a, b];\n}\n\n/**\n * Returns the numerical -- not the lexicographical -- ordering of `a` and `b`.\n *\n * For example, `10-alpha` is greater than `2-beta`.\n *\n * @param {string} a\n * @param {string} b\n * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,\n * or greater than `b`, respectively\n */\nfunction compareNumeric(a, b) {\n  var aPrefix = a.match(numericRegex)[1];\n  var bPrefix = b.match(numericRegex)[1];\n  var aNumeric = parseInt(aPrefix, 10);\n  var bNumeric = parseInt(bPrefix, 10);\n\n  if (isNumber(aNumeric) && isNumber(bNumeric) && aNumeric !== bNumeric) {\n    return compare(aNumeric, bNumeric);\n  } else {\n    return compare(a, b);\n  }\n}\n\n/**\n * Returns the ordering of `a` and `b`.\n *\n * @param {string|number} a\n * @param {string|number} b\n * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,\n * or greater than `b`, respectively\n */\nfunction compare(a, b) {\n  !(typeof a === typeof b) ? process.env.NODE_ENV !== 'production' ? invariant(false, '\"a\" and \"b\" must be of the same type') : invariant(false) : void 0;\n\n  if (a > b) {\n    return 1;\n  } else if (a < b) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\n/**\n * Compares arrays of version components.\n *\n * @param {array<string>} a\n * @param {array<string>} b\n * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,\n * or greater than `b`, respectively\n */\nfunction compareComponents(a, b) {\n  var _normalizeVersions = normalizeVersions(a, b),\n      aNormalized = _normalizeVersions[0],\n      bNormalized = _normalizeVersions[1];\n\n  for (var i = 0; i < bNormalized.length; i++) {\n    var result = compareNumeric(aNormalized[i], bNormalized[i]);\n    if (result) {\n      return result;\n    }\n  }\n\n  return 0;\n}\n\nvar VersionRange = {\n  /**\n   * Checks whether `version` satisfies the `range` specification.\n   *\n   * We support a subset of the expressions defined in\n   * https://www.npmjs.org/doc/misc/semver.html:\n   *\n   *    version   Must match version exactly\n   *    =version  Same as just version\n   *    >version  Must be greater than version\n   *    >=version Must be greater than or equal to version\n   *    <version  Must be less than version\n   *    <=version Must be less than or equal to version\n   *    ~version  Must be at least version, but less than the next significant\n   *              revision above version:\n   *              \"~1.2.3\" is equivalent to \">= 1.2.3 and < 1.3\"\n   *    ~>version Equivalent to ~version\n   *    1.2.x     Must match \"1.2.x\", where \"x\" is a wildcard that matches\n   *              anything\n   *    1.2.*     Similar to \"1.2.x\", but \"*\" in the trailing position is a\n   *              \"greedy\" wildcard, so will match any number of additional\n   *              components:\n   *              \"1.2.*\" will match \"1.2.1\", \"1.2.1.1\", \"1.2.1.1.1\" etc\n   *    *         Any version\n   *    \"\"        (Empty string) Same as *\n   *    v1 - v2   Equivalent to \">= v1 and <= v2\"\n   *    r1 || r2  Passes if either r1 or r2 are satisfied\n   *\n   * @param {string} range\n   * @param {string} version\n   * @returns {boolean}\n   */\n  contains: function contains(range, version) {\n    return checkOrExpression(range.trim(), version.trim());\n  }\n};\n\nmodule.exports = VersionRange;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant"]],"~:properties",["^5",["contains","modifier","rangeComponents"]],"~:compiled-at",1532351402138,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$fbjs$lib$VersionRange.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/fbjs/lib/VersionRange.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$fbjs$lib$VersionRange\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n *\\n */\\n\\n'use strict';\\n\\nvar invariant = require('./invariant');\\n\\nvar componentRegex = /\\\\./;\\nvar orRegex = /\\\\|\\\\|/;\\nvar rangeRegex = /\\\\s+\\\\-\\\\s+/;\\nvar modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\\\\s*(.+)/;\\nvar numericRegex = /^(\\\\d*)(.*)/;\\n\\n/**\\n * Splits input `range` on \\\"||\\\" and returns true if any subrange matches\\n * `version`.\\n *\\n * @param {string} range\\n * @param {string} version\\n * @returns {boolean}\\n */\\nfunction checkOrExpression(range, version) {\\n  var expressions = range.split(orRegex);\\n\\n  if (expressions.length > 1) {\\n    return expressions.some(function (range) {\\n      return VersionRange.contains(range, version);\\n    });\\n  } else {\\n    range = expressions[0].trim();\\n    return checkRangeExpression(range, version);\\n  }\\n}\\n\\n/**\\n * Splits input `range` on \\\" - \\\" (the surrounding whitespace is required) and\\n * returns true if version falls between the two operands.\\n *\\n * @param {string} range\\n * @param {string} version\\n * @returns {boolean}\\n */\\nfunction checkRangeExpression(range, version) {\\n  var expressions = range.split(rangeRegex);\\n\\n  !(expressions.length > 0 && expressions.length <= 2) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'the \\\"-\\\" operator expects exactly 2 operands') : invariant(false) : void 0;\\n\\n  if (expressions.length === 1) {\\n    return checkSimpleExpression(expressions[0], version);\\n  } else {\\n    var startVersion = expressions[0],\\n        endVersion = expressions[1];\\n\\n    !(isSimpleVersion(startVersion) && isSimpleVersion(endVersion)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'operands to the \\\"-\\\" operator must be simple (no modifiers)') : invariant(false) : void 0;\\n\\n    return checkSimpleExpression('>=' + startVersion, version) && checkSimpleExpression('<=' + endVersion, version);\\n  }\\n}\\n\\n/**\\n * Checks if `range` matches `version`. `range` should be a \\\"simple\\\" range (ie.\\n * not a compound range using the \\\" - \\\" or \\\"||\\\" operators).\\n *\\n * @param {string} range\\n * @param {string} version\\n * @returns {boolean}\\n */\\nfunction checkSimpleExpression(range, version) {\\n  range = range.trim();\\n  if (range === '') {\\n    return true;\\n  }\\n\\n  var versionComponents = version.split(componentRegex);\\n\\n  var _getModifierAndCompon = getModifierAndComponents(range),\\n      modifier = _getModifierAndCompon.modifier,\\n      rangeComponents = _getModifierAndCompon.rangeComponents;\\n\\n  switch (modifier) {\\n    case '<':\\n      return checkLessThan(versionComponents, rangeComponents);\\n    case '<=':\\n      return checkLessThanOrEqual(versionComponents, rangeComponents);\\n    case '>=':\\n      return checkGreaterThanOrEqual(versionComponents, rangeComponents);\\n    case '>':\\n      return checkGreaterThan(versionComponents, rangeComponents);\\n    case '~':\\n    case '~>':\\n      return checkApproximateVersion(versionComponents, rangeComponents);\\n    default:\\n      return checkEqual(versionComponents, rangeComponents);\\n  }\\n}\\n\\n/**\\n * Checks whether `a` is less than `b`.\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {boolean}\\n */\\nfunction checkLessThan(a, b) {\\n  return compareComponents(a, b) === -1;\\n}\\n\\n/**\\n * Checks whether `a` is less than or equal to `b`.\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {boolean}\\n */\\nfunction checkLessThanOrEqual(a, b) {\\n  var result = compareComponents(a, b);\\n  return result === -1 || result === 0;\\n}\\n\\n/**\\n * Checks whether `a` is equal to `b`.\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {boolean}\\n */\\nfunction checkEqual(a, b) {\\n  return compareComponents(a, b) === 0;\\n}\\n\\n/**\\n * Checks whether `a` is greater than or equal to `b`.\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {boolean}\\n */\\nfunction checkGreaterThanOrEqual(a, b) {\\n  var result = compareComponents(a, b);\\n  return result === 1 || result === 0;\\n}\\n\\n/**\\n * Checks whether `a` is greater than `b`.\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {boolean}\\n */\\nfunction checkGreaterThan(a, b) {\\n  return compareComponents(a, b) === 1;\\n}\\n\\n/**\\n * Checks whether `a` is \\\"reasonably close\\\" to `b` (as described in\\n * https://www.npmjs.org/doc/misc/semver.html). For example, if `b` is \\\"1.3.1\\\"\\n * then \\\"reasonably close\\\" is defined as \\\">= 1.3.1 and < 1.4\\\".\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {boolean}\\n */\\nfunction checkApproximateVersion(a, b) {\\n  var lowerBound = b.slice();\\n  var upperBound = b.slice();\\n\\n  if (upperBound.length > 1) {\\n    upperBound.pop();\\n  }\\n  var lastIndex = upperBound.length - 1;\\n  var numeric = parseInt(upperBound[lastIndex], 10);\\n  if (isNumber(numeric)) {\\n    upperBound[lastIndex] = numeric + 1 + '';\\n  }\\n\\n  return checkGreaterThanOrEqual(a, lowerBound) && checkLessThan(a, upperBound);\\n}\\n\\n/**\\n * Extracts the optional modifier (<, <=, =, >=, >, ~, ~>) and version\\n * components from `range`.\\n *\\n * For example, given `range` \\\">= 1.2.3\\\" returns an object with a `modifier` of\\n * `\\\">=\\\"` and `components` of `[1, 2, 3]`.\\n *\\n * @param {string} range\\n * @returns {object}\\n */\\nfunction getModifierAndComponents(range) {\\n  var rangeComponents = range.split(componentRegex);\\n  var matches = rangeComponents[0].match(modifierRegex);\\n  !matches ? process.env.NODE_ENV !== 'production' ? invariant(false, 'expected regex to match but it did not') : invariant(false) : void 0;\\n\\n  return {\\n    modifier: matches[1],\\n    rangeComponents: [matches[2]].concat(rangeComponents.slice(1))\\n  };\\n}\\n\\n/**\\n * Determines if `number` is a number.\\n *\\n * @param {mixed} number\\n * @returns {boolean}\\n */\\nfunction isNumber(number) {\\n  return !isNaN(number) && isFinite(number);\\n}\\n\\n/**\\n * Tests whether `range` is a \\\"simple\\\" version number without any modifiers\\n * (\\\">\\\", \\\"~\\\" etc).\\n *\\n * @param {string} range\\n * @returns {boolean}\\n */\\nfunction isSimpleVersion(range) {\\n  return !getModifierAndComponents(range).modifier;\\n}\\n\\n/**\\n * Zero-pads array `array` until it is at least `length` long.\\n *\\n * @param {array} array\\n * @param {number} length\\n */\\nfunction zeroPad(array, length) {\\n  for (var i = array.length; i < length; i++) {\\n    array[i] = '0';\\n  }\\n}\\n\\n/**\\n * Normalizes `a` and `b` in preparation for comparison by doing the following:\\n *\\n * - zero-pads `a` and `b`\\n * - marks any \\\"x\\\", \\\"X\\\" or \\\"*\\\" component in `b` as equivalent by zero-ing it out\\n *   in both `a` and `b`\\n * - marks any final \\\"*\\\" component in `b` as a greedy wildcard by zero-ing it\\n *   and all of its successors in `a`\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {array<array<string>>}\\n */\\nfunction normalizeVersions(a, b) {\\n  a = a.slice();\\n  b = b.slice();\\n\\n  zeroPad(a, b.length);\\n\\n  // mark \\\"x\\\" and \\\"*\\\" components as equal\\n  for (var i = 0; i < b.length; i++) {\\n    var matches = b[i].match(/^[x*]$/i);\\n    if (matches) {\\n      b[i] = a[i] = '0';\\n\\n      // final \\\"*\\\" greedily zeros all remaining components\\n      if (matches[0] === '*' && i === b.length - 1) {\\n        for (var j = i; j < a.length; j++) {\\n          a[j] = '0';\\n        }\\n      }\\n    }\\n  }\\n\\n  zeroPad(b, a.length);\\n\\n  return [a, b];\\n}\\n\\n/**\\n * Returns the numerical -- not the lexicographical -- ordering of `a` and `b`.\\n *\\n * For example, `10-alpha` is greater than `2-beta`.\\n *\\n * @param {string} a\\n * @param {string} b\\n * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,\\n * or greater than `b`, respectively\\n */\\nfunction compareNumeric(a, b) {\\n  var aPrefix = a.match(numericRegex)[1];\\n  var bPrefix = b.match(numericRegex)[1];\\n  var aNumeric = parseInt(aPrefix, 10);\\n  var bNumeric = parseInt(bPrefix, 10);\\n\\n  if (isNumber(aNumeric) && isNumber(bNumeric) && aNumeric !== bNumeric) {\\n    return compare(aNumeric, bNumeric);\\n  } else {\\n    return compare(a, b);\\n  }\\n}\\n\\n/**\\n * Returns the ordering of `a` and `b`.\\n *\\n * @param {string|number} a\\n * @param {string|number} b\\n * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,\\n * or greater than `b`, respectively\\n */\\nfunction compare(a, b) {\\n  !(typeof a === typeof b) ? process.env.NODE_ENV !== 'production' ? invariant(false, '\\\"a\\\" and \\\"b\\\" must be of the same type') : invariant(false) : void 0;\\n\\n  if (a > b) {\\n    return 1;\\n  } else if (a < b) {\\n    return -1;\\n  } else {\\n    return 0;\\n  }\\n}\\n\\n/**\\n * Compares arrays of version components.\\n *\\n * @param {array<string>} a\\n * @param {array<string>} b\\n * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,\\n * or greater than `b`, respectively\\n */\\nfunction compareComponents(a, b) {\\n  var _normalizeVersions = normalizeVersions(a, b),\\n      aNormalized = _normalizeVersions[0],\\n      bNormalized = _normalizeVersions[1];\\n\\n  for (var i = 0; i < bNormalized.length; i++) {\\n    var result = compareNumeric(aNormalized[i], bNormalized[i]);\\n    if (result) {\\n      return result;\\n    }\\n  }\\n\\n  return 0;\\n}\\n\\nvar VersionRange = {\\n  /**\\n   * Checks whether `version` satisfies the `range` specification.\\n   *\\n   * We support a subset of the expressions defined in\\n   * https://www.npmjs.org/doc/misc/semver.html:\\n   *\\n   *    version   Must match version exactly\\n   *    =version  Same as just version\\n   *    >version  Must be greater than version\\n   *    >=version Must be greater than or equal to version\\n   *    <version  Must be less than version\\n   *    <=version Must be less than or equal to version\\n   *    ~version  Must be at least version, but less than the next significant\\n   *              revision above version:\\n   *              \\\"~1.2.3\\\" is equivalent to \\\">= 1.2.3 and < 1.3\\\"\\n   *    ~>version Equivalent to ~version\\n   *    1.2.x     Must match \\\"1.2.x\\\", where \\\"x\\\" is a wildcard that matches\\n   *              anything\\n   *    1.2.*     Similar to \\\"1.2.x\\\", but \\\"*\\\" in the trailing position is a\\n   *              \\\"greedy\\\" wildcard, so will match any number of additional\\n   *              components:\\n   *              \\\"1.2.*\\\" will match \\\"1.2.1\\\", \\\"1.2.1.1\\\", \\\"1.2.1.1.1\\\" etc\\n   *    *         Any version\\n   *    \\\"\\\"        (Empty string) Same as *\\n   *    v1 - v2   Equivalent to \\\">= v1 and <= v2\\\"\\n   *    r1 || r2  Passes if either r1 or r2 are satisfied\\n   *\\n   * @param {string} range\\n   * @param {string} version\\n   * @returns {boolean}\\n   */\\n  contains: function contains(range, version) {\\n    return checkOrExpression(range.trim(), version.trim());\\n  }\\n};\\n\\nmodule.exports = VersionRange;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"checkOrExpression\",\"range\",\"version\",\"expressions\",\"split\",\"orRegex\",\"length\",\"some\",\"VersionRange\",\"contains\",\"trim\",\"checkRangeExpression\",\"rangeRegex\",\"invariant\",\"checkSimpleExpression\",\"startVersion\",\"endVersion\",\"getModifierAndComponents\",\"modifier\",\"versionComponents\",\"componentRegex\",\"_getModifierAndCompon\",\"rangeComponents\",\"compareComponents\",\"result\",\"checkGreaterThanOrEqual\",\"lowerBound\",\"slice\",\"upperBound\",\"pop\",\"lastIndex\",\"numeric\",\"parseInt\",\"isNumber\",\"a\",\"b\",\"matches\",\"match\",\"modifierRegex\",\"concat\",\"number\",\"isNaN\",\"isFinite\",\"zeroPad\",\"array\",\"i\",\"compare\",\"j\",\"aNormalized\",\"_normalizeVersions\",\"bNormalized\",\"aPrefix\",\"numericRegex\",\"bPrefix\",\"aNumeric\",\"bNumeric\"]\n}\n"]