["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/randomizeBlockMapKeys.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$randomizeBlockMapKeys=function(global,process,require,module,exports,shadow$shims){var ContentBlockNode=require(\"module$node_modules$draft_js$lib$ContentBlockNode\");global=require(\"module$node_modules$immutable$dist$immutable\");var generateRandomKey=require(\"module$node_modules$draft_js$lib$generateRandomKey\"),OrderedMap=global.OrderedMap,randomizeContentBlockNodeKeys=function(blockMap){var newKeysRef={},lastRootBlock=void 0;return OrderedMap(blockMap.withMutations(function(blockMapState){blockMapState.forEach(function(block,\nindex){var oldKey=block.getKey(),nextKey=block.getNextSiblingKey(),prevKey=block.getPrevSiblingKey();index=block.getChildKeys();var parentKey=block.getParentKey(),key=generateRandomKey();newKeysRef[oldKey]=key;nextKey&&(blockMapState.get(nextKey)?blockMapState.setIn([nextKey,\"prevSibling\"],key):blockMapState.setIn([oldKey,\"nextSibling\"],null));prevKey&&(blockMapState.get(prevKey)?blockMapState.setIn([prevKey,\"nextSibling\"],key):blockMapState.setIn([oldKey,\"prevSibling\"],null));parentKey&&blockMapState.get(parentKey)?\n(nextKey=blockMapState.get(parentKey).getChildKeys(),blockMapState.setIn([parentKey,\"children\"],nextKey.set(nextKey.indexOf(block.getKey()),key))):(blockMapState.setIn([oldKey,\"parent\"],null),lastRootBlock&&(blockMapState.setIn([lastRootBlock.getKey(),\"nextSibling\"],key),blockMapState.setIn([oldKey,\"prevSibling\"],newKeysRef[lastRootBlock.getKey()])),lastRootBlock=blockMapState.get(oldKey));index.forEach(function(childKey){blockMapState.get(childKey)?blockMapState.setIn([childKey,\"parent\"],key):blockMapState.setIn([oldKey,\n\"children\"],block.getChildKeys().filter(function(child){return child!==childKey}))})})}).toArray().map(function(block){return[newKeysRef[block.getKey()],block.set(\"key\",newKeysRef[block.getKey()])]}))},randomizeContentBlockKeys=function(blockMap){return OrderedMap(blockMap.toArray().map(function(block){var key=generateRandomKey();return[key,block.set(\"key\",key)]}))};module.exports=function(blockMap){return blockMap.first()instanceof ContentBlockNode?randomizeContentBlockNodeKeys(blockMap):randomizeContentBlockKeys(blockMap)}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$randomizeBlockMapKeys\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule randomizeBlockMapKeys\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar OrderedMap = Immutable.OrderedMap;\n\n\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {};\n\n  // we keep track of root blocks in order to update subsequent sibling links\n  var lastRootBlock = void 0;\n\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey();\n\n      // new key that we will use to build linking\n      var key = generateRandomKey();\n\n      // we will add it here to re-use it later\n      newKeysRef[oldKey] = key;\n\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\n\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\n\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n\n  return randomizeContentBlockNodeKeys(blockMap);\n};\n\nmodule.exports = randomizeBlockMapKeys;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$draft_js$lib$ContentBlockNode","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$draft_js$lib$generateRandomKey"]],"~:properties",["^5",[]],"~:compiled-at",1532351402127,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$randomizeBlockMapKeys.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/randomizeBlockMapKeys.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$randomizeBlockMapKeys\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule randomizeBlockMapKeys\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar ContentBlockNode = require('./ContentBlockNode');\\nvar Immutable = require('immutable');\\n\\nvar generateRandomKey = require('./generateRandomKey');\\n\\nvar OrderedMap = Immutable.OrderedMap;\\n\\n\\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\\n  var newKeysRef = {};\\n\\n  // we keep track of root blocks in order to update subsequent sibling links\\n  var lastRootBlock = void 0;\\n\\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\\n    blockMapState.forEach(function (block, index) {\\n      var oldKey = block.getKey();\\n      var nextKey = block.getNextSiblingKey();\\n      var prevKey = block.getPrevSiblingKey();\\n      var childrenKeys = block.getChildKeys();\\n      var parentKey = block.getParentKey();\\n\\n      // new key that we will use to build linking\\n      var key = generateRandomKey();\\n\\n      // we will add it here to re-use it later\\n      newKeysRef[oldKey] = key;\\n\\n      if (nextKey) {\\n        var nextBlock = blockMapState.get(nextKey);\\n        if (nextBlock) {\\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\\n        } else {\\n          // this can happen when generating random keys for fragments\\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\\n        }\\n      }\\n\\n      if (prevKey) {\\n        var prevBlock = blockMapState.get(prevKey);\\n        if (prevBlock) {\\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\\n        } else {\\n          // this can happen when generating random keys for fragments\\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\\n        }\\n      }\\n\\n      if (parentKey && blockMapState.get(parentKey)) {\\n        var parentBlock = blockMapState.get(parentKey);\\n        var parentChildrenList = parentBlock.getChildKeys();\\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\\n      } else {\\n        // blocks will then be treated as root block nodes\\n        blockMapState.setIn([oldKey, 'parent'], null);\\n\\n        if (lastRootBlock) {\\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\\n        }\\n\\n        lastRootBlock = blockMapState.get(oldKey);\\n      }\\n\\n      childrenKeys.forEach(function (childKey) {\\n        var childBlock = blockMapState.get(childKey);\\n        if (childBlock) {\\n          blockMapState.setIn([childKey, 'parent'], key);\\n        } else {\\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\\n            return child !== childKey;\\n          }));\\n        }\\n      });\\n    });\\n  }).toArray().map(function (block) {\\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\\n  }));\\n};\\n\\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\\n  return OrderedMap(blockMap.toArray().map(function (block) {\\n    var key = generateRandomKey();\\n    return [key, block.set('key', key)];\\n  }));\\n};\\n\\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\\n\\n  if (!isTreeBasedBlockMap) {\\n    return randomizeContentBlockKeys(blockMap);\\n  }\\n\\n  return randomizeContentBlockNodeKeys(blockMap);\\n};\\n\\nmodule.exports = randomizeBlockMapKeys;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"ContentBlockNode\",\"Immutable\",\"generateRandomKey\",\"OrderedMap\",\"randomizeContentBlockNodeKeys\",\"blockMap\",\"newKeysRef\",\"lastRootBlock\",\"withMutations\",\"blockMapState\",\"forEach\",\"block\",\"index\",\"oldKey\",\"getKey\",\"nextKey\",\"getNextSiblingKey\",\"prevKey\",\"getPrevSiblingKey\",\"childrenKeys\",\"getChildKeys\",\"parentKey\",\"getParentKey\",\"key\",\"get\",\"nextBlock\",\"setIn\",\"prevBlock\",\"parentChildrenList\",\"parentBlock\",\"set\",\"indexOf\",\"childKey\",\"childBlock\",\"filter\",\"child\",\"toArray\",\"map\",\"randomizeContentBlockKeys\",\"randomizeBlockMapKeys\",\"first\"]\n}\n"]