["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/getCharacterRemovalRange.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$getCharacterRemovalRange=function(global,process,require,module,exports,shadow$shims){function getEntityRemovalRange(entityMap,block,selectionState,direction,entityKey,isEntireSelectionWithinEntity,isEntityAtStart){var start=selectionState.getStartOffset(),end=selectionState.getEndOffset();entityMap=entityMap.__get(entityKey).getMutability();var sideToConsider=isEntityAtStart?start:end;if(\"MUTABLE\"===entityMap)return selectionState;entityKey=getRangesForDraftEntity(block,\nentityKey).filter(function(range){return sideToConsider<=range.end&&sideToConsider>=range.start});1!=entityKey.length?invariant(!1,\"There should only be one entity range within this removal range.\"):void 0;entityKey=entityKey[0];if(\"IMMUTABLE\"===entityMap)return selectionState.merge({anchorOffset:entityKey.start,focusOffset:entityKey.end,isBackward:!1});isEntireSelectionWithinEntity||(isEntityAtStart?end=entityKey.end:start=entityKey.start);block=DraftEntitySegments.getRemovalRange(start,end,block.getText().slice(entityKey.start,\nentityKey.end),entityKey.start,direction);return selectionState.merge({anchorOffset:block.start,focusOffset:block.end,isBackward:!1})}var DraftEntitySegments=require(\"module$node_modules$draft_js$lib$DraftEntitySegments\"),getRangesForDraftEntity=require(\"module$node_modules$draft_js$lib$getRangesForDraftEntity\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\");module.exports=function(entityMap,startBlock,endBlock,selectionState,direction){var start=selectionState.getStartOffset(),end=selectionState.getEndOffset();\nstart=startBlock.getEntityAt(start);end=endBlock.getEntityAt(end-1);if(!start&&!end)return selectionState;start&&start===end?selectionState=getEntityRemovalRange(entityMap,startBlock,selectionState,direction,start,!0,!0):start&&end?(startBlock=getEntityRemovalRange(entityMap,startBlock,selectionState,direction,start,!1,!0),entityMap=getEntityRemovalRange(entityMap,endBlock,selectionState,direction,end,!1,!1),selectionState=selectionState.merge({anchorOffset:startBlock.getAnchorOffset(),focusOffset:entityMap.getFocusOffset(),\nisBackward:!1})):start?(entityMap=getEntityRemovalRange(entityMap,startBlock,selectionState,direction,start,!1,!0),selectionState=selectionState.merge({anchorOffset:entityMap.getStartOffset(),isBackward:!1})):end&&(entityMap=getEntityRemovalRange(entityMap,endBlock,selectionState,direction,end,!1,!1),selectionState=selectionState.merge({focusOffset:entityMap.getEndOffset(),isBackward:!1}));return selectionState}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$getCharacterRemovalRange\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getCharacterRemovalRange\n * @format\n * \n */\n\n'use strict';\n\nvar DraftEntitySegments = require('./DraftEntitySegments');\n\nvar getRangesForDraftEntity = require('./getRangesForDraftEntity');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Given a SelectionState and a removal direction, determine the entire range\n * that should be removed from a ContentState. This is based on any entities\n * within the target, with their `mutability` values taken into account.\n *\n * For instance, if we are attempting to remove part of an \"immutable\" entity\n * range, the entire entity must be removed. The returned `SelectionState`\n * will be adjusted accordingly.\n */\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n  var newSelectionState = selectionState;\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n  return newSelectionState;\n}\n\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var entity = entityMap.__get(entityKey);\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end;\n\n  // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  }\n\n  // Find the entity range that overlaps with our removal range.\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n\n  var entityRange = entityRanges[0];\n\n  // For `IMMUTABLE` entity types, we will remove the entire entity range.\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  }\n\n  // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\n\nmodule.exports = getCharacterRemovalRange;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$draft_js$lib$DraftEntitySegments","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$draft_js$lib$getRangesForDraftEntity"]],"~:properties",["^5",["anchorOffset","isBackward","focusOffset"]],"~:compiled-at",1532351402127,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$getCharacterRemovalRange.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/getCharacterRemovalRange.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$getCharacterRemovalRange\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule getCharacterRemovalRange\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar DraftEntitySegments = require('./DraftEntitySegments');\\n\\nvar getRangesForDraftEntity = require('./getRangesForDraftEntity');\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Given a SelectionState and a removal direction, determine the entire range\\n * that should be removed from a ContentState. This is based on any entities\\n * within the target, with their `mutability` values taken into account.\\n *\\n * For instance, if we are attempting to remove part of an \\\"immutable\\\" entity\\n * range, the entire entity must be removed. The returned `SelectionState`\\n * will be adjusted accordingly.\\n */\\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\\n  var start = selectionState.getStartOffset();\\n  var end = selectionState.getEndOffset();\\n  var startEntityKey = startBlock.getEntityAt(start);\\n  var endEntityKey = endBlock.getEntityAt(end - 1);\\n  if (!startEntityKey && !endEntityKey) {\\n    return selectionState;\\n  }\\n  var newSelectionState = selectionState;\\n  if (startEntityKey && startEntityKey === endEntityKey) {\\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\\n  } else if (startEntityKey && endEntityKey) {\\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\\n    newSelectionState = newSelectionState.merge({\\n      anchorOffset: startSelectionState.getAnchorOffset(),\\n      focusOffset: endSelectionState.getFocusOffset(),\\n      isBackward: false\\n    });\\n  } else if (startEntityKey) {\\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\\n    newSelectionState = newSelectionState.merge({\\n      anchorOffset: _startSelectionState.getStartOffset(),\\n      isBackward: false\\n    });\\n  } else if (endEntityKey) {\\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\\n    newSelectionState = newSelectionState.merge({\\n      focusOffset: _endSelectionState.getEndOffset(),\\n      isBackward: false\\n    });\\n  }\\n  return newSelectionState;\\n}\\n\\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\\n  var start = selectionState.getStartOffset();\\n  var end = selectionState.getEndOffset();\\n  var entity = entityMap.__get(entityKey);\\n  var mutability = entity.getMutability();\\n  var sideToConsider = isEntityAtStart ? start : end;\\n\\n  // `MUTABLE` entities can just have the specified range of text removed\\n  // directly. No adjustments are needed.\\n  if (mutability === 'MUTABLE') {\\n    return selectionState;\\n  }\\n\\n  // Find the entity range that overlaps with our removal range.\\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\\n    return sideToConsider <= range.end && sideToConsider >= range.start;\\n  });\\n\\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\\n\\n  var entityRange = entityRanges[0];\\n\\n  // For `IMMUTABLE` entity types, we will remove the entire entity range.\\n  if (mutability === 'IMMUTABLE') {\\n    return selectionState.merge({\\n      anchorOffset: entityRange.start,\\n      focusOffset: entityRange.end,\\n      isBackward: false\\n    });\\n  }\\n\\n  // For `SEGMENTED` entity types, determine the appropriate segment to\\n  // remove.\\n  if (!isEntireSelectionWithinEntity) {\\n    if (isEntityAtStart) {\\n      end = entityRange.end;\\n    } else {\\n      start = entityRange.start;\\n    }\\n  }\\n\\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\\n\\n  return selectionState.merge({\\n    anchorOffset: removalRange.start,\\n    focusOffset: removalRange.end,\\n    isBackward: false\\n  });\\n}\\n\\nmodule.exports = getCharacterRemovalRange;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"getEntityRemovalRange\",\"entityMap\",\"block\",\"selectionState\",\"direction\",\"entityKey\",\"isEntireSelectionWithinEntity\",\"isEntityAtStart\",\"start\",\"getStartOffset\",\"end\",\"getEndOffset\",\"mutability\",\"__get\",\"entity\",\"getMutability\",\"sideToConsider\",\"entityRanges\",\"getRangesForDraftEntity\",\"filter\",\"range\",\"length\",\"invariant\",\"entityRange\",\"merge\",\"anchorOffset\",\"focusOffset\",\"isBackward\",\"removalRange\",\"DraftEntitySegments\",\"getRemovalRange\",\"getText\",\"slice\",\"getCharacterRemovalRange\",\"startBlock\",\"endBlock\",\"startEntityKey\",\"getEntityAt\",\"endEntityKey\",\"newSelectionState\",\"startSelectionState\",\"endSelectionState\",\"getAnchorOffset\",\"getFocusOffset\",\"_startSelectionState\",\"_endSelectionState\"]\n}\n"]