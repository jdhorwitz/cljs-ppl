["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/splitBlockInContentState.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$splitBlockInContentState=function(global,process,require,module,exports,shadow$shims){var ContentBlockNode=require(\"module$node_modules$draft_js$lib$ContentBlockNode\");global=require(\"module$node_modules$immutable$dist$immutable\");var generateRandomKey=require(\"module$node_modules$draft_js$lib$generateRandomKey\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),List=global.List,Map=global.Map,transformBlock=function(key,blockMap,func){if(key){var block=\nblockMap.get(key);block&&blockMap.set(key,func(block))}},updateBlockMapLinks=function(blockMap,originalBlock,belowBlock){return blockMap.withMutations(function(blocks){var originalBlockKey=originalBlock.getKey(),belowBlockKey=belowBlock.getKey();transformBlock(originalBlock.getParentKey(),blocks,function(block){var parentChildrenList=block.getChildKeys(),insertionIndex=parentChildrenList.indexOf(originalBlockKey)+1;parentChildrenList=parentChildrenList.toArray();parentChildrenList.splice(insertionIndex,\n0,belowBlockKey);return block.merge({children:List(parentChildrenList)})});transformBlock(originalBlock.getNextSiblingKey(),blocks,function(block){return block.merge({prevSibling:belowBlockKey})});transformBlock(originalBlockKey,blocks,function(block){return block.merge({nextSibling:belowBlockKey})});transformBlock(belowBlockKey,blocks,function(block){return block.merge({prevSibling:originalBlockKey})})})};module.exports=function(contentState,selectionState){selectionState.isCollapsed()?void 0:invariant(!1,\n\"Selection range must be collapsed.\");var key=selectionState.getAnchorKey(),offset=selectionState.getAnchorOffset(),blockMap=contentState.getBlockMap(),blockToSplit=blockMap.get(key),text=blockToSplit.getText(),chars=blockToSplit.getCharacterList(),keyBelow=generateRandomKey(),isExperimentalTreeBlock=blockToSplit instanceof ContentBlockNode,blockAbove=blockToSplit.merge({text:text.slice(0,offset),characterList:chars.slice(0,offset)});offset=blockAbove.merge({key:keyBelow,text:text.slice(offset),characterList:chars.slice(offset),\ndata:Map()});text=blockMap.toSeq().takeUntil(function(v){return v===blockToSplit});blockMap=blockMap.toSeq().skipUntil(function(v){return v===blockToSplit}).rest();key=text.concat([[key,blockAbove],[keyBelow,offset]],blockMap).toOrderedMap();isExperimentalTreeBlock&&(blockToSplit.getChildKeys().isEmpty()?void 0:invariant(!1,\"ContentBlockNode must not have children\"),key=updateBlockMapLinks(key,blockAbove,offset));return contentState.merge({blockMap:key,selectionBefore:selectionState,selectionAfter:selectionState.merge({anchorKey:keyBelow,\nanchorOffset:0,focusKey:keyBelow,focusOffset:0,isBackward:!1})})}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$splitBlockInContentState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule splitBlockInContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar generateRandomKey = require('./generateRandomKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlock, belowBlock) {\n  return blockMap.withMutations(function (blocks) {\n    var originalBlockKey = originalBlock.getKey();\n    var belowBlockKey = belowBlock.getKey();\n\n    // update block parent\n    transformBlock(originalBlock.getParentKey(), blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;\n      var newChildrenArray = parentChildrenList.toArray();\n\n      newChildrenArray.splice(insertionIndex, 0, belowBlockKey);\n\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    });\n\n    // update original next block\n    transformBlock(originalBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: belowBlockKey\n      });\n    });\n\n    // update original block\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: belowBlockKey\n      });\n    });\n\n    // update below block\n    transformBlock(belowBlockKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n  });\n};\n\nvar splitBlockInContentState = function splitBlockInContentState(contentState, selectionState) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Selection range must be collapsed.') : invariant(false) : void 0;\n\n  var key = selectionState.getAnchorKey();\n  var offset = selectionState.getAnchorOffset();\n  var blockMap = contentState.getBlockMap();\n  var blockToSplit = blockMap.get(key);\n  var text = blockToSplit.getText();\n  var chars = blockToSplit.getCharacterList();\n  var keyBelow = generateRandomKey();\n  var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode;\n\n  var blockAbove = blockToSplit.merge({\n    text: text.slice(0, offset),\n    characterList: chars.slice(0, offset)\n  });\n  var blockBelow = blockAbove.merge({\n    key: keyBelow,\n    text: text.slice(offset),\n    characterList: chars.slice(offset),\n    data: Map()\n  });\n\n  var blocksBefore = blockMap.toSeq().takeUntil(function (v) {\n    return v === blockToSplit;\n  });\n  var blocksAfter = blockMap.toSeq().skipUntil(function (v) {\n    return v === blockToSplit;\n  }).rest();\n  var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();\n\n  if (isExperimentalTreeBlock) {\n    !blockToSplit.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ContentBlockNode must not have children') : invariant(false) : void 0;\n\n    newBlocks = updateBlockMapLinks(newBlocks, blockAbove, blockBelow);\n  }\n\n  return contentState.merge({\n    blockMap: newBlocks,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: keyBelow,\n      anchorOffset: 0,\n      focusKey: keyBelow,\n      focusOffset: 0,\n      isBackward: false\n    })\n  });\n};\n\nmodule.exports = splitBlockInContentState;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$draft_js$lib$ContentBlockNode","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$draft_js$lib$generateRandomKey"]],"~:properties",["^5",["selectionBefore","anchorOffset","isBackward","selectionAfter","key","children","nextSibling","anchorKey","text","focusKey","focusOffset","characterList","blockMap","data","prevSibling"]],"~:compiled-at",1532351402129,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$splitBlockInContentState.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/splitBlockInContentState.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$splitBlockInContentState\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule splitBlockInContentState\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar ContentBlockNode = require('./ContentBlockNode');\\nvar Immutable = require('immutable');\\n\\nvar generateRandomKey = require('./generateRandomKey');\\nvar invariant = require('fbjs/lib/invariant');\\n\\nvar List = Immutable.List,\\n    Map = Immutable.Map;\\n\\n\\nvar transformBlock = function transformBlock(key, blockMap, func) {\\n  if (!key) {\\n    return;\\n  }\\n\\n  var block = blockMap.get(key);\\n\\n  if (!block) {\\n    return;\\n  }\\n\\n  blockMap.set(key, func(block));\\n};\\n\\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlock, belowBlock) {\\n  return blockMap.withMutations(function (blocks) {\\n    var originalBlockKey = originalBlock.getKey();\\n    var belowBlockKey = belowBlock.getKey();\\n\\n    // update block parent\\n    transformBlock(originalBlock.getParentKey(), blocks, function (block) {\\n      var parentChildrenList = block.getChildKeys();\\n      var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;\\n      var newChildrenArray = parentChildrenList.toArray();\\n\\n      newChildrenArray.splice(insertionIndex, 0, belowBlockKey);\\n\\n      return block.merge({\\n        children: List(newChildrenArray)\\n      });\\n    });\\n\\n    // update original next block\\n    transformBlock(originalBlock.getNextSiblingKey(), blocks, function (block) {\\n      return block.merge({\\n        prevSibling: belowBlockKey\\n      });\\n    });\\n\\n    // update original block\\n    transformBlock(originalBlockKey, blocks, function (block) {\\n      return block.merge({\\n        nextSibling: belowBlockKey\\n      });\\n    });\\n\\n    // update below block\\n    transformBlock(belowBlockKey, blocks, function (block) {\\n      return block.merge({\\n        prevSibling: originalBlockKey\\n      });\\n    });\\n  });\\n};\\n\\nvar splitBlockInContentState = function splitBlockInContentState(contentState, selectionState) {\\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Selection range must be collapsed.') : invariant(false) : void 0;\\n\\n  var key = selectionState.getAnchorKey();\\n  var offset = selectionState.getAnchorOffset();\\n  var blockMap = contentState.getBlockMap();\\n  var blockToSplit = blockMap.get(key);\\n  var text = blockToSplit.getText();\\n  var chars = blockToSplit.getCharacterList();\\n  var keyBelow = generateRandomKey();\\n  var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode;\\n\\n  var blockAbove = blockToSplit.merge({\\n    text: text.slice(0, offset),\\n    characterList: chars.slice(0, offset)\\n  });\\n  var blockBelow = blockAbove.merge({\\n    key: keyBelow,\\n    text: text.slice(offset),\\n    characterList: chars.slice(offset),\\n    data: Map()\\n  });\\n\\n  var blocksBefore = blockMap.toSeq().takeUntil(function (v) {\\n    return v === blockToSplit;\\n  });\\n  var blocksAfter = blockMap.toSeq().skipUntil(function (v) {\\n    return v === blockToSplit;\\n  }).rest();\\n  var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();\\n\\n  if (isExperimentalTreeBlock) {\\n    !blockToSplit.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ContentBlockNode must not have children') : invariant(false) : void 0;\\n\\n    newBlocks = updateBlockMapLinks(newBlocks, blockAbove, blockBelow);\\n  }\\n\\n  return contentState.merge({\\n    blockMap: newBlocks,\\n    selectionBefore: selectionState,\\n    selectionAfter: selectionState.merge({\\n      anchorKey: keyBelow,\\n      anchorOffset: 0,\\n      focusKey: keyBelow,\\n      focusOffset: 0,\\n      isBackward: false\\n    })\\n  });\\n};\\n\\nmodule.exports = splitBlockInContentState;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"ContentBlockNode\",\"Immutable\",\"generateRandomKey\",\"invariant\",\"List\",\"Map\",\"transformBlock\",\"key\",\"blockMap\",\"func\",\"block\",\"get\",\"set\",\"updateBlockMapLinks\",\"originalBlock\",\"belowBlock\",\"withMutations\",\"blocks\",\"originalBlockKey\",\"getKey\",\"belowBlockKey\",\"getParentKey\",\"parentChildrenList\",\"getChildKeys\",\"insertionIndex\",\"indexOf\",\"newChildrenArray\",\"toArray\",\"splice\",\"merge\",\"children\",\"getNextSiblingKey\",\"prevSibling\",\"nextSibling\",\"splitBlockInContentState\",\"contentState\",\"selectionState\",\"isCollapsed\",\"getAnchorKey\",\"offset\",\"getAnchorOffset\",\"getBlockMap\",\"blockToSplit\",\"text\",\"getText\",\"chars\",\"getCharacterList\",\"keyBelow\",\"isExperimentalTreeBlock\",\"blockAbove\",\"slice\",\"characterList\",\"blockBelow\",\"data\",\"blocksBefore\",\"toSeq\",\"takeUntil\",\"v\",\"blocksAfter\",\"skipUntil\",\"rest\",\"newBlocks\",\"concat\",\"toOrderedMap\",\"isEmpty\",\"selectionBefore\",\"selectionAfter\",\"anchorKey\",\"anchorOffset\",\"focusKey\",\"focusOffset\",\"isBackward\"]\n}\n"]