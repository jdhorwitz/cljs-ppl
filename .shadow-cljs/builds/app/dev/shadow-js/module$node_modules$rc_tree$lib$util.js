["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/rc-tree/lib/util.js"],"~:js","shadow$provide.module$node_modules$rc_tree$lib$util=function(global,process,require,module,exports,shadow$shims){function posToArr(pos){return pos.split(\"-\")}function getNodeChildren(children){return(Array.isArray(children)?children:[children]).filter(function(child){return child&&child.type&&child.type.isTreeNode})}function isCheckDisabled(node){node=node.props||{};var disableCheckbox=node.disableCheckbox;return!(!node.disabled&&!disableCheckbox)}function traverseTreeNodes(treeNodes,subTreeData,\ncallback){function processNode(node,index,parent){var pos=node?parent.pos+\"-\"+index:0,childList=getNodeChildren(node?node.props.children:treeNodes);if(node){parent={node:node,index:index,pos:pos,key:node.key||pos,parentPos:parent.node?parent.pos:null};if(subTreeData){var subNodes=[];_react.Children.forEach(childList,function(subNode,subIndex){var subPos=pos+\"-\"+index;subNodes.push({node:subNode,key:subNode.key||subPos,pos:subPos,index:subIndex})});parent.subNodes=subNodes}if(!1===callback(parent))return}_react.Children.forEach(childList,\nfunction(subNode,subIndex){processNode(subNode,subIndex,{node:node,pos:pos})})}\"function\"===typeof subTreeData&&(callback=subTreeData,subTreeData=!1);processNode(null)}function isParent(parentPos,childPos){var directly=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1;if(!parentPos||!childPos||parentPos.length>childPos.length)return!1;var parentPath=posToArr(parentPos),childPath=posToArr(childPos);if(directly&&parentPath.length!==childPath.length-1)return!1;directly=parentPath.length;for(var i=\n0;i<directly;i+=1)if(parentPath[i]!==childPath[i])return!1;return!0}function getNodesStatistic(treeNodes){var statistic={keyNodes:{},posNodes:{},nodeList:[]};traverseTreeNodes(treeNodes,!0,function(_ref3){var pos=_ref3.pos,key=_ref3.key;_ref3={node:_ref3.node,index:_ref3.index,pos:pos,key:key,subNodes:_ref3.subNodes,parentPos:_ref3.parentPos};statistic.keyNodes[key]=_ref3;statistic.posNodes[pos]=_ref3;statistic.nodeList.push(_ref3)});return statistic}function calcCheckStateConduct(treeNodes,checkedKeys){function conductUp(key,\nhalfChecked){if(!tgtCheckedKeys[key]){var _keyNodes$key=keyNodes[key],_keyNodes$key$subNode=_keyNodes$key.subNodes,subNodes=void 0===_keyNodes$key$subNode?[]:_keyNodes$key$subNode;_keyNodes$key$subNode=_keyNodes$key.parentPos;isCheckDisabled(_keyNodes$key.node)||((halfChecked=!halfChecked&&subNodes.filter(function(sub){return!isCheckDisabled(sub.node)}).every(function(sub){return tgtCheckedKeys[sub.key]}))?tgtCheckedKeys[key]=!0:tgtHalfCheckedKeys[key]=!0,null!==_keyNodes$key$subNode&&conductUp(posNodes[_keyNodes$key$subNode].key,\n!halfChecked))}}function conductDown(key){if(!tgtCheckedKeys[key]){var _keyNodes$key2=keyNodes[key],_keyNodes$key2$subNod=_keyNodes$key2.subNodes;_keyNodes$key2$subNod=void 0===_keyNodes$key2$subNod?[]:_keyNodes$key2$subNod;isCheckDisabled(_keyNodes$key2.node)||(tgtCheckedKeys[key]=!0,_keyNodes$key2$subNod.forEach(function(sub){conductDown(sub.key)}))}}function conduct(key){if(keyNodes[key]){var _keyNodes$key3=keyNodes[key],_keyNodes$key3$subNod=_keyNodes$key3.subNodes;_keyNodes$key3$subNod=void 0===\n_keyNodes$key3$subNod?[]:_keyNodes$key3$subNod;var parentPos=_keyNodes$key3.parentPos;_keyNodes$key3=_keyNodes$key3.node;tgtCheckedKeys[key]=!0;isCheckDisabled(_keyNodes$key3)||(_keyNodes$key3$subNod.filter(function(sub){return!isCheckDisabled(sub.node)}).forEach(function(sub){conductDown(sub.key)}),null!==parentPos&&conductUp(posNodes[parentPos].key))}else(0,_warning2[\"default\"])(!1,\"'\"+key+\"' does not exist in the tree.\")}treeNodes=getNodesStatistic(treeNodes);var keyNodes=treeNodes.keyNodes,posNodes=\ntreeNodes.posNodes,tgtCheckedKeys={},tgtHalfCheckedKeys={};checkedKeys.forEach(function(key){conduct(key)});return{checkedKeys:Object.keys(tgtCheckedKeys),halfCheckedKeys:Object.keys(tgtHalfCheckedKeys).filter(function(key){return!tgtCheckedKeys[key]})}}function keyListToString(keyList){return keyList?keyList.map(function(key){return String(key)}):keyList}exports.__esModule=!0;exports.arrDel=function(list,value){list=list.slice();value=list.indexOf(value);0<=value&&list.splice(value,1);return list};\nexports.arrAdd=function(list,value){list=list.slice();-1===list.indexOf(value)&&list.push(value);return list};exports.posToArr=posToArr;exports.getPosition=function(level,index){return level+\"-\"+index};exports.getNodeChildren=getNodeChildren;exports.isCheckDisabled=isCheckDisabled;exports.traverseTreeNodes=traverseTreeNodes;exports.mapChildren=function(children,func){children=(0,_toArray2[\"default\"])(children).map(func);return 1===children.length?children[0]:children};exports.getStrictlyValue=function(checkedKeys,\nhalfChecked){return halfChecked?{checked:checkedKeys,halfChecked:halfChecked}:checkedKeys};exports.getFullKeyList=function(treeNodes){var keyList=[];traverseTreeNodes(treeNodes,function(_ref2){keyList.push(_ref2.key)});return keyList};exports.isParent=isParent;exports.getNodesStatistic=getNodesStatistic;exports.getDragNodesKeys=function(treeNodes,node){node=node.props;var eventKey=node.eventKey,pos=node.pos,dragNodesKeys=[];traverseTreeNodes(treeNodes,function(_ref4){var key=_ref4.key;isParent(pos,\n_ref4.pos)&&dragNodesKeys.push(key)});dragNodesKeys.push(eventKey||pos);return dragNodesKeys};exports.calcDropPosition=function(event,treeNode){event=event.clientY;treeNode=treeNode.selectHandle.getBoundingClientRect();var bottom=treeNode.bottom,des=Math.max(treeNode.height*DRAG_SIDE_RANGE,DRAG_MIN_GAP);return event<=treeNode.top+des?-1:event>=bottom-des?1:0};exports.calcExpandedKeys=function(keyList,props){if(!keyList)return[];props=getNodesStatistic(props.children);var keyNodes=props.keyNodes;props=\nprops.nodeList;var needExpandKeys={},needExpandPathList=[];keyList.forEach(function(key){var node=keyNodes[key];node&&(needExpandKeys[key]=!0,needExpandPathList.push(node.pos))});props.forEach(function(_ref5){var pos=_ref5.pos;_ref5=_ref5.key;needExpandPathList.some(function(childPos){return isParent(pos,childPos)})&&(needExpandKeys[_ref5]=!0)});props=Object.keys(needExpandKeys);return props.length?props:keyList};exports.calcSelectedKeys=function(selectedKeys,props){if(selectedKeys)return props.multiple?\nselectedKeys.slice():selectedKeys.length?[selectedKeys[0]]:selectedKeys};exports.calcCheckStateConduct=calcCheckStateConduct;exports.calcCheckedKeys=function(keys,props){var children=props.children,checkStrictly=props.checkStrictly;if(!props.checkable||!keys)return null;if(Array.isArray(keys))keys={checkedKeys:keys,halfCheckedKeys:void 0};else if(\"object\"===typeof keys)keys={checkedKeys:keys.checked||void 0,halfCheckedKeys:keys.halfChecked||void 0};else return(0,_warning2[\"default\"])(!1,\"`CheckedKeys` is not an array or an object\"),\nnull;keys.checkedKeys=keyListToString(keys.checkedKeys);keys.halfCheckedKeys=keyListToString(keys.halfCheckedKeys);if(checkStrictly)return keys;checkStrictly=keys.checkedKeys;return calcCheckStateConduct(children,void 0===checkStrictly?[]:checkStrictly)};var _react=require(\"module$node_modules$react$index\"),_toArray2=(global=require(\"module$node_modules$rc_util$lib$Children$toArray\"))&&global.__esModule?global:{\"default\":global},_warning2=(require=require(\"module$node_modules$warning$warning\"))&&\nrequire.__esModule?require:{\"default\":require},DRAG_SIDE_RANGE=.25,DRAG_MIN_GAP=2}","~:source","shadow$provide[\"module$node_modules$rc_tree$lib$util\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nexports.__esModule = true;\nexports.arrDel = arrDel;\nexports.arrAdd = arrAdd;\nexports.posToArr = posToArr;\nexports.getPosition = getPosition;\nexports.getNodeChildren = getNodeChildren;\nexports.isCheckDisabled = isCheckDisabled;\nexports.traverseTreeNodes = traverseTreeNodes;\nexports.mapChildren = mapChildren;\nexports.getStrictlyValue = getStrictlyValue;\nexports.getFullKeyList = getFullKeyList;\nexports.isParent = isParent;\nexports.getNodesStatistic = getNodesStatistic;\nexports.getDragNodesKeys = getDragNodesKeys;\nexports.calcDropPosition = calcDropPosition;\nexports.calcExpandedKeys = calcExpandedKeys;\nexports.calcSelectedKeys = calcSelectedKeys;\nexports.calcCheckStateConduct = calcCheckStateConduct;\nexports.calcCheckedKeys = calcCheckedKeys;\n\nvar _react = require('react');\n\nvar _toArray = require('rc-util/lib/Children/toArray');\n\nvar _toArray2 = _interopRequireDefault(_toArray);\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar DRAG_SIDE_RANGE = 0.25; /* eslint no-loop-func: 0*/\n\nvar DRAG_MIN_GAP = 2;\n\nfunction arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n  return clone;\n}\n\nfunction arrAdd(list, value) {\n  var clone = list.slice();\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n  return clone;\n}\n\nfunction posToArr(pos) {\n  return pos.split('-');\n}\n\nfunction getPosition(level, index) {\n  return level + '-' + index;\n}\n\nfunction getNodeChildren(children) {\n  var childList = Array.isArray(children) ? children : [children];\n  return childList.filter(function (child) {\n    return child && child.type && child.type.isTreeNode;\n  });\n}\n\nfunction isCheckDisabled(node) {\n  var _ref = node.props || {},\n      disabled = _ref.disabled,\n      disableCheckbox = _ref.disableCheckbox;\n\n  return !!(disabled || disableCheckbox);\n}\n\nfunction traverseTreeNodes(treeNodes, subTreeData, callback) {\n  if (typeof subTreeData === 'function') {\n    callback = subTreeData;\n    subTreeData = false;\n  }\n\n  function processNode(node, index, parent) {\n    var children = node ? node.props.children : treeNodes;\n    var pos = node ? getPosition(parent.pos, index) : 0;\n\n    // Filter children\n    var childList = getNodeChildren(children);\n\n    // Process node if is not root\n    if (node) {\n      var data = {\n        node: node,\n        index: index,\n        pos: pos,\n        key: node.key || pos,\n        parentPos: parent.node ? parent.pos : null\n      };\n\n      // Children data is not must have\n      if (subTreeData) {\n        // Statistic children\n        var subNodes = [];\n        _react.Children.forEach(childList, function (subNode, subIndex) {\n          // Provide limit snapshot\n          var subPos = getPosition(pos, index);\n          subNodes.push({\n            node: subNode,\n            key: subNode.key || subPos,\n            pos: subPos,\n            index: subIndex\n          });\n        });\n        data.subNodes = subNodes;\n      }\n\n      // Can break traverse by return false\n      if (callback(data) === false) {\n        return;\n      }\n    }\n\n    // Process children node\n    _react.Children.forEach(childList, function (subNode, subIndex) {\n      processNode(subNode, subIndex, { node: node, pos: pos });\n    });\n  }\n\n  processNode(null);\n}\n\n/**\n * Use `rc-util` `toArray` to get the children list which keeps the key.\n * And return single node if children is only one(This can avoid `key` missing check).\n */\nfunction mapChildren(children, func) {\n  var list = (0, _toArray2['default'])(children).map(func);\n  if (list.length === 1) {\n    return list[0];\n  }\n  return list;\n}\n\n/**\n * [Legacy] Return halfChecked when it has value.\n * @param checkedKeys\n * @param halfChecked\n * @returns {*}\n */\nfunction getStrictlyValue(checkedKeys, halfChecked) {\n  if (halfChecked) {\n    return { checked: checkedKeys, halfChecked: halfChecked };\n  }\n  return checkedKeys;\n}\n\nfunction getFullKeyList(treeNodes) {\n  var keyList = [];\n  traverseTreeNodes(treeNodes, function (_ref2) {\n    var key = _ref2.key;\n\n    keyList.push(key);\n  });\n  return keyList;\n}\n\n/**\n * Check position relation.\n * @param parentPos\n * @param childPos\n * @param directly only directly parent can be true\n * @returns {boolean}\n */\nfunction isParent(parentPos, childPos) {\n  var directly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!parentPos || !childPos || parentPos.length > childPos.length) return false;\n\n  var parentPath = posToArr(parentPos);\n  var childPath = posToArr(childPos);\n\n  // Directly check\n  if (directly && parentPath.length !== childPath.length - 1) return false;\n\n  var len = parentPath.length;\n  for (var i = 0; i < len; i += 1) {\n    if (parentPath[i] !== childPath[i]) return false;\n  }\n\n  return true;\n}\n\n/**\n * Statistic TreeNodes info\n * @param treeNodes\n * @returns {{}}\n */\nfunction getNodesStatistic(treeNodes) {\n  var statistic = {\n    keyNodes: {},\n    posNodes: {},\n    nodeList: []\n  };\n\n  traverseTreeNodes(treeNodes, true, function (_ref3) {\n    var node = _ref3.node,\n        index = _ref3.index,\n        pos = _ref3.pos,\n        key = _ref3.key,\n        subNodes = _ref3.subNodes,\n        parentPos = _ref3.parentPos;\n\n    var data = { node: node, index: index, pos: pos, key: key, subNodes: subNodes, parentPos: parentPos };\n    statistic.keyNodes[key] = data;\n    statistic.posNodes[pos] = data;\n    statistic.nodeList.push(data);\n  });\n\n  return statistic;\n}\n\nfunction getDragNodesKeys(treeNodes, node) {\n  var _node$props = node.props,\n      eventKey = _node$props.eventKey,\n      pos = _node$props.pos;\n\n  var dragNodesKeys = [];\n\n  traverseTreeNodes(treeNodes, function (_ref4) {\n    var nodePos = _ref4.pos,\n        key = _ref4.key;\n\n    if (isParent(pos, nodePos)) {\n      dragNodesKeys.push(key);\n    }\n  });\n  dragNodesKeys.push(eventKey || pos);\n  return dragNodesKeys;\n}\n\n// Only used when drag, not affect SSR.\nfunction calcDropPosition(event, treeNode) {\n  var clientY = event.clientY;\n\n  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),\n      top = _treeNode$selectHandl.top,\n      bottom = _treeNode$selectHandl.bottom,\n      height = _treeNode$selectHandl.height;\n\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\n\n  if (clientY <= top + des) {\n    return -1;\n  } else if (clientY >= bottom - des) {\n    return 1;\n  }\n\n  return 0;\n}\n\n/**\n * Auto expand all related node when sub node is expanded\n * @param keyList\n * @param props\n * @returns [string]\n */\nfunction calcExpandedKeys(keyList, props) {\n  if (!keyList) {\n    return [];\n  }\n\n  var children = props.children;\n\n  // Fill parent expanded keys\n\n  var _getNodesStatistic = getNodesStatistic(children),\n      keyNodes = _getNodesStatistic.keyNodes,\n      nodeList = _getNodesStatistic.nodeList;\n\n  var needExpandKeys = {};\n  var needExpandPathList = [];\n\n  // Fill expanded nodes\n  keyList.forEach(function (key) {\n    var node = keyNodes[key];\n    if (node) {\n      needExpandKeys[key] = true;\n      needExpandPathList.push(node.pos);\n    }\n  });\n\n  // Match parent by path\n  nodeList.forEach(function (_ref5) {\n    var pos = _ref5.pos,\n        key = _ref5.key;\n\n    if (needExpandPathList.some(function (childPos) {\n      return isParent(pos, childPos);\n    })) {\n      needExpandKeys[key] = true;\n    }\n  });\n\n  var calcExpandedKeyList = Object.keys(needExpandKeys);\n\n  // [Legacy] Return origin keyList if calc list is empty\n  return calcExpandedKeyList.length ? calcExpandedKeyList : keyList;\n}\n\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\nfunction calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) {\n    return undefined;\n  }\n\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n  return selectedKeys;\n}\n\n/**\n * Check conduct is by key level. It pass though up & down.\n * When conduct target node is check means already conducted will be skip.\n * @param treeNodes\n * @param checkedKeys\n * @returns {{checkedKeys: Array, halfCheckedKeys: Array}}\n */\nfunction calcCheckStateConduct(treeNodes, checkedKeys) {\n  var _getNodesStatistic2 = getNodesStatistic(treeNodes),\n      keyNodes = _getNodesStatistic2.keyNodes,\n      posNodes = _getNodesStatistic2.posNodes;\n\n  var tgtCheckedKeys = {};\n  var tgtHalfCheckedKeys = {};\n\n  // Conduct up\n  function conductUp(key, halfChecked) {\n    if (tgtCheckedKeys[key]) return;\n\n    var _keyNodes$key = keyNodes[key],\n        _keyNodes$key$subNode = _keyNodes$key.subNodes,\n        subNodes = _keyNodes$key$subNode === undefined ? [] : _keyNodes$key$subNode,\n        parentPos = _keyNodes$key.parentPos,\n        node = _keyNodes$key.node;\n\n    if (isCheckDisabled(node)) return;\n\n    var allSubChecked = !halfChecked && subNodes.filter(function (sub) {\n      return !isCheckDisabled(sub.node);\n    }).every(function (sub) {\n      return tgtCheckedKeys[sub.key];\n    });\n\n    if (allSubChecked) {\n      tgtCheckedKeys[key] = true;\n    } else {\n      tgtHalfCheckedKeys[key] = true;\n    }\n\n    if (parentPos !== null) {\n      conductUp(posNodes[parentPos].key, !allSubChecked);\n    }\n  }\n\n  // Conduct down\n  function conductDown(key) {\n    if (tgtCheckedKeys[key]) return;\n    var _keyNodes$key2 = keyNodes[key],\n        _keyNodes$key2$subNod = _keyNodes$key2.subNodes,\n        subNodes = _keyNodes$key2$subNod === undefined ? [] : _keyNodes$key2$subNod,\n        node = _keyNodes$key2.node;\n\n\n    if (isCheckDisabled(node)) return;\n\n    tgtCheckedKeys[key] = true;\n\n    subNodes.forEach(function (sub) {\n      conductDown(sub.key);\n    });\n  }\n\n  function conduct(key) {\n    if (!keyNodes[key]) {\n      (0, _warning2['default'])(false, '\\'' + key + '\\' does not exist in the tree.');\n      return;\n    }\n\n    var _keyNodes$key3 = keyNodes[key],\n        _keyNodes$key3$subNod = _keyNodes$key3.subNodes,\n        subNodes = _keyNodes$key3$subNod === undefined ? [] : _keyNodes$key3$subNod,\n        parentPos = _keyNodes$key3.parentPos,\n        node = _keyNodes$key3.node;\n\n    tgtCheckedKeys[key] = true;\n\n    if (isCheckDisabled(node)) return;\n\n    // Conduct down\n    subNodes.filter(function (sub) {\n      return !isCheckDisabled(sub.node);\n    }).forEach(function (sub) {\n      conductDown(sub.key);\n    });\n\n    // Conduct up\n    if (parentPos !== null) {\n      conductUp(posNodes[parentPos].key);\n    }\n  }\n\n  checkedKeys.forEach(function (key) {\n    conduct(key);\n  });\n\n  return {\n    checkedKeys: Object.keys(tgtCheckedKeys),\n    halfCheckedKeys: Object.keys(tgtHalfCheckedKeys).filter(function (key) {\n      return !tgtCheckedKeys[key];\n    })\n  };\n}\n\n/**\n * Since React internal will convert key to string,\n * we need do this to avoid `checkStrictly` use number match\n */\nfunction keyListToString(keyList) {\n  if (!keyList) return keyList;\n  return keyList.map(function (key) {\n    return String(key);\n  });\n}\n\n/**\n * Calculate the value of checked and halfChecked keys.\n * This should be only run in init or props changed.\n */\nfunction calcCheckedKeys(keys, props) {\n  var checkable = props.checkable,\n      children = props.children,\n      checkStrictly = props.checkStrictly;\n\n\n  if (!checkable || !keys) {\n    return null;\n  }\n\n  // Convert keys to object format\n  var keyProps = void 0;\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (typeof keys === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    (0, _warning2['default'])(false, '`CheckedKeys` is not an array or an object');\n    return null;\n  }\n\n  keyProps.checkedKeys = keyListToString(keyProps.checkedKeys);\n  keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys);\n\n  // Do nothing if is checkStrictly mode\n  if (checkStrictly) {\n    return keyProps;\n  }\n\n  // Conduct calculate the check status\n  var _keyProps = keyProps,\n      _keyProps$checkedKeys = _keyProps.checkedKeys,\n      checkedKeys = _keyProps$checkedKeys === undefined ? [] : _keyProps$checkedKeys;\n\n  return calcCheckStateConduct(children, checkedKeys);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$rc_util$lib$Children$toArray","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$warning$warning"]],"~:properties",["^5",["pos","halfChecked","parentPos","index","calcExpandedKeys","calcSelectedKeys","traverseTreeNodes","checkedKeys","getPosition","posToArr","key","calcCheckedKeys","__esModule","subNodes","getFullKeyList","mapChildren","isCheckDisabled","isParent","calcCheckStateConduct","halfCheckedKeys","getStrictlyValue","posNodes","keyNodes","arrAdd","getNodesStatistic","calcDropPosition","arrDel","getDragNodesKeys","getNodeChildren","default","checked","nodeList","node"]],"~:compiled-at",1532351402098,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$rc_tree$lib$util.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/rc-tree/lib/util.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$rc_tree$lib$util\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.arrDel = arrDel;\\nexports.arrAdd = arrAdd;\\nexports.posToArr = posToArr;\\nexports.getPosition = getPosition;\\nexports.getNodeChildren = getNodeChildren;\\nexports.isCheckDisabled = isCheckDisabled;\\nexports.traverseTreeNodes = traverseTreeNodes;\\nexports.mapChildren = mapChildren;\\nexports.getStrictlyValue = getStrictlyValue;\\nexports.getFullKeyList = getFullKeyList;\\nexports.isParent = isParent;\\nexports.getNodesStatistic = getNodesStatistic;\\nexports.getDragNodesKeys = getDragNodesKeys;\\nexports.calcDropPosition = calcDropPosition;\\nexports.calcExpandedKeys = calcExpandedKeys;\\nexports.calcSelectedKeys = calcSelectedKeys;\\nexports.calcCheckStateConduct = calcCheckStateConduct;\\nexports.calcCheckedKeys = calcCheckedKeys;\\n\\nvar _react = require('react');\\n\\nvar _toArray = require('rc-util/lib/Children/toArray');\\n\\nvar _toArray2 = _interopRequireDefault(_toArray);\\n\\nvar _warning = require('warning');\\n\\nvar _warning2 = _interopRequireDefault(_warning);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar DRAG_SIDE_RANGE = 0.25; /* eslint no-loop-func: 0*/\\n\\nvar DRAG_MIN_GAP = 2;\\n\\nfunction arrDel(list, value) {\\n  var clone = list.slice();\\n  var index = clone.indexOf(value);\\n  if (index >= 0) {\\n    clone.splice(index, 1);\\n  }\\n  return clone;\\n}\\n\\nfunction arrAdd(list, value) {\\n  var clone = list.slice();\\n  if (clone.indexOf(value) === -1) {\\n    clone.push(value);\\n  }\\n  return clone;\\n}\\n\\nfunction posToArr(pos) {\\n  return pos.split('-');\\n}\\n\\nfunction getPosition(level, index) {\\n  return level + '-' + index;\\n}\\n\\nfunction getNodeChildren(children) {\\n  var childList = Array.isArray(children) ? children : [children];\\n  return childList.filter(function (child) {\\n    return child && child.type && child.type.isTreeNode;\\n  });\\n}\\n\\nfunction isCheckDisabled(node) {\\n  var _ref = node.props || {},\\n      disabled = _ref.disabled,\\n      disableCheckbox = _ref.disableCheckbox;\\n\\n  return !!(disabled || disableCheckbox);\\n}\\n\\nfunction traverseTreeNodes(treeNodes, subTreeData, callback) {\\n  if (typeof subTreeData === 'function') {\\n    callback = subTreeData;\\n    subTreeData = false;\\n  }\\n\\n  function processNode(node, index, parent) {\\n    var children = node ? node.props.children : treeNodes;\\n    var pos = node ? getPosition(parent.pos, index) : 0;\\n\\n    // Filter children\\n    var childList = getNodeChildren(children);\\n\\n    // Process node if is not root\\n    if (node) {\\n      var data = {\\n        node: node,\\n        index: index,\\n        pos: pos,\\n        key: node.key || pos,\\n        parentPos: parent.node ? parent.pos : null\\n      };\\n\\n      // Children data is not must have\\n      if (subTreeData) {\\n        // Statistic children\\n        var subNodes = [];\\n        _react.Children.forEach(childList, function (subNode, subIndex) {\\n          // Provide limit snapshot\\n          var subPos = getPosition(pos, index);\\n          subNodes.push({\\n            node: subNode,\\n            key: subNode.key || subPos,\\n            pos: subPos,\\n            index: subIndex\\n          });\\n        });\\n        data.subNodes = subNodes;\\n      }\\n\\n      // Can break traverse by return false\\n      if (callback(data) === false) {\\n        return;\\n      }\\n    }\\n\\n    // Process children node\\n    _react.Children.forEach(childList, function (subNode, subIndex) {\\n      processNode(subNode, subIndex, { node: node, pos: pos });\\n    });\\n  }\\n\\n  processNode(null);\\n}\\n\\n/**\\n * Use `rc-util` `toArray` to get the children list which keeps the key.\\n * And return single node if children is only one(This can avoid `key` missing check).\\n */\\nfunction mapChildren(children, func) {\\n  var list = (0, _toArray2['default'])(children).map(func);\\n  if (list.length === 1) {\\n    return list[0];\\n  }\\n  return list;\\n}\\n\\n/**\\n * [Legacy] Return halfChecked when it has value.\\n * @param checkedKeys\\n * @param halfChecked\\n * @returns {*}\\n */\\nfunction getStrictlyValue(checkedKeys, halfChecked) {\\n  if (halfChecked) {\\n    return { checked: checkedKeys, halfChecked: halfChecked };\\n  }\\n  return checkedKeys;\\n}\\n\\nfunction getFullKeyList(treeNodes) {\\n  var keyList = [];\\n  traverseTreeNodes(treeNodes, function (_ref2) {\\n    var key = _ref2.key;\\n\\n    keyList.push(key);\\n  });\\n  return keyList;\\n}\\n\\n/**\\n * Check position relation.\\n * @param parentPos\\n * @param childPos\\n * @param directly only directly parent can be true\\n * @returns {boolean}\\n */\\nfunction isParent(parentPos, childPos) {\\n  var directly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n  if (!parentPos || !childPos || parentPos.length > childPos.length) return false;\\n\\n  var parentPath = posToArr(parentPos);\\n  var childPath = posToArr(childPos);\\n\\n  // Directly check\\n  if (directly && parentPath.length !== childPath.length - 1) return false;\\n\\n  var len = parentPath.length;\\n  for (var i = 0; i < len; i += 1) {\\n    if (parentPath[i] !== childPath[i]) return false;\\n  }\\n\\n  return true;\\n}\\n\\n/**\\n * Statistic TreeNodes info\\n * @param treeNodes\\n * @returns {{}}\\n */\\nfunction getNodesStatistic(treeNodes) {\\n  var statistic = {\\n    keyNodes: {},\\n    posNodes: {},\\n    nodeList: []\\n  };\\n\\n  traverseTreeNodes(treeNodes, true, function (_ref3) {\\n    var node = _ref3.node,\\n        index = _ref3.index,\\n        pos = _ref3.pos,\\n        key = _ref3.key,\\n        subNodes = _ref3.subNodes,\\n        parentPos = _ref3.parentPos;\\n\\n    var data = { node: node, index: index, pos: pos, key: key, subNodes: subNodes, parentPos: parentPos };\\n    statistic.keyNodes[key] = data;\\n    statistic.posNodes[pos] = data;\\n    statistic.nodeList.push(data);\\n  });\\n\\n  return statistic;\\n}\\n\\nfunction getDragNodesKeys(treeNodes, node) {\\n  var _node$props = node.props,\\n      eventKey = _node$props.eventKey,\\n      pos = _node$props.pos;\\n\\n  var dragNodesKeys = [];\\n\\n  traverseTreeNodes(treeNodes, function (_ref4) {\\n    var nodePos = _ref4.pos,\\n        key = _ref4.key;\\n\\n    if (isParent(pos, nodePos)) {\\n      dragNodesKeys.push(key);\\n    }\\n  });\\n  dragNodesKeys.push(eventKey || pos);\\n  return dragNodesKeys;\\n}\\n\\n// Only used when drag, not affect SSR.\\nfunction calcDropPosition(event, treeNode) {\\n  var clientY = event.clientY;\\n\\n  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),\\n      top = _treeNode$selectHandl.top,\\n      bottom = _treeNode$selectHandl.bottom,\\n      height = _treeNode$selectHandl.height;\\n\\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\\n\\n  if (clientY <= top + des) {\\n    return -1;\\n  } else if (clientY >= bottom - des) {\\n    return 1;\\n  }\\n\\n  return 0;\\n}\\n\\n/**\\n * Auto expand all related node when sub node is expanded\\n * @param keyList\\n * @param props\\n * @returns [string]\\n */\\nfunction calcExpandedKeys(keyList, props) {\\n  if (!keyList) {\\n    return [];\\n  }\\n\\n  var children = props.children;\\n\\n  // Fill parent expanded keys\\n\\n  var _getNodesStatistic = getNodesStatistic(children),\\n      keyNodes = _getNodesStatistic.keyNodes,\\n      nodeList = _getNodesStatistic.nodeList;\\n\\n  var needExpandKeys = {};\\n  var needExpandPathList = [];\\n\\n  // Fill expanded nodes\\n  keyList.forEach(function (key) {\\n    var node = keyNodes[key];\\n    if (node) {\\n      needExpandKeys[key] = true;\\n      needExpandPathList.push(node.pos);\\n    }\\n  });\\n\\n  // Match parent by path\\n  nodeList.forEach(function (_ref5) {\\n    var pos = _ref5.pos,\\n        key = _ref5.key;\\n\\n    if (needExpandPathList.some(function (childPos) {\\n      return isParent(pos, childPos);\\n    })) {\\n      needExpandKeys[key] = true;\\n    }\\n  });\\n\\n  var calcExpandedKeyList = Object.keys(needExpandKeys);\\n\\n  // [Legacy] Return origin keyList if calc list is empty\\n  return calcExpandedKeyList.length ? calcExpandedKeyList : keyList;\\n}\\n\\n/**\\n * Return selectedKeys according with multiple prop\\n * @param selectedKeys\\n * @param props\\n * @returns [string]\\n */\\nfunction calcSelectedKeys(selectedKeys, props) {\\n  if (!selectedKeys) {\\n    return undefined;\\n  }\\n\\n  var multiple = props.multiple;\\n\\n  if (multiple) {\\n    return selectedKeys.slice();\\n  }\\n\\n  if (selectedKeys.length) {\\n    return [selectedKeys[0]];\\n  }\\n  return selectedKeys;\\n}\\n\\n/**\\n * Check conduct is by key level. It pass though up & down.\\n * When conduct target node is check means already conducted will be skip.\\n * @param treeNodes\\n * @param checkedKeys\\n * @returns {{checkedKeys: Array, halfCheckedKeys: Array}}\\n */\\nfunction calcCheckStateConduct(treeNodes, checkedKeys) {\\n  var _getNodesStatistic2 = getNodesStatistic(treeNodes),\\n      keyNodes = _getNodesStatistic2.keyNodes,\\n      posNodes = _getNodesStatistic2.posNodes;\\n\\n  var tgtCheckedKeys = {};\\n  var tgtHalfCheckedKeys = {};\\n\\n  // Conduct up\\n  function conductUp(key, halfChecked) {\\n    if (tgtCheckedKeys[key]) return;\\n\\n    var _keyNodes$key = keyNodes[key],\\n        _keyNodes$key$subNode = _keyNodes$key.subNodes,\\n        subNodes = _keyNodes$key$subNode === undefined ? [] : _keyNodes$key$subNode,\\n        parentPos = _keyNodes$key.parentPos,\\n        node = _keyNodes$key.node;\\n\\n    if (isCheckDisabled(node)) return;\\n\\n    var allSubChecked = !halfChecked && subNodes.filter(function (sub) {\\n      return !isCheckDisabled(sub.node);\\n    }).every(function (sub) {\\n      return tgtCheckedKeys[sub.key];\\n    });\\n\\n    if (allSubChecked) {\\n      tgtCheckedKeys[key] = true;\\n    } else {\\n      tgtHalfCheckedKeys[key] = true;\\n    }\\n\\n    if (parentPos !== null) {\\n      conductUp(posNodes[parentPos].key, !allSubChecked);\\n    }\\n  }\\n\\n  // Conduct down\\n  function conductDown(key) {\\n    if (tgtCheckedKeys[key]) return;\\n    var _keyNodes$key2 = keyNodes[key],\\n        _keyNodes$key2$subNod = _keyNodes$key2.subNodes,\\n        subNodes = _keyNodes$key2$subNod === undefined ? [] : _keyNodes$key2$subNod,\\n        node = _keyNodes$key2.node;\\n\\n\\n    if (isCheckDisabled(node)) return;\\n\\n    tgtCheckedKeys[key] = true;\\n\\n    subNodes.forEach(function (sub) {\\n      conductDown(sub.key);\\n    });\\n  }\\n\\n  function conduct(key) {\\n    if (!keyNodes[key]) {\\n      (0, _warning2['default'])(false, '\\\\'' + key + '\\\\' does not exist in the tree.');\\n      return;\\n    }\\n\\n    var _keyNodes$key3 = keyNodes[key],\\n        _keyNodes$key3$subNod = _keyNodes$key3.subNodes,\\n        subNodes = _keyNodes$key3$subNod === undefined ? [] : _keyNodes$key3$subNod,\\n        parentPos = _keyNodes$key3.parentPos,\\n        node = _keyNodes$key3.node;\\n\\n    tgtCheckedKeys[key] = true;\\n\\n    if (isCheckDisabled(node)) return;\\n\\n    // Conduct down\\n    subNodes.filter(function (sub) {\\n      return !isCheckDisabled(sub.node);\\n    }).forEach(function (sub) {\\n      conductDown(sub.key);\\n    });\\n\\n    // Conduct up\\n    if (parentPos !== null) {\\n      conductUp(posNodes[parentPos].key);\\n    }\\n  }\\n\\n  checkedKeys.forEach(function (key) {\\n    conduct(key);\\n  });\\n\\n  return {\\n    checkedKeys: Object.keys(tgtCheckedKeys),\\n    halfCheckedKeys: Object.keys(tgtHalfCheckedKeys).filter(function (key) {\\n      return !tgtCheckedKeys[key];\\n    })\\n  };\\n}\\n\\n/**\\n * Since React internal will convert key to string,\\n * we need do this to avoid `checkStrictly` use number match\\n */\\nfunction keyListToString(keyList) {\\n  if (!keyList) return keyList;\\n  return keyList.map(function (key) {\\n    return String(key);\\n  });\\n}\\n\\n/**\\n * Calculate the value of checked and halfChecked keys.\\n * This should be only run in init or props changed.\\n */\\nfunction calcCheckedKeys(keys, props) {\\n  var checkable = props.checkable,\\n      children = props.children,\\n      checkStrictly = props.checkStrictly;\\n\\n\\n  if (!checkable || !keys) {\\n    return null;\\n  }\\n\\n  // Convert keys to object format\\n  var keyProps = void 0;\\n  if (Array.isArray(keys)) {\\n    // [Legacy] Follow the api doc\\n    keyProps = {\\n      checkedKeys: keys,\\n      halfCheckedKeys: undefined\\n    };\\n  } else if (typeof keys === 'object') {\\n    keyProps = {\\n      checkedKeys: keys.checked || undefined,\\n      halfCheckedKeys: keys.halfChecked || undefined\\n    };\\n  } else {\\n    (0, _warning2['default'])(false, '`CheckedKeys` is not an array or an object');\\n    return null;\\n  }\\n\\n  keyProps.checkedKeys = keyListToString(keyProps.checkedKeys);\\n  keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys);\\n\\n  // Do nothing if is checkStrictly mode\\n  if (checkStrictly) {\\n    return keyProps;\\n  }\\n\\n  // Conduct calculate the check status\\n  var _keyProps = keyProps,\\n      _keyProps$checkedKeys = _keyProps.checkedKeys,\\n      checkedKeys = _keyProps$checkedKeys === undefined ? [] : _keyProps$checkedKeys;\\n\\n  return calcCheckStateConduct(children, checkedKeys);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"posToArr\",\"pos\",\"split\",\"getNodeChildren\",\"children\",\"filter\",\"Array\",\"isArray\",\"childList\",\"child\",\"type\",\"isTreeNode\",\"isCheckDisabled\",\"node\",\"_ref\",\"props\",\"disableCheckbox\",\"disabled\",\"traverseTreeNodes\",\"treeNodes\",\"subTreeData\",\"callback\",\"processNode\",\"index\",\"parent\",\"data\",\"key\",\"parentPos\",\"subNodes\",\"_react\",\"Children\",\"forEach\",\"subNode\",\"subIndex\",\"subPos\",\"push\",\"isParent\",\"childPos\",\"directly\",\"arguments\",\"length\",\"undefined\",\"parentPath\",\"childPath\",\"len\",\"i\",\"getNodesStatistic\",\"statistic\",\"keyNodes\",\"posNodes\",\"nodeList\",\"_ref3\",\"calcCheckStateConduct\",\"checkedKeys\",\"conductUp\",\"halfChecked\",\"tgtCheckedKeys\",\"_keyNodes$key\",\"_keyNodes$key$subNode\",\"allSubChecked\",\"sub\",\"every\",\"tgtHalfCheckedKeys\",\"conductDown\",\"_keyNodes$key2\",\"_keyNodes$key2$subNod\",\"conduct\",\"_keyNodes$key3\",\"_keyNodes$key3$subNod\",\"_warning2\",\"_getNodesStatistic2\",\"Object\",\"keys\",\"halfCheckedKeys\",\"keyListToString\",\"keyList\",\"map\",\"String\",\"__esModule\",\"arrDel\",\"list\",\"value\",\"clone\",\"slice\",\"indexOf\",\"splice\",\"arrAdd\",\"getPosition\",\"level\",\"mapChildren\",\"func\",\"_toArray2\",\"getStrictlyValue\",\"checked\",\"getFullKeyList\",\"_ref2\",\"getDragNodesKeys\",\"_node$props\",\"eventKey\",\"dragNodesKeys\",\"_ref4\",\"calcDropPosition\",\"event\",\"treeNode\",\"clientY\",\"_treeNode$selectHandl\",\"selectHandle\",\"getBoundingClientRect\",\"bottom\",\"des\",\"Math\",\"max\",\"height\",\"DRAG_SIDE_RANGE\",\"DRAG_MIN_GAP\",\"top\",\"calcExpandedKeys\",\"_getNodesStatistic\",\"needExpandKeys\",\"needExpandPathList\",\"_ref5\",\"some\",\"calcExpandedKeyList\",\"calcSelectedKeys\",\"selectedKeys\",\"multiple\",\"calcCheckedKeys\",\"checkStrictly\",\"checkable\",\"keyProps\",\"_keyProps$checkedKeys\",\"_toArray\",\"_warning\"]\n}\n"]