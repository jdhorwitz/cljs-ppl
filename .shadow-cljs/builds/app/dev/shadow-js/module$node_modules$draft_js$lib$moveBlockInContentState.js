["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/moveBlockInContentState.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$moveBlockInContentState=function(global,process,require,module,exports,shadow$shims){var ContentBlockNode=require(\"module$node_modules$draft_js$lib$ContentBlockNode\");global=require(\"module$node_modules$immutable$dist$immutable\");var getNextDelimiterBlockKey=require(\"module$node_modules$draft_js$lib$getNextDelimiterBlockKey\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),OrderedMap=global.OrderedMap,List=global.List,transformBlock=function(key,\nblockMap,func){if(key){var block=blockMap.get(key);block&&blockMap.set(key,func(block))}},updateBlockMapLinks=function(blockMap,originalBlockToBeMoved,originalTargetBlock,insertionMode,isExperimentalTreeBlock){if(!isExperimentalTreeBlock)return blockMap;var isInsertedAfterTarget=\"after\"===insertionMode,originalBlockKey=originalBlockToBeMoved.getKey(),originalTargetKey=originalTargetBlock.getKey(),originalParentKey=originalBlockToBeMoved.getParentKey(),originalNextSiblingKey=originalBlockToBeMoved.getNextSiblingKey(),\noriginalPrevSiblingKey=originalBlockToBeMoved.getPrevSiblingKey(),newParentKey=originalTargetBlock.getParentKey(),newNextSiblingKey=isInsertedAfterTarget?originalTargetBlock.getNextSiblingKey():originalTargetKey,newPrevSiblingKey=isInsertedAfterTarget?originalTargetKey:originalTargetBlock.getPrevSiblingKey();return blockMap.withMutations(function(blocks){transformBlock(originalParentKey,blocks,function(block){var parentChildrenList=block.getChildKeys();return block.merge({children:parentChildrenList[\"delete\"](parentChildrenList.indexOf(originalBlockKey))})});\ntransformBlock(originalPrevSiblingKey,blocks,function(block){return block.merge({nextSibling:originalNextSiblingKey})});transformBlock(originalNextSiblingKey,blocks,function(block){return block.merge({prevSibling:originalPrevSiblingKey})});transformBlock(newNextSiblingKey,blocks,function(block){return block.merge({prevSibling:originalBlockKey})});transformBlock(newPrevSiblingKey,blocks,function(block){return block.merge({nextSibling:originalBlockKey})});transformBlock(newParentKey,blocks,function(block){var newParentChildrenList=\nblock.getChildKeys(),targetBlockIndex=newParentChildrenList.indexOf(originalTargetKey);targetBlockIndex=isInsertedAfterTarget?targetBlockIndex+1:0!==targetBlockIndex?targetBlockIndex-1:0;newParentChildrenList=newParentChildrenList.toArray();newParentChildrenList.splice(targetBlockIndex,0,originalBlockKey);return block.merge({children:List(newParentChildrenList)})});transformBlock(originalBlockKey,blocks,function(block){return block.merge({nextSibling:newNextSiblingKey,prevSibling:newPrevSiblingKey,\nparent:newParentKey})})})};module.exports=function(contentState,blockToBeMoved,targetBlock,insertionMode){\"replace\"===insertionMode?invariant(!1,\"Replacing blocks is not supported.\"):void 0;var targetKey=targetBlock.getKey(),blockKey=blockToBeMoved.getKey();blockKey===targetKey?invariant(!1,\"Block cannot be moved next to itself.\"):void 0;var blockMap=contentState.getBlockMap(),isExperimentalTreeBlock=blockToBeMoved instanceof ContentBlockNode,blocksToBeMoved=[blockToBeMoved],blockMapWithoutBlocksToBeMoved=\nblockMap[\"delete\"](blockKey);isExperimentalTreeBlock&&(blocksToBeMoved=[],blockMapWithoutBlocksToBeMoved=blockMap.withMutations(function(blocks){var nextSiblingKey=blockToBeMoved.getNextSiblingKey(),nextDelimiterBlockKey=getNextDelimiterBlockKey(blockToBeMoved,blocks);blocks.toSeq().skipUntil(function(block){return block.getKey()===blockKey}).takeWhile(function(block){var key=block.getKey(),isBlockToBeMoved=key===blockKey,hasNextSiblingAndIsNotNextSibling=nextSiblingKey&&key!==nextSiblingKey;block=\n!nextSiblingKey&&block.getParentKey()&&(!nextDelimiterBlockKey||key!==nextDelimiterBlockKey);return!!(isBlockToBeMoved||hasNextSiblingAndIsNotNextSibling||block)}).forEach(function(block){blocksToBeMoved.push(block);blocks[\"delete\"](block.getKey())})}));blockMap=blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function(v){return v===targetBlock});blockMapWithoutBlocksToBeMoved=blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function(v){return v===targetBlock}).skip(1);var slicedBlocks=blocksToBeMoved.map(function(block){return[block.getKey(),\nblock]}),newBlocks=OrderedMap();\"before\"===insertionMode?((newBlocks=contentState.getBlockBefore(targetKey))&&newBlocks.getKey()===blockToBeMoved.getKey()?invariant(!1,\"Block cannot be moved next to itself.\"):void 0,newBlocks=blockMap.concat([].concat(slicedBlocks,[[targetKey,targetBlock]]),blockMapWithoutBlocksToBeMoved).toOrderedMap()):\"after\"===insertionMode&&((newBlocks=contentState.getBlockAfter(targetKey))&&newBlocks.getKey()===blockKey?invariant(!1,\"Block cannot be moved next to itself.\"):\nvoid 0,newBlocks=blockMap.concat([[targetKey,targetBlock]].concat(slicedBlocks),blockMapWithoutBlocksToBeMoved).toOrderedMap());return contentState.merge({blockMap:updateBlockMapLinks(newBlocks,blockToBeMoved,targetBlock,insertionMode,isExperimentalTreeBlock),selectionBefore:contentState.getSelectionAfter(),selectionAfter:contentState.getSelectionAfter().merge({anchorKey:blockKey,focusKey:blockKey})})}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$moveBlockInContentState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule moveBlockInContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  }\n  // possible values of 'insertionMode' are: 'after', 'before'\n  var isInsertedAfterTarget = insertionMode === 'after';\n\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\n      });\n    });\n\n    // update old prev\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    });\n\n    // update old next\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    });\n\n    // update new next\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n\n    // update new prev\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    });\n\n    // update new parent\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    });\n\n    // update block\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks['delete'](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$draft_js$lib$ContentBlockNode","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$draft_js$lib$getNextDelimiterBlockKey"]],"~:properties",["^5",["selectionBefore","selectionAfter","parent","children","nextSibling","anchorKey","focusKey","blockMap","prevSibling"]],"~:compiled-at",1532351402134,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$moveBlockInContentState.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/moveBlockInContentState.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$moveBlockInContentState\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule moveBlockInContentState\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar ContentBlockNode = require('./ContentBlockNode');\\nvar Immutable = require('immutable');\\n\\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\\nvar invariant = require('fbjs/lib/invariant');\\n\\nvar OrderedMap = Immutable.OrderedMap,\\n    List = Immutable.List;\\n\\n\\nvar transformBlock = function transformBlock(key, blockMap, func) {\\n  if (!key) {\\n    return;\\n  }\\n\\n  var block = blockMap.get(key);\\n\\n  if (!block) {\\n    return;\\n  }\\n\\n  blockMap.set(key, func(block));\\n};\\n\\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\\n  if (!isExperimentalTreeBlock) {\\n    return blockMap;\\n  }\\n  // possible values of 'insertionMode' are: 'after', 'before'\\n  var isInsertedAfterTarget = insertionMode === 'after';\\n\\n  var originalBlockKey = originalBlockToBeMoved.getKey();\\n  var originalTargetKey = originalTargetBlock.getKey();\\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\\n  var newParentKey = originalTargetBlock.getParentKey();\\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\\n\\n  return blockMap.withMutations(function (blocks) {\\n    // update old parent\\n    transformBlock(originalParentKey, blocks, function (block) {\\n      var parentChildrenList = block.getChildKeys();\\n      return block.merge({\\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\\n      });\\n    });\\n\\n    // update old prev\\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\\n      return block.merge({\\n        nextSibling: originalNextSiblingKey\\n      });\\n    });\\n\\n    // update old next\\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\\n      return block.merge({\\n        prevSibling: originalPrevSiblingKey\\n      });\\n    });\\n\\n    // update new next\\n    transformBlock(newNextSiblingKey, blocks, function (block) {\\n      return block.merge({\\n        prevSibling: originalBlockKey\\n      });\\n    });\\n\\n    // update new prev\\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\\n      return block.merge({\\n        nextSibling: originalBlockKey\\n      });\\n    });\\n\\n    // update new parent\\n    transformBlock(newParentKey, blocks, function (block) {\\n      var newParentChildrenList = block.getChildKeys();\\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\\n\\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\\n\\n      var newChildrenArray = newParentChildrenList.toArray();\\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\\n\\n      return block.merge({\\n        children: List(newChildrenArray)\\n      });\\n    });\\n\\n    // update block\\n    transformBlock(originalBlockKey, blocks, function (block) {\\n      return block.merge({\\n        nextSibling: newNextSiblingKey,\\n        prevSibling: newPrevSiblingKey,\\n        parent: newParentKey\\n      });\\n    });\\n  });\\n};\\n\\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\\n\\n  var targetKey = targetBlock.getKey();\\n  var blockKey = blockToBeMoved.getKey();\\n\\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\\n\\n  var blockMap = contentState.getBlockMap();\\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\\n\\n  var blocksToBeMoved = [blockToBeMoved];\\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\\n\\n  if (isExperimentalTreeBlock) {\\n    blocksToBeMoved = [];\\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\\n\\n      blocks.toSeq().skipUntil(function (block) {\\n        return block.getKey() === blockKey;\\n      }).takeWhile(function (block) {\\n        var key = block.getKey();\\n        var isBlockToBeMoved = key === blockKey;\\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\\n\\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\\n      }).forEach(function (block) {\\n        blocksToBeMoved.push(block);\\n        blocks['delete'](block.getKey());\\n      });\\n    });\\n  }\\n\\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\\n    return v === targetBlock;\\n  });\\n\\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\\n    return v === targetBlock;\\n  }).skip(1);\\n\\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\\n    return [block.getKey(), block];\\n  });\\n\\n  var newBlocks = OrderedMap();\\n\\n  if (insertionMode === 'before') {\\n    var blockBefore = contentState.getBlockBefore(targetKey);\\n\\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\\n\\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\\n  } else if (insertionMode === 'after') {\\n    var blockAfter = contentState.getBlockAfter(targetKey);\\n\\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\\n\\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\\n  }\\n\\n  return contentState.merge({\\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\\n    selectionBefore: contentState.getSelectionAfter(),\\n    selectionAfter: contentState.getSelectionAfter().merge({\\n      anchorKey: blockKey,\\n      focusKey: blockKey\\n    })\\n  });\\n};\\n\\nmodule.exports = moveBlockInContentState;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"ContentBlockNode\",\"Immutable\",\"getNextDelimiterBlockKey\",\"invariant\",\"OrderedMap\",\"List\",\"transformBlock\",\"key\",\"blockMap\",\"func\",\"block\",\"get\",\"set\",\"updateBlockMapLinks\",\"originalBlockToBeMoved\",\"originalTargetBlock\",\"insertionMode\",\"isExperimentalTreeBlock\",\"isInsertedAfterTarget\",\"originalBlockKey\",\"getKey\",\"originalTargetKey\",\"originalParentKey\",\"getParentKey\",\"originalNextSiblingKey\",\"getNextSiblingKey\",\"originalPrevSiblingKey\",\"getPrevSiblingKey\",\"newParentKey\",\"newNextSiblingKey\",\"newPrevSiblingKey\",\"withMutations\",\"blocks\",\"parentChildrenList\",\"getChildKeys\",\"merge\",\"children\",\"indexOf\",\"nextSibling\",\"prevSibling\",\"newParentChildrenList\",\"targetBlockIndex\",\"insertionIndex\",\"newChildrenArray\",\"toArray\",\"splice\",\"parent\",\"moveBlockInContentState\",\"contentState\",\"blockToBeMoved\",\"targetBlock\",\"targetKey\",\"blockKey\",\"getBlockMap\",\"blocksToBeMoved\",\"blockMapWithoutBlocksToBeMoved\",\"nextSiblingKey\",\"nextDelimiterBlockKey\",\"toSeq\",\"skipUntil\",\"takeWhile\",\"isBlockToBeMoved\",\"hasNextSiblingAndIsNotNextSibling\",\"doesNotHaveNextSiblingAndIsNotDelimiter\",\"forEach\",\"push\",\"blocksBefore\",\"takeUntil\",\"v\",\"blocksAfter\",\"skip\",\"slicedBlocks\",\"map\",\"newBlocks\",\"blockBefore\",\"getBlockBefore\",\"concat\",\"toOrderedMap\",\"blockAfter\",\"getBlockAfter\",\"selectionBefore\",\"getSelectionAfter\",\"selectionAfter\",\"anchorKey\",\"focusKey\"]\n}\n"]