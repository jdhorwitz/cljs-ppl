["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/removeRangeFromContentState.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$removeRangeFromContentState=function(global,process,require,module,exports,shadow$shims){var ContentBlockNode=require(\"module$node_modules$draft_js$lib$ContentBlockNode\");global=require(\"module$node_modules$immutable$dist$immutable\");var getNextDelimiterBlockKey=require(\"module$node_modules$draft_js$lib$getNextDelimiterBlockKey\"),Map=global.Map,transformBlock=function(key,blockMap,func){if(key){var block=blockMap.get(key);block&&blockMap.set(key,func(block))}},\ngetAncestorsKeys=function(blockKey,blockMap){var parents=[];if(!blockKey)return parents;for(blockKey=blockMap.get(blockKey);blockKey&&blockKey.getParentKey();)(blockKey=blockKey.getParentKey())&&parents.push(blockKey),blockKey=blockKey?blockMap.get(blockKey):null;return parents},getNextDelimitersBlockKeys=function(block,blockMap){var nextDelimiters=[];if(!block)return nextDelimiters;for(block=getNextDelimiterBlockKey(block,blockMap);block&&blockMap.get(block);){var _block=blockMap.get(block);nextDelimiters.push(block);\nblock=_block.getParentKey()?getNextDelimiterBlockKey(_block,blockMap):null}return nextDelimiters},getNextValidSibling=function(block,blockMap,originalBlockMap){if(!block)return null;for(block=originalBlockMap.get(block.getKey()).getNextSiblingKey();block&&!blockMap.get(block);)block=originalBlockMap.get(block).getNextSiblingKey()||null;return block},getPrevValidSibling=function(block,blockMap,originalBlockMap){if(!block)return null;for(block=originalBlockMap.get(block.getKey()).getPrevSiblingKey();block&&\n!blockMap.get(block);)block=originalBlockMap.get(block).getPrevSiblingKey()||null;return block},updateBlockMapLinks=function(blockMap,startBlock,endBlock,originalBlockMap){return blockMap.withMutations(function(blocks){transformBlock(startBlock.getKey(),blocks,function(block){return block.merge({nextSibling:getNextValidSibling(startBlock,blocks,originalBlockMap),prevSibling:getPrevValidSibling(startBlock,blocks,originalBlockMap)})});transformBlock(endBlock.getKey(),blocks,function(block){return block.merge({nextSibling:getNextValidSibling(endBlock,\nblocks,originalBlockMap),prevSibling:getPrevValidSibling(endBlock,blocks,originalBlockMap)})});getAncestorsKeys(startBlock.getKey(),originalBlockMap).forEach(function(parentKey){return transformBlock(parentKey,blocks,function(block){return block.merge({children:block.getChildKeys().filter(function(key){return blocks.get(key)}),nextSibling:getNextValidSibling(block,blocks,originalBlockMap),prevSibling:getPrevValidSibling(block,blocks,originalBlockMap)})})});transformBlock(startBlock.getNextSiblingKey(),\nblocks,function(block){return block.merge({prevSibling:startBlock.getPrevSiblingKey()})});transformBlock(startBlock.getPrevSiblingKey(),blocks,function(block){return block.merge({nextSibling:getNextValidSibling(startBlock,blocks,originalBlockMap)})});transformBlock(endBlock.getNextSiblingKey(),blocks,function(block){return block.merge({prevSibling:getPrevValidSibling(endBlock,blocks,originalBlockMap)})});transformBlock(endBlock.getPrevSiblingKey(),blocks,function(block){return block.merge({nextSibling:endBlock.getNextSiblingKey()})});\ngetAncestorsKeys(endBlock.getKey(),originalBlockMap).forEach(function(parentKey){transformBlock(parentKey,blocks,function(block){return block.merge({children:block.getChildKeys().filter(function(key){return blocks.get(key)}),nextSibling:getNextValidSibling(block,blocks,originalBlockMap),prevSibling:getPrevValidSibling(block,blocks,originalBlockMap)})})});getNextDelimitersBlockKeys(endBlock,originalBlockMap).forEach(function(delimiterKey){return transformBlock(delimiterKey,blocks,function(block){return block.merge({nextSibling:getNextValidSibling(block,\nblocks,originalBlockMap),prevSibling:getPrevValidSibling(block,blocks,originalBlockMap)})})})})},removeFromList=function(targetList,startOffset,endOffset){if(0===startOffset)for(;startOffset<endOffset;)targetList=targetList.shift(),startOffset++;else if(endOffset===targetList.count())for(;endOffset>startOffset;)targetList=targetList.pop(),endOffset--;else startOffset=targetList.slice(0,startOffset),targetList=targetList.slice(endOffset),targetList=startOffset.concat(targetList).toList();return targetList};\nmodule.exports=function(contentState,selectionState){if(selectionState.isCollapsed())return contentState;var blockMap=contentState.getBlockMap(),startKey=selectionState.getStartKey(),startOffset=selectionState.getStartOffset(),endKey=selectionState.getEndKey(),endOffset=selectionState.getEndOffset(),startBlock=blockMap.get(startKey),endBlock=blockMap.get(endKey),isExperimentalTreeBlock=startBlock instanceof ContentBlockNode,parentAncestors=[];if(isExperimentalTreeBlock){var endBlockchildrenKeys=endBlock.getChildKeys(),\nendBlockAncestors=getAncestorsKeys(endKey,blockMap);endBlock.getNextSiblingKey()&&(parentAncestors=parentAncestors.concat(endBlockAncestors));endBlockchildrenKeys.isEmpty()||(parentAncestors=parentAncestors.concat(endBlockAncestors.concat([endKey])));parentAncestors=parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock,blockMap),blockMap))}endBlockchildrenKeys=void 0;endBlockchildrenKeys=startBlock===endBlock?removeFromList(startBlock.getCharacterList(),startOffset,endOffset):\nstartBlock.getCharacterList().slice(0,startOffset).concat(endBlock.getCharacterList().slice(endOffset));var modifiedStart=startBlock.merge({text:startBlock.getText().slice(0,startOffset)+endBlock.getText().slice(endOffset),characterList:endBlockchildrenKeys});endOffset=blockMap.toSeq().skipUntil(function(_,k){return k===startKey}).takeUntil(function(_,k){return k===endKey}).filter(function(_,k){return-1===parentAncestors.indexOf(k)}).concat(Map([[endKey,null]])).map(function(_,k){return k===startKey?\nmodifiedStart:null});endOffset=blockMap.merge(endOffset).filter(function(block){return!!block});isExperimentalTreeBlock&&(endOffset=updateBlockMapLinks(endOffset,startBlock,endBlock,blockMap));return contentState.merge({blockMap:endOffset,selectionBefore:selectionState,selectionAfter:selectionState.merge({anchorKey:startKey,anchorOffset:startOffset,focusKey:startKey,focusOffset:startOffset,isBackward:!1})})}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$removeRangeFromContentState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule removeRangeFromContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n\n  if (!blockKey) {\n    return parents;\n  }\n\n  var blockNode = blockMap.get(blockKey);\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n\n  return parents;\n};\n\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n\n  if (!block) {\n    return nextDelimiters;\n  }\n\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n    nextDelimiters.push(nextDelimiter);\n\n    // we do not need to keep checking all root node siblings, just the first occurance\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n\n  return nextDelimiters;\n};\n\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  }\n\n  // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n\n  return nextValidSiblingKey;\n};\n\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  }\n\n  // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n\n  return prevValidSiblingKey;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update endblock if its retained\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(endBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update start block parent ancestors\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n\n    // update start block next - can only happen if startBlock == endBlock\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    });\n\n    // update start block prev\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update end block next\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update end block prev\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    });\n\n    // update end block parent ancestors\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n\n    // update next delimiters all the way to a root delimiter\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n  });\n};\n\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey);\n\n  // we assume that ContentBlockNode and ContentBlocks are not mixed together\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode;\n\n  // used to retain blocks that should not be deleted to avoid orphan children\n  var parentAncestors = [];\n\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap);\n\n    // endBlock has unselected sibblings so we can not remove its ancestors parents\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    }\n\n    // endBlock has children so can not remove this block or any of its ancestors\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    }\n\n    // we need to retain all ancestors of the next delimiter block\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n\n  var characterList = void 0;\n\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  });\n\n  var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  });\n\n  if (isExperimentalTreeBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n  return targetList;\n};\n\nmodule.exports = removeRangeFromContentState;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$draft_js$lib$ContentBlockNode","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$draft_js$lib$getNextDelimiterBlockKey"]],"~:properties",["^5",["selectionBefore","anchorOffset","isBackward","selectionAfter","children","nextSibling","anchorKey","text","focusKey","focusOffset","characterList","blockMap","prevSibling"]],"~:compiled-at",1532351402129,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$removeRangeFromContentState.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/removeRangeFromContentState.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$removeRangeFromContentState\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule removeRangeFromContentState\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar ContentBlockNode = require('./ContentBlockNode');\\nvar Immutable = require('immutable');\\n\\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\\n\\nvar List = Immutable.List,\\n    Map = Immutable.Map;\\n\\n\\nvar transformBlock = function transformBlock(key, blockMap, func) {\\n  if (!key) {\\n    return;\\n  }\\n\\n  var block = blockMap.get(key);\\n\\n  if (!block) {\\n    return;\\n  }\\n\\n  blockMap.set(key, func(block));\\n};\\n\\n/**\\n * Ancestors needs to be preserved when there are non selected\\n * children to make sure we do not leave any orphans behind\\n */\\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\\n  var parents = [];\\n\\n  if (!blockKey) {\\n    return parents;\\n  }\\n\\n  var blockNode = blockMap.get(blockKey);\\n  while (blockNode && blockNode.getParentKey()) {\\n    var parentKey = blockNode.getParentKey();\\n    if (parentKey) {\\n      parents.push(parentKey);\\n    }\\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\\n  }\\n\\n  return parents;\\n};\\n\\n/**\\n * Get all next delimiter keys until we hit a root delimiter and return\\n * an array of key references\\n */\\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\\n  var nextDelimiters = [];\\n\\n  if (!block) {\\n    return nextDelimiters;\\n  }\\n\\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\\n    var _block = blockMap.get(nextDelimiter);\\n    nextDelimiters.push(nextDelimiter);\\n\\n    // we do not need to keep checking all root node siblings, just the first occurance\\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\\n  }\\n\\n  return nextDelimiters;\\n};\\n\\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\\n  if (!block) {\\n    return null;\\n  }\\n\\n  // note that we need to make sure we refer to the original block since this\\n  // function is called within a withMutations\\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\\n\\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\\n  }\\n\\n  return nextValidSiblingKey;\\n};\\n\\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\\n  if (!block) {\\n    return null;\\n  }\\n\\n  // note that we need to make sure we refer to the original block since this\\n  // function is called within a withMutations\\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\\n\\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\\n  }\\n\\n  return prevValidSiblingKey;\\n};\\n\\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\\n  return blockMap.withMutations(function (blocks) {\\n    // update start block if its retained\\n    transformBlock(startBlock.getKey(), blocks, function (block) {\\n      return block.merge({\\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap),\\n        prevSibling: getPrevValidSibling(startBlock, blocks, originalBlockMap)\\n      });\\n    });\\n\\n    // update endblock if its retained\\n    transformBlock(endBlock.getKey(), blocks, function (block) {\\n      return block.merge({\\n        nextSibling: getNextValidSibling(endBlock, blocks, originalBlockMap),\\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\\n      });\\n    });\\n\\n    // update start block parent ancestors\\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\\n      return transformBlock(parentKey, blocks, function (block) {\\n        return block.merge({\\n          children: block.getChildKeys().filter(function (key) {\\n            return blocks.get(key);\\n          }),\\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\\n        });\\n      });\\n    });\\n\\n    // update start block next - can only happen if startBlock == endBlock\\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\\n      return block.merge({\\n        prevSibling: startBlock.getPrevSiblingKey()\\n      });\\n    });\\n\\n    // update start block prev\\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\\n      return block.merge({\\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap)\\n      });\\n    });\\n\\n    // update end block next\\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\\n      return block.merge({\\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\\n      });\\n    });\\n\\n    // update end block prev\\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\\n      return block.merge({\\n        nextSibling: endBlock.getNextSiblingKey()\\n      });\\n    });\\n\\n    // update end block parent ancestors\\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\\n      transformBlock(parentKey, blocks, function (block) {\\n        return block.merge({\\n          children: block.getChildKeys().filter(function (key) {\\n            return blocks.get(key);\\n          }),\\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\\n        });\\n      });\\n    });\\n\\n    // update next delimiters all the way to a root delimiter\\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\\n      return transformBlock(delimiterKey, blocks, function (block) {\\n        return block.merge({\\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\\n        });\\n      });\\n    });\\n  });\\n};\\n\\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\\n  if (selectionState.isCollapsed()) {\\n    return contentState;\\n  }\\n\\n  var blockMap = contentState.getBlockMap();\\n  var startKey = selectionState.getStartKey();\\n  var startOffset = selectionState.getStartOffset();\\n  var endKey = selectionState.getEndKey();\\n  var endOffset = selectionState.getEndOffset();\\n\\n  var startBlock = blockMap.get(startKey);\\n  var endBlock = blockMap.get(endKey);\\n\\n  // we assume that ContentBlockNode and ContentBlocks are not mixed together\\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode;\\n\\n  // used to retain blocks that should not be deleted to avoid orphan children\\n  var parentAncestors = [];\\n\\n  if (isExperimentalTreeBlock) {\\n    var endBlockchildrenKeys = endBlock.getChildKeys();\\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap);\\n\\n    // endBlock has unselected sibblings so we can not remove its ancestors parents\\n    if (endBlock.getNextSiblingKey()) {\\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\\n    }\\n\\n    // endBlock has children so can not remove this block or any of its ancestors\\n    if (!endBlockchildrenKeys.isEmpty()) {\\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\\n    }\\n\\n    // we need to retain all ancestors of the next delimiter block\\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\\n  }\\n\\n  var characterList = void 0;\\n\\n  if (startBlock === endBlock) {\\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\\n  } else {\\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\\n  }\\n\\n  var modifiedStart = startBlock.merge({\\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\\n    characterList: characterList\\n  });\\n\\n  var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {\\n    return k === startKey;\\n  }).takeUntil(function (_, k) {\\n    return k === endKey;\\n  }).filter(function (_, k) {\\n    return parentAncestors.indexOf(k) === -1;\\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\\n    return k === startKey ? modifiedStart : null;\\n  });\\n\\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\\n    return !!block;\\n  });\\n\\n  if (isExperimentalTreeBlock) {\\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\\n  }\\n\\n  return contentState.merge({\\n    blockMap: updatedBlockMap,\\n    selectionBefore: selectionState,\\n    selectionAfter: selectionState.merge({\\n      anchorKey: startKey,\\n      anchorOffset: startOffset,\\n      focusKey: startKey,\\n      focusOffset: startOffset,\\n      isBackward: false\\n    })\\n  });\\n};\\n\\n/**\\n * Maintain persistence for target list when removing characters on the\\n * head and tail of the character list.\\n */\\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\\n  if (startOffset === 0) {\\n    while (startOffset < endOffset) {\\n      targetList = targetList.shift();\\n      startOffset++;\\n    }\\n  } else if (endOffset === targetList.count()) {\\n    while (endOffset > startOffset) {\\n      targetList = targetList.pop();\\n      endOffset--;\\n    }\\n  } else {\\n    var head = targetList.slice(0, startOffset);\\n    var tail = targetList.slice(endOffset);\\n    targetList = head.concat(tail).toList();\\n  }\\n  return targetList;\\n};\\n\\nmodule.exports = removeRangeFromContentState;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"ContentBlockNode\",\"Immutable\",\"getNextDelimiterBlockKey\",\"Map\",\"transformBlock\",\"key\",\"blockMap\",\"func\",\"block\",\"get\",\"set\",\"getAncestorsKeys\",\"blockKey\",\"parents\",\"blockNode\",\"getParentKey\",\"parentKey\",\"push\",\"getNextDelimitersBlockKeys\",\"nextDelimiters\",\"nextDelimiter\",\"_block\",\"getNextValidSibling\",\"originalBlockMap\",\"nextValidSiblingKey\",\"getKey\",\"getNextSiblingKey\",\"getPrevValidSibling\",\"prevValidSiblingKey\",\"getPrevSiblingKey\",\"updateBlockMapLinks\",\"startBlock\",\"endBlock\",\"withMutations\",\"blocks\",\"merge\",\"nextSibling\",\"prevSibling\",\"forEach\",\"children\",\"getChildKeys\",\"filter\",\"delimiterKey\",\"removeFromList\",\"targetList\",\"startOffset\",\"endOffset\",\"shift\",\"count\",\"pop\",\"head\",\"slice\",\"tail\",\"concat\",\"toList\",\"removeRangeFromContentState\",\"contentState\",\"selectionState\",\"isCollapsed\",\"getBlockMap\",\"startKey\",\"getStartKey\",\"getStartOffset\",\"endKey\",\"getEndKey\",\"getEndOffset\",\"isExperimentalTreeBlock\",\"parentAncestors\",\"endBlockchildrenKeys\",\"endBlockAncestors\",\"isEmpty\",\"characterList\",\"getCharacterList\",\"modifiedStart\",\"text\",\"getText\",\"newBlocks\",\"toSeq\",\"skipUntil\",\"_\",\"k\",\"takeUntil\",\"indexOf\",\"map\",\"updatedBlockMap\",\"selectionBefore\",\"selectionAfter\",\"anchorKey\",\"anchorOffset\",\"focusKey\",\"focusOffset\",\"isBackward\"]\n}\n"]