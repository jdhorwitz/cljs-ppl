["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/editOnInput.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$editOnInput=function(global,process,require,module,exports,shadow$shims){var DraftFeatureFlags=require(\"module$node_modules$draft_js$lib$DraftFeatureFlags\"),DraftModifier=require(\"module$node_modules$draft_js$lib$DraftModifier\"),DraftOffsetKey=require(\"module$node_modules$draft_js$lib$DraftOffsetKey\"),EditorState=require(\"module$node_modules$draft_js$lib$EditorState\");process=require(\"module$node_modules$fbjs$lib$UserAgent\");var findAncestorOffsetKey=\nrequire(\"module$node_modules$draft_js$lib$findAncestorOffsetKey\"),nullthrows=require(\"module$node_modules$fbjs$lib$nullthrows\"),isGecko=process.isEngine(\"Gecko\");module.exports=function(editor){void 0!==editor._pendingStateFromBeforeInput&&(editor.update(editor._pendingStateFromBeforeInput),editor._pendingStateFromBeforeInput=void 0);var domSelection=global.getSelection(),anchorNode=domSelection.anchorNode,isCollapsed=domSelection.isCollapsed,isNotTextNode=anchorNode.nodeType!==Node.TEXT_NODE,isNotTextOrElementNode=\nanchorNode.nodeType!==Node.TEXT_NODE&&anchorNode.nodeType!==Node.ELEMENT_NODE;if(DraftFeatureFlags.draft_killswitch_allow_nontextnodes){if(isNotTextNode)return}else if(isNotTextOrElementNode)return;if(anchorNode.nodeType===Node.TEXT_NODE&&(null!==anchorNode.previousSibling||null!==anchorNode.nextSibling))for(isNotTextNode=anchorNode.parentNode,anchorNode.nodeValue=isNotTextNode.textContent,isNotTextOrElementNode=isNotTextNode.firstChild;null!==isNotTextOrElementNode;isNotTextOrElementNode=isNotTextOrElementNode.nextSibling)isNotTextOrElementNode!==\nanchorNode&&isNotTextNode.removeChild(isNotTextOrElementNode);isNotTextOrElementNode=anchorNode.textContent;isNotTextNode=editor._latestEditorState;anchorNode=nullthrows(findAncestorOffsetKey(anchorNode));var _DraftOffsetKey$decod=DraftOffsetKey.decode(anchorNode),blockKey=_DraftOffsetKey$decod.blockKey;anchorNode=_DraftOffsetKey$decod.decoratorKey;_DraftOffsetKey$decod=_DraftOffsetKey$decod.leafKey;anchorNode=isNotTextNode.getBlockTree(blockKey).getIn([anchorNode,\"leaves\",_DraftOffsetKey$decod]);\n_DraftOffsetKey$decod=anchorNode.start;var end=anchorNode.end;anchorNode=isNotTextNode.getCurrentContent();var block=anchorNode.getBlockForKey(blockKey),modelText=block.getText().slice(_DraftOffsetKey$decod,end);isNotTextOrElementNode.endsWith(\"\\n\\n\")&&(isNotTextOrElementNode=isNotTextOrElementNode.slice(0,-1));if(isNotTextOrElementNode!==modelText){blockKey=isNotTextNode.getSelection();var targetRange=blockKey.merge({anchorOffset:_DraftOffsetKey$decod,focusOffset:end,isBackward:!1});end=(end=block.getEntityAt(_DraftOffsetKey$decod))&&\nanchorNode.getEntity(end);var preserveEntity=\"MUTABLE\"===(end&&end.getMutability());end=preserveEntity?\"spellcheck-change\":\"apply-entity\";block=DraftModifier.replaceText(anchorNode,targetRange,isNotTextOrElementNode,block.getInlineStyleAt(_DraftOffsetKey$decod),preserveEntity?block.getEntityAt(_DraftOffsetKey$decod):null);isGecko?(isCollapsed=domSelection.anchorOffset,isNotTextOrElementNode=domSelection.focusOffset,domSelection=_DraftOffsetKey$decod+Math.min(isCollapsed,isNotTextOrElementNode),isNotTextOrElementNode=\ndomSelection+Math.abs(isCollapsed-isNotTextOrElementNode),isCollapsed=domSelection):(_DraftOffsetKey$decod=isNotTextOrElementNode.length-modelText.length,domSelection=blockKey.getStartOffset(),isNotTextOrElementNode=blockKey.getEndOffset(),isCollapsed=isCollapsed?isNotTextOrElementNode+_DraftOffsetKey$decod:domSelection,isNotTextOrElementNode+=_DraftOffsetKey$decod);isCollapsed=block.merge({selectionBefore:anchorNode.getSelectionAfter(),selectionAfter:blockKey.merge({anchorOffset:isCollapsed,focusOffset:isNotTextOrElementNode})});\neditor.update(EditorState.push(isNotTextNode,isCollapsed,end))}}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$editOnInput\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule editOnInput\n * @format\n * \n */\n\n'use strict';\n\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftModifier = require('./DraftModifier');\nvar DraftOffsetKey = require('./DraftOffsetKey');\nvar EditorState = require('./EditorState');\nvar UserAgent = require('fbjs/lib/UserAgent');\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\nvar nullthrows = require('fbjs/lib/nullthrows');\n\nvar isGecko = UserAgent.isEngine('Gecko');\n\nvar DOUBLE_NEWLINE = '\\n\\n';\n\n/**\n * This function is intended to handle spellcheck and autocorrect changes,\n * which occur in the DOM natively without any opportunity to observe or\n * interpret the changes before they occur.\n *\n * The `input` event fires in contentEditable elements reliably for non-IE\n * browsers, immediately after changes occur to the editor DOM. Since our other\n * handlers override or otherwise handle cover other varieties of text input,\n * the DOM state should match the model in all controlled input cases. Thus,\n * when an `input` change leads to a DOM/model mismatch, the change should be\n * due to a spellcheck change, and we can incorporate it into our model.\n */\nfunction editOnInput(editor) {\n  if (editor._pendingStateFromBeforeInput !== undefined) {\n    editor.update(editor._pendingStateFromBeforeInput);\n    editor._pendingStateFromBeforeInput = undefined;\n  }\n\n  var domSelection = global.getSelection();\n\n  var anchorNode = domSelection.anchorNode,\n      isCollapsed = domSelection.isCollapsed;\n\n  var isNotTextNode = anchorNode.nodeType !== Node.TEXT_NODE;\n  var isNotTextOrElementNode = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.ELEMENT_NODE;\n\n  if (DraftFeatureFlags.draft_killswitch_allow_nontextnodes) {\n    if (isNotTextNode) {\n      return;\n    }\n  } else {\n    if (isNotTextOrElementNode) {\n      // TODO: (t16149272) figure out context for this change\n      return;\n    }\n  }\n\n  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {\n    // When typing at the beginning of a visual line, Chrome splits the text\n    // nodes into two. Why? No one knows. This commit is suspicious:\n    // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724\n    // To work around, we'll merge the sibling text nodes back into this one.\n    var span = anchorNode.parentNode;\n    anchorNode.nodeValue = span.textContent;\n    for (var child = span.firstChild; child !== null; child = child.nextSibling) {\n      if (child !== anchorNode) {\n        span.removeChild(child);\n      }\n    }\n  }\n\n  var domText = anchorNode.textContent;\n  var editorState = editor._latestEditorState;\n  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));\n\n  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\n      blockKey = _DraftOffsetKey$decod.blockKey,\n      decoratorKey = _DraftOffsetKey$decod.decoratorKey,\n      leafKey = _DraftOffsetKey$decod.leafKey;\n\n  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\n      start = _editorState$getBlock.start,\n      end = _editorState$getBlock.end;\n\n  var content = editorState.getCurrentContent();\n  var block = content.getBlockForKey(blockKey);\n  var modelText = block.getText().slice(start, end);\n\n  // Special-case soft newlines here. If the DOM text ends in a soft newline,\n  // we will have manually inserted an extra soft newline in DraftEditorLeaf.\n  // We want to remove this extra newline for the purpose of our comparison\n  // of DOM and model text.\n  if (domText.endsWith(DOUBLE_NEWLINE)) {\n    domText = domText.slice(0, -1);\n  }\n\n  // No change -- the DOM is up to date. Nothing to do here.\n  if (domText === modelText) {\n    // This can be buggy for some Android keyboards because they don't fire\n    // standard onkeydown/pressed events and only fired editOnInput\n    // so domText is already changed by the browser and ends up being equal\n    // to modelText unexpectedly\n    return;\n  }\n\n  var selection = editorState.getSelection();\n\n  // We'll replace the entire leaf with the text content of the target.\n  var targetRange = selection.merge({\n    anchorOffset: start,\n    focusOffset: end,\n    isBackward: false\n  });\n\n  var entityKey = block.getEntityAt(start);\n  var entity = entityKey && content.getEntity(entityKey);\n  var entityType = entity && entity.getMutability();\n  var preserveEntity = entityType === 'MUTABLE';\n\n  // Immutable or segmented entities cannot properly be handled by the\n  // default browser undo, so we have to use a different change type to\n  // force using our internal undo method instead of falling through to the\n  // native browser undo.\n  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';\n\n  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);\n\n  var anchorOffset, focusOffset, startOffset, endOffset;\n\n  if (isGecko) {\n    // Firefox selection does not change while the context menu is open, so\n    // we preserve the anchor and focus values of the DOM selection.\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    startOffset = start + Math.min(anchorOffset, focusOffset);\n    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);\n    anchorOffset = startOffset;\n    focusOffset = endOffset;\n  } else {\n    // Browsers other than Firefox may adjust DOM selection while the context\n    // menu is open, and Safari autocorrect is prone to providing an inaccurate\n    // DOM selection. Don't trust it. Instead, use our existing SelectionState\n    // and adjust it based on the number of characters changed during the\n    // mutation.\n    var charDelta = domText.length - modelText.length;\n    startOffset = selection.getStartOffset();\n    endOffset = selection.getEndOffset();\n\n    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;\n    focusOffset = endOffset + charDelta;\n  }\n\n  // Segmented entities are completely or partially removed when their\n  // text content changes. For this case we do not want any text to be selected\n  // after the change, so we are not merging the selection.\n  var contentWithAdjustedDOMSelection = newContent.merge({\n    selectionBefore: content.getSelectionAfter(),\n    selectionAfter: selection.merge({ anchorOffset: anchorOffset, focusOffset: focusOffset })\n  });\n\n  editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));\n}\n\nmodule.exports = editOnInput;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$fbjs$lib$nullthrows","~$shadow.js","~$module$node_modules$draft_js$lib$DraftFeatureFlags","~$module$node_modules$draft_js$lib$DraftModifier","~$module$node_modules$draft_js$lib$DraftOffsetKey","~$module$node_modules$draft_js$lib$EditorState","~$module$node_modules$draft_js$lib$findAncestorOffsetKey","~$module$node_modules$fbjs$lib$UserAgent"]],"~:properties",["^5",["selectionBefore","_pendingStateFromBeforeInput","anchorOffset","isBackward","selectionAfter","nodeValue","focusOffset"]],"~:compiled-at",1532351402145,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$editOnInput.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/editOnInput.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$editOnInput\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule editOnInput\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\\nvar DraftModifier = require('./DraftModifier');\\nvar DraftOffsetKey = require('./DraftOffsetKey');\\nvar EditorState = require('./EditorState');\\nvar UserAgent = require('fbjs/lib/UserAgent');\\n\\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\\nvar nullthrows = require('fbjs/lib/nullthrows');\\n\\nvar isGecko = UserAgent.isEngine('Gecko');\\n\\nvar DOUBLE_NEWLINE = '\\\\n\\\\n';\\n\\n/**\\n * This function is intended to handle spellcheck and autocorrect changes,\\n * which occur in the DOM natively without any opportunity to observe or\\n * interpret the changes before they occur.\\n *\\n * The `input` event fires in contentEditable elements reliably for non-IE\\n * browsers, immediately after changes occur to the editor DOM. Since our other\\n * handlers override or otherwise handle cover other varieties of text input,\\n * the DOM state should match the model in all controlled input cases. Thus,\\n * when an `input` change leads to a DOM/model mismatch, the change should be\\n * due to a spellcheck change, and we can incorporate it into our model.\\n */\\nfunction editOnInput(editor) {\\n  if (editor._pendingStateFromBeforeInput !== undefined) {\\n    editor.update(editor._pendingStateFromBeforeInput);\\n    editor._pendingStateFromBeforeInput = undefined;\\n  }\\n\\n  var domSelection = global.getSelection();\\n\\n  var anchorNode = domSelection.anchorNode,\\n      isCollapsed = domSelection.isCollapsed;\\n\\n  var isNotTextNode = anchorNode.nodeType !== Node.TEXT_NODE;\\n  var isNotTextOrElementNode = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.ELEMENT_NODE;\\n\\n  if (DraftFeatureFlags.draft_killswitch_allow_nontextnodes) {\\n    if (isNotTextNode) {\\n      return;\\n    }\\n  } else {\\n    if (isNotTextOrElementNode) {\\n      // TODO: (t16149272) figure out context for this change\\n      return;\\n    }\\n  }\\n\\n  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {\\n    // When typing at the beginning of a visual line, Chrome splits the text\\n    // nodes into two. Why? No one knows. This commit is suspicious:\\n    // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724\\n    // To work around, we'll merge the sibling text nodes back into this one.\\n    var span = anchorNode.parentNode;\\n    anchorNode.nodeValue = span.textContent;\\n    for (var child = span.firstChild; child !== null; child = child.nextSibling) {\\n      if (child !== anchorNode) {\\n        span.removeChild(child);\\n      }\\n    }\\n  }\\n\\n  var domText = anchorNode.textContent;\\n  var editorState = editor._latestEditorState;\\n  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));\\n\\n  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\\n      blockKey = _DraftOffsetKey$decod.blockKey,\\n      decoratorKey = _DraftOffsetKey$decod.decoratorKey,\\n      leafKey = _DraftOffsetKey$decod.leafKey;\\n\\n  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\\n      start = _editorState$getBlock.start,\\n      end = _editorState$getBlock.end;\\n\\n  var content = editorState.getCurrentContent();\\n  var block = content.getBlockForKey(blockKey);\\n  var modelText = block.getText().slice(start, end);\\n\\n  // Special-case soft newlines here. If the DOM text ends in a soft newline,\\n  // we will have manually inserted an extra soft newline in DraftEditorLeaf.\\n  // We want to remove this extra newline for the purpose of our comparison\\n  // of DOM and model text.\\n  if (domText.endsWith(DOUBLE_NEWLINE)) {\\n    domText = domText.slice(0, -1);\\n  }\\n\\n  // No change -- the DOM is up to date. Nothing to do here.\\n  if (domText === modelText) {\\n    // This can be buggy for some Android keyboards because they don't fire\\n    // standard onkeydown/pressed events and only fired editOnInput\\n    // so domText is already changed by the browser and ends up being equal\\n    // to modelText unexpectedly\\n    return;\\n  }\\n\\n  var selection = editorState.getSelection();\\n\\n  // We'll replace the entire leaf with the text content of the target.\\n  var targetRange = selection.merge({\\n    anchorOffset: start,\\n    focusOffset: end,\\n    isBackward: false\\n  });\\n\\n  var entityKey = block.getEntityAt(start);\\n  var entity = entityKey && content.getEntity(entityKey);\\n  var entityType = entity && entity.getMutability();\\n  var preserveEntity = entityType === 'MUTABLE';\\n\\n  // Immutable or segmented entities cannot properly be handled by the\\n  // default browser undo, so we have to use a different change type to\\n  // force using our internal undo method instead of falling through to the\\n  // native browser undo.\\n  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';\\n\\n  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);\\n\\n  var anchorOffset, focusOffset, startOffset, endOffset;\\n\\n  if (isGecko) {\\n    // Firefox selection does not change while the context menu is open, so\\n    // we preserve the anchor and focus values of the DOM selection.\\n    anchorOffset = domSelection.anchorOffset;\\n    focusOffset = domSelection.focusOffset;\\n    startOffset = start + Math.min(anchorOffset, focusOffset);\\n    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);\\n    anchorOffset = startOffset;\\n    focusOffset = endOffset;\\n  } else {\\n    // Browsers other than Firefox may adjust DOM selection while the context\\n    // menu is open, and Safari autocorrect is prone to providing an inaccurate\\n    // DOM selection. Don't trust it. Instead, use our existing SelectionState\\n    // and adjust it based on the number of characters changed during the\\n    // mutation.\\n    var charDelta = domText.length - modelText.length;\\n    startOffset = selection.getStartOffset();\\n    endOffset = selection.getEndOffset();\\n\\n    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;\\n    focusOffset = endOffset + charDelta;\\n  }\\n\\n  // Segmented entities are completely or partially removed when their\\n  // text content changes. For this case we do not want any text to be selected\\n  // after the change, so we are not merging the selection.\\n  var contentWithAdjustedDOMSelection = newContent.merge({\\n    selectionBefore: content.getSelectionAfter(),\\n    selectionAfter: selection.merge({ anchorOffset: anchorOffset, focusOffset: focusOffset })\\n  });\\n\\n  editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));\\n}\\n\\nmodule.exports = editOnInput;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"DraftFeatureFlags\",\"DraftModifier\",\"DraftOffsetKey\",\"EditorState\",\"UserAgent\",\"findAncestorOffsetKey\",\"nullthrows\",\"isGecko\",\"isEngine\",\"editOnInput\",\"editor\",\"undefined\",\"_pendingStateFromBeforeInput\",\"update\",\"domSelection\",\"getSelection\",\"anchorNode\",\"isCollapsed\",\"isNotTextNode\",\"nodeType\",\"Node\",\"TEXT_NODE\",\"isNotTextOrElementNode\",\"ELEMENT_NODE\",\"draft_killswitch_allow_nontextnodes\",\"previousSibling\",\"nextSibling\",\"span\",\"child\",\"parentNode\",\"nodeValue\",\"textContent\",\"firstChild\",\"removeChild\",\"domText\",\"editorState\",\"_latestEditorState\",\"offsetKey\",\"_DraftOffsetKey$decod\",\"decode\",\"blockKey\",\"decoratorKey\",\"leafKey\",\"_editorState$getBlock\",\"getBlockTree\",\"getIn\",\"start\",\"end\",\"content\",\"getCurrentContent\",\"block\",\"getBlockForKey\",\"modelText\",\"getText\",\"slice\",\"endsWith\",\"DOUBLE_NEWLINE\",\"selection\",\"targetRange\",\"merge\",\"anchorOffset\",\"focusOffset\",\"isBackward\",\"entity\",\"entityKey\",\"getEntityAt\",\"getEntity\",\"preserveEntity\",\"getMutability\",\"changeType\",\"newContent\",\"replaceText\",\"getInlineStyleAt\",\"startOffset\",\"Math\",\"min\",\"endOffset\",\"abs\",\"charDelta\",\"length\",\"getStartOffset\",\"getEndOffset\",\"contentWithAdjustedDOMSelection\",\"selectionBefore\",\"getSelectionAfter\",\"selectionAfter\",\"push\"]\n}\n"]