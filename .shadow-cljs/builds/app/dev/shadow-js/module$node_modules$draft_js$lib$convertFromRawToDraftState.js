["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/draft-js/lib/convertFromRawToDraftState.js"],"~:js","shadow$provide.module$node_modules$draft_js$lib$convertFromRawToDraftState=function(global,process,require,module,exports,shadow$shims){var _extends=require(\"module$node_modules$object_assign$index\")||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},ContentBlock=require(\"module$node_modules$draft_js$lib$ContentBlock\"),ContentBlockNode=require(\"module$node_modules$draft_js$lib$ContentBlockNode\"),\nContentState=require(\"module$node_modules$draft_js$lib$ContentState\"),DraftEntity=require(\"module$node_modules$draft_js$lib$DraftEntity\");global=require(\"module$node_modules$draft_js$lib$DraftFeatureFlags\");var DraftTreeAdapter=require(\"module$node_modules$draft_js$lib$DraftTreeAdapter\");process=require(\"module$node_modules$immutable$dist$immutable\");var SelectionState=require(\"module$node_modules$draft_js$lib$SelectionState\"),createCharacterList=require(\"module$node_modules$draft_js$lib$createCharacterList\"),\ndecodeEntityRanges=require(\"module$node_modules$draft_js$lib$decodeEntityRanges\"),decodeInlineStyleRanges=require(\"module$node_modules$draft_js$lib$decodeInlineStyleRanges\"),generateRandomKey=require(\"module$node_modules$draft_js$lib$generateRandomKey\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),experimentalTreeDataSupport=global.draft_tree_data_support,List=process.List,Map=process.Map,OrderedMap=process.OrderedMap,decodeBlockNodeConfig=function(block,entityMap){var data=block.data;\nreturn{text:block.text,depth:block.depth||0,type:block.type||\"unstyled\",key:block.key||generateRandomKey(),data:Map(data),characterList:decodeCharacterList(block,entityMap)}},decodeCharacterList=function(block,entityMap){var text=block.text,entityRanges=block.entityRanges||[];return createCharacterList(decodeInlineStyleRanges(text,block.inlineStyleRanges||[]),decodeEntityRanges(text,entityRanges.filter(function(range){return entityMap.hasOwnProperty(range.key)}).map(function(range){return _extends({},\nrange,{key:entityMap[range.key]})})))},addKeyIfMissing=function(block){return _extends({},block,{key:block.key||generateRandomKey()})},updateNodeStack=function(stack,nodes,parentRef){nodes=nodes.map(function(block){return _extends({},block,{parentRef:parentRef})});return stack.concat(nodes.reverse())},decodeContentBlockNodes=function(blocks,entityMap){return blocks.map(addKeyIfMissing).reduce(function(blockMap,block,index){Array.isArray(block.children)?void 0:invariant(!1,\"invalid RawDraftContentBlock can not be converted to ContentBlockNode\");\nvar children=block.children.map(addKeyIfMissing);block=new ContentBlockNode(_extends({},decodeBlockNodeConfig(block,entityMap),{prevSibling:0===index?null:blocks[index-1].key,nextSibling:index===blocks.length-1?null:blocks[index+1].key,children:List(children.map(function(child){return child.key}))}));blockMap=blockMap.set(block.getKey(),block);for(children=updateNodeStack([],children,block);0<children.length;){block=children.pop();index=block.parentRef;var siblings=index.getChildKeys(),_index=siblings.indexOf(block.key),\nisValidBlock=Array.isArray(block.children);if(!isValidBlock){isValidBlock?void 0:invariant(!1,\"invalid RawDraftContentBlock can not be converted to ContentBlockNode\");break}isValidBlock=block.children.map(addKeyIfMissing);block=new ContentBlockNode(_extends({},decodeBlockNodeConfig(block,entityMap),{parent:index.getKey(),children:List(isValidBlock.map(function(child){return child.key})),prevSibling:0===_index?null:siblings.get(_index-1),nextSibling:_index===siblings.size-1?null:siblings.get(_index+\n1)}));blockMap=blockMap.set(block.getKey(),block);children=updateNodeStack(children,isValidBlock,block)}return blockMap},OrderedMap())},decodeContentBlocks=function(blocks,entityMap){return OrderedMap(blocks.map(function(block){block=new ContentBlock(decodeBlockNodeConfig(block,entityMap));return[block.getKey(),block]}))},decodeRawEntityMap=function(rawState){var rawEntityMap=rawState.entityMap,entityMap={};Object.keys(rawEntityMap).forEach(function(rawEntityKey){var _rawEntityMap$rawEnti=rawEntityMap[rawEntityKey];\nentityMap[rawEntityKey]=DraftEntity.__create(_rawEntityMap$rawEnti.type,_rawEntityMap$rawEnti.mutability,_rawEntityMap$rawEnti.data||{})});return entityMap};module.exports=function(rawState){Array.isArray(rawState.blocks)?void 0:invariant(!1,\"invalid RawDraftContentState\");var entityMap=decodeRawEntityMap(rawState);var isTreeRawBlock=Array.isArray(rawState.blocks[0].children),rawBlocks=experimentalTreeDataSupport&&!isTreeRawBlock?DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks:rawState.blocks;\nrawState=experimentalTreeDataSupport?decodeContentBlockNodes(rawBlocks,entityMap):decodeContentBlocks(isTreeRawBlock?DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks:rawBlocks,entityMap);isTreeRawBlock=rawState.isEmpty()?new SelectionState:SelectionState.createEmpty(rawState.first().getKey());return new ContentState({blockMap:rawState,entityMap:entityMap,selectionBefore:isTreeRawBlock,selectionAfter:isTreeRawBlock})}}","~:source","shadow$provide[\"module$node_modules$draft_js$lib$convertFromRawToDraftState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule convertFromRawToDraftState\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar ContentBlock = require('./ContentBlock');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar ContentState = require('./ContentState');\nvar DraftEntity = require('./DraftEntity');\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftTreeAdapter = require('./DraftTreeAdapter');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\n\nvar createCharacterList = require('./createCharacterList');\nvar decodeEntityRanges = require('./decodeEntityRanges');\nvar decodeInlineStyleRanges = require('./decodeInlineStyleRanges');\nvar generateRandomKey = require('./generateRandomKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\n\nvar List = Immutable.List,\n    Map = Immutable.Map,\n    OrderedMap = Immutable.OrderedMap;\n\n\nvar decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {\n  var key = block.key,\n      type = block.type,\n      data = block.data,\n      text = block.text,\n      depth = block.depth;\n\n\n  var blockNodeConfig = {\n    text: text,\n    depth: depth || 0,\n    type: type || 'unstyled',\n    key: key || generateRandomKey(),\n    data: Map(data),\n    characterList: decodeCharacterList(block, entityMap)\n  };\n\n  return blockNodeConfig;\n};\n\nvar decodeCharacterList = function decodeCharacterList(block, entityMap) {\n  var text = block.text,\n      rawEntityRanges = block.entityRanges,\n      rawInlineStyleRanges = block.inlineStyleRanges;\n\n\n  var entityRanges = rawEntityRanges || [];\n  var inlineStyleRanges = rawInlineStyleRanges || [];\n\n  // Translate entity range keys to the DraftEntity map.\n  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {\n    return entityMap.hasOwnProperty(range.key);\n  }).map(function (range) {\n    return _extends({}, range, { key: entityMap[range.key] });\n  })));\n};\n\nvar addKeyIfMissing = function addKeyIfMissing(block) {\n  return _extends({}, block, {\n    key: block.key || generateRandomKey()\n  });\n};\n\n/**\n * Node stack is responsible to ensure we traverse the tree only once\n * in depth order, while also providing parent refs to inner nodes to\n * construct their links.\n */\nvar updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {\n  var nodesWithParentRef = nodes.map(function (block) {\n    return _extends({}, block, {\n      parentRef: parentRef\n    });\n  });\n\n  // since we pop nodes from the stack we need to insert them in reverse\n  return stack.concat(nodesWithParentRef.reverse());\n};\n\n/**\n * This will build a tree draft content state by creating the node\n * reference links into a single tree walk. Each node has a link\n * reference to \"parent\", \"children\", \"nextSibling\" and \"prevSibling\"\n * blockMap will be created using depth ordering.\n */\nvar decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {\n  return blocks\n  // ensure children have valid keys to enable sibling links\n  .map(addKeyIfMissing).reduce(function (blockMap, block, index) {\n    !Array.isArray(block.children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n\n    // ensure children have valid keys to enable sibling links\n    var children = block.children.map(addKeyIfMissing);\n\n    // root level nodes\n    var contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(block, entityMap), {\n      prevSibling: index === 0 ? null : blocks[index - 1].key,\n      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,\n      children: List(children.map(function (child) {\n        return child.key;\n      }))\n    }));\n\n    // push root node to blockMap\n    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);\n\n    // this stack is used to ensure we visit all nodes respecting depth ordering\n    var stack = updateNodeStack([], children, contentBlockNode);\n\n    // start computing children nodes\n    while (stack.length > 0) {\n      // we pop from the stack and start processing this node\n      var node = stack.pop();\n\n      // parentRef already points to a converted ContentBlockNode\n      var parentRef = node.parentRef;\n      var siblings = parentRef.getChildKeys();\n      var _index = siblings.indexOf(node.key);\n      var isValidBlock = Array.isArray(node.children);\n\n      if (!isValidBlock) {\n        !isValidBlock ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n        break;\n      }\n\n      // ensure children have valid keys to enable sibling links\n      var _children = node.children.map(addKeyIfMissing);\n\n      var _contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(node, entityMap), {\n        parent: parentRef.getKey(),\n        children: List(_children.map(function (child) {\n          return child.key;\n        })),\n        prevSibling: _index === 0 ? null : siblings.get(_index - 1),\n        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)\n      }));\n\n      // push node to blockMap\n      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);\n\n      // this stack is used to ensure we visit all nodes respecting depth ordering\n      stack = updateNodeStack(stack, _children, _contentBlockNode);\n    }\n\n    return blockMap;\n  }, OrderedMap());\n};\n\nvar decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {\n  return OrderedMap(blocks.map(function (block) {\n    var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));\n    return [contentBlock.getKey(), contentBlock];\n  }));\n};\n\nvar decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {\n  var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);\n  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;\n\n  if (!experimentalTreeDataSupport) {\n    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);\n  }\n\n  return decodeContentBlockNodes(rawBlocks, entityMap);\n};\n\nvar decodeRawEntityMap = function decodeRawEntityMap(rawState) {\n  var rawEntityMap = rawState.entityMap;\n\n  var entityMap = {};\n\n  // TODO: Update this once we completely remove DraftEntity\n  Object.keys(rawEntityMap).forEach(function (rawEntityKey) {\n    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],\n        type = _rawEntityMap$rawEnti.type,\n        mutability = _rawEntityMap$rawEnti.mutability,\n        data = _rawEntityMap$rawEnti.data;\n\n    // get the key reference to created entity\n\n    entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});\n  });\n\n  return entityMap;\n};\n\nvar convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {\n  !Array.isArray(rawState.blocks) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentState') : invariant(false) : void 0;\n\n  // decode entities\n  var entityMap = decodeRawEntityMap(rawState);\n\n  // decode blockMap\n  var blockMap = decodeRawBlocks(rawState, entityMap);\n\n  // create initial selection\n  var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());\n\n  return new ContentState({\n    blockMap: blockMap,\n    entityMap: entityMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState\n  });\n};\n\nmodule.exports = convertFromRawToDraftState;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$draft_js$lib$createCharacterList","~$module$node_modules$draft_js$lib$ContentState","~$module$node_modules$draft_js$lib$decodeInlineStyleRanges","~$module$node_modules$object_assign$index","~$module$node_modules$draft_js$lib$ContentBlock","~$shadow.js","~$module$node_modules$draft_js$lib$DraftFeatureFlags","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$draft_js$lib$SelectionState","~$module$node_modules$draft_js$lib$ContentBlockNode","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$draft_js$lib$DraftTreeAdapter","~$module$node_modules$draft_js$lib$decodeEntityRanges","~$module$node_modules$draft_js$lib$generateRandomKey","~$module$node_modules$draft_js$lib$DraftEntity"]],"~:properties",["^5",["selectionBefore","entityMap","selectionAfter","key","parent","children","nextSibling","parentRef","text","characterList","blockMap","type","depth","data","prevSibling"]],"~:compiled-at",1532351402155,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$draft_js$lib$convertFromRawToDraftState.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/draft-js/lib/convertFromRawToDraftState.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$draft_js$lib$convertFromRawToDraftState\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule convertFromRawToDraftState\\n * @format\\n * \\n */\\n\\n'use strict';\\n\\nvar _assign = require('object-assign');\\n\\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nvar ContentBlock = require('./ContentBlock');\\nvar ContentBlockNode = require('./ContentBlockNode');\\nvar ContentState = require('./ContentState');\\nvar DraftEntity = require('./DraftEntity');\\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\\nvar DraftTreeAdapter = require('./DraftTreeAdapter');\\nvar Immutable = require('immutable');\\nvar SelectionState = require('./SelectionState');\\n\\nvar createCharacterList = require('./createCharacterList');\\nvar decodeEntityRanges = require('./decodeEntityRanges');\\nvar decodeInlineStyleRanges = require('./decodeInlineStyleRanges');\\nvar generateRandomKey = require('./generateRandomKey');\\nvar invariant = require('fbjs/lib/invariant');\\n\\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\\n\\nvar List = Immutable.List,\\n    Map = Immutable.Map,\\n    OrderedMap = Immutable.OrderedMap;\\n\\n\\nvar decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {\\n  var key = block.key,\\n      type = block.type,\\n      data = block.data,\\n      text = block.text,\\n      depth = block.depth;\\n\\n\\n  var blockNodeConfig = {\\n    text: text,\\n    depth: depth || 0,\\n    type: type || 'unstyled',\\n    key: key || generateRandomKey(),\\n    data: Map(data),\\n    characterList: decodeCharacterList(block, entityMap)\\n  };\\n\\n  return blockNodeConfig;\\n};\\n\\nvar decodeCharacterList = function decodeCharacterList(block, entityMap) {\\n  var text = block.text,\\n      rawEntityRanges = block.entityRanges,\\n      rawInlineStyleRanges = block.inlineStyleRanges;\\n\\n\\n  var entityRanges = rawEntityRanges || [];\\n  var inlineStyleRanges = rawInlineStyleRanges || [];\\n\\n  // Translate entity range keys to the DraftEntity map.\\n  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {\\n    return entityMap.hasOwnProperty(range.key);\\n  }).map(function (range) {\\n    return _extends({}, range, { key: entityMap[range.key] });\\n  })));\\n};\\n\\nvar addKeyIfMissing = function addKeyIfMissing(block) {\\n  return _extends({}, block, {\\n    key: block.key || generateRandomKey()\\n  });\\n};\\n\\n/**\\n * Node stack is responsible to ensure we traverse the tree only once\\n * in depth order, while also providing parent refs to inner nodes to\\n * construct their links.\\n */\\nvar updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {\\n  var nodesWithParentRef = nodes.map(function (block) {\\n    return _extends({}, block, {\\n      parentRef: parentRef\\n    });\\n  });\\n\\n  // since we pop nodes from the stack we need to insert them in reverse\\n  return stack.concat(nodesWithParentRef.reverse());\\n};\\n\\n/**\\n * This will build a tree draft content state by creating the node\\n * reference links into a single tree walk. Each node has a link\\n * reference to \\\"parent\\\", \\\"children\\\", \\\"nextSibling\\\" and \\\"prevSibling\\\"\\n * blockMap will be created using depth ordering.\\n */\\nvar decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {\\n  return blocks\\n  // ensure children have valid keys to enable sibling links\\n  .map(addKeyIfMissing).reduce(function (blockMap, block, index) {\\n    !Array.isArray(block.children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\\n\\n    // ensure children have valid keys to enable sibling links\\n    var children = block.children.map(addKeyIfMissing);\\n\\n    // root level nodes\\n    var contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(block, entityMap), {\\n      prevSibling: index === 0 ? null : blocks[index - 1].key,\\n      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,\\n      children: List(children.map(function (child) {\\n        return child.key;\\n      }))\\n    }));\\n\\n    // push root node to blockMap\\n    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);\\n\\n    // this stack is used to ensure we visit all nodes respecting depth ordering\\n    var stack = updateNodeStack([], children, contentBlockNode);\\n\\n    // start computing children nodes\\n    while (stack.length > 0) {\\n      // we pop from the stack and start processing this node\\n      var node = stack.pop();\\n\\n      // parentRef already points to a converted ContentBlockNode\\n      var parentRef = node.parentRef;\\n      var siblings = parentRef.getChildKeys();\\n      var _index = siblings.indexOf(node.key);\\n      var isValidBlock = Array.isArray(node.children);\\n\\n      if (!isValidBlock) {\\n        !isValidBlock ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\\n        break;\\n      }\\n\\n      // ensure children have valid keys to enable sibling links\\n      var _children = node.children.map(addKeyIfMissing);\\n\\n      var _contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(node, entityMap), {\\n        parent: parentRef.getKey(),\\n        children: List(_children.map(function (child) {\\n          return child.key;\\n        })),\\n        prevSibling: _index === 0 ? null : siblings.get(_index - 1),\\n        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)\\n      }));\\n\\n      // push node to blockMap\\n      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);\\n\\n      // this stack is used to ensure we visit all nodes respecting depth ordering\\n      stack = updateNodeStack(stack, _children, _contentBlockNode);\\n    }\\n\\n    return blockMap;\\n  }, OrderedMap());\\n};\\n\\nvar decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {\\n  return OrderedMap(blocks.map(function (block) {\\n    var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));\\n    return [contentBlock.getKey(), contentBlock];\\n  }));\\n};\\n\\nvar decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {\\n  var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);\\n  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;\\n\\n  if (!experimentalTreeDataSupport) {\\n    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);\\n  }\\n\\n  return decodeContentBlockNodes(rawBlocks, entityMap);\\n};\\n\\nvar decodeRawEntityMap = function decodeRawEntityMap(rawState) {\\n  var rawEntityMap = rawState.entityMap;\\n\\n  var entityMap = {};\\n\\n  // TODO: Update this once we completely remove DraftEntity\\n  Object.keys(rawEntityMap).forEach(function (rawEntityKey) {\\n    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],\\n        type = _rawEntityMap$rawEnti.type,\\n        mutability = _rawEntityMap$rawEnti.mutability,\\n        data = _rawEntityMap$rawEnti.data;\\n\\n    // get the key reference to created entity\\n\\n    entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});\\n  });\\n\\n  return entityMap;\\n};\\n\\nvar convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {\\n  !Array.isArray(rawState.blocks) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentState') : invariant(false) : void 0;\\n\\n  // decode entities\\n  var entityMap = decodeRawEntityMap(rawState);\\n\\n  // decode blockMap\\n  var blockMap = decodeRawBlocks(rawState, entityMap);\\n\\n  // create initial selection\\n  var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());\\n\\n  return new ContentState({\\n    blockMap: blockMap,\\n    entityMap: entityMap,\\n    selectionBefore: selectionState,\\n    selectionAfter: selectionState\\n  });\\n};\\n\\nmodule.exports = convertFromRawToDraftState;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"_extends\",\"_assign\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"key\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"ContentBlock\",\"ContentBlockNode\",\"ContentState\",\"DraftEntity\",\"DraftFeatureFlags\",\"DraftTreeAdapter\",\"Immutable\",\"SelectionState\",\"createCharacterList\",\"decodeEntityRanges\",\"decodeInlineStyleRanges\",\"generateRandomKey\",\"invariant\",\"experimentalTreeDataSupport\",\"draft_tree_data_support\",\"List\",\"Map\",\"OrderedMap\",\"decodeBlockNodeConfig\",\"block\",\"entityMap\",\"data\",\"blockNodeConfig\",\"text\",\"depth\",\"type\",\"characterList\",\"decodeCharacterList\",\"entityRanges\",\"inlineStyleRanges\",\"filter\",\"range\",\"map\",\"addKeyIfMissing\",\"updateNodeStack\",\"stack\",\"nodes\",\"parentRef\",\"nodesWithParentRef\",\"concat\",\"reverse\",\"decodeContentBlockNodes\",\"blocks\",\"reduce\",\"blockMap\",\"index\",\"Array\",\"isArray\",\"children\",\"contentBlockNode\",\"prevSibling\",\"nextSibling\",\"child\",\"set\",\"getKey\",\"node\",\"pop\",\"siblings\",\"getChildKeys\",\"_index\",\"indexOf\",\"isValidBlock\",\"_children\",\"_contentBlockNode\",\"parent\",\"get\",\"size\",\"decodeContentBlocks\",\"contentBlock\",\"decodeRawEntityMap\",\"rawState\",\"rawEntityMap\",\"keys\",\"forEach\",\"rawEntityKey\",\"_rawEntityMap$rawEnti\",\"__create\",\"mutability\",\"convertFromRawToDraftState\",\"isTreeRawBlock\",\"rawBlocks\",\"fromRawStateToRawTreeState\",\"fromRawTreeStateToRawState\",\"selectionState\",\"isEmpty\",\"createEmpty\",\"first\",\"selectionBefore\",\"selectionAfter\"]\n}\n"]